<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS层叠上下文、层叠等级、层叠顺序、z-index完全说明]]></title>
    <url>%2F2018%2F08%2F28%2Fz-index%2F</url>
    <content type="text"><![CDATA[前言最近，在项目中遇到一个关于CSS中元素z-index属性的问题，具体问题不太好描述，总结起来就是当给元素和父元素色设置position属性和z-index相关属性后，页面上渲染的元素层级结果和我预想的不一样。根据自己之前的理解，也没找到一个合理的解释。我知道，肯定是我对相关属性的细节理解存在问题，所以结合官方文档和在网上各种搜集整理，明白了其中的原因。写下这篇文章，和大家分享有关CSS中层叠上下文、层叠等级、层叠顺序以及z-index相关的一整套技术细节。 如果存在什么错误或重要遗漏或者有什么疑问，欢迎留言指正、讨论！感谢！ 一个“片面”的理解以往，由于自己使用z-index的频率不大，所以对这个CSS属性存在比较片面的认识。一直认为z-index就是用来描述定义一个元素在屏幕Y轴上的堆叠顺序。z-index值越大在Y轴上就越靠上，也就是离屏幕观察者越近。最后才发现这个认识存在很大的问题： 首先，z-index属性值并不是在任何元素上都有效果。它仅在定位元素（定义了position属性，且属性值为非static值的元素）上有效果。 判断元素在Y轴上的堆叠顺序，不仅仅是直接比较两个元素的z-index值的大小，这个堆叠顺序实际由元素的层叠上下文、层叠等级共同决定。 要想完全理解一个东西，首先要明白它是什么，也就是它的定义。我们先看看上面提到的层叠上下文、层叠等级、层叠顺序都是什么？定义又太过抽象，后面会再用一个具象的比喻来让你彻底明白它们到底是什么，有什么联系。 什么是“层叠上下文”层叠上下文(stacking context)，是HTML中一个三维的概念。在CSS2.1规范中，每个盒模型的位置是三维的，分别是平面画布上的X轴，Y轴以及表示层叠的Z轴。一般情况下，元素在页面上沿X轴Y轴平铺，我们察觉不到它们在Y轴上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。 如果一个元素含有层叠上下文，(也就是说它是层叠上下文元素)，我们可以理解为这个元素在z轴上就“高人一等”，最终表现就是它离屏幕观察者更近。 具象的比喻：你可以把层叠上下文元素理解为理解为该元素当了官，而其他非层叠上下文元素则可以理解为普通群众。凡是“当了官的元素”就比普通元素等级要高，也就是说元素在Z轴上更靠上，更靠近观察者。 什么是“层叠等级”那么，层叠等级指的又是什么？层叠等级(stacking level，叫“层叠级别”/“层叠水平”也行) 在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在Z轴上的上下顺序。 在其他普通元素中，它描述定义的是这些普通元素在Z轴上的上下顺序。 说到这，可能很多人疑问了，不论在层叠上下文中还是在普通元素中，层叠等级都表示元素在Z轴上的上下顺序，那就直接说它描述定义了所有元素在Z轴上的上下顺序就OK啊！为什么要分开描述？ 为了说明原因，先举个栗子： 具象的比喻：我们之前说到，处于层叠上下文中的元素，就像是元素当了官，等级自然比普通元素高。再想象一下，假设一个官员A是个省级领导，他下属有一个秘书a-1，家里有一个保姆a-2。另一个官员B是一个县级领导，他下属有一个秘书b-1，家里有一个保姆b-2。a-1和b-1虽然都是秘书，但是你想一个省级领导的秘书和一个县级领导的秘书之间有可比性么？甚至保姆a-2都要比秘书b-1的等级高得多。谁大谁小，谁高谁低一目了然，所以根本没有比较的意义。只有在A下属的a-1、a-2以及B下属的b-1、b-2中相互比较大小高低才有意义。 再类比回“层叠上下文”和“层叠等级”，就得出一个结论： 普通元素的层叠等级优先由其所在的层叠上下文决定。 层叠等级的比较只有在当前层叠上下文元素中才有意义。不同层叠上下文中比较层叠等级是没有意义的。 如何产生“层叠上下文”前面说了那么多，知道了“层叠上下文”和“层叠等级”，其中还有一个最关键的问题：到底如何产生层叠上下文呢？如何让一个元素变成层叠上下文元素呢？ 其实，层叠上下文也基本上是有一些特定的CSS属性创建的，一般有3种方法： HTML中的根元素&lt;html&gt;&lt;/html&gt;本身j就具有层叠上下文，称为“根层叠上下文”。 普通元素设置position属性为非static值并设置z-index属性为具体数值，产生层叠上下文。 CSS3中的新属性也可以产生层叠上下文。 至此，终于可以上代码了，我们用代码说话，来验证上面的结论： 栗子1:有两个div，p.a、p.b被包裹在一个div里，p.c被包裹在另一个盒子里，只为.a、.b、.c设置position和z-index属性12345678910111213141516171819202122232425262728293031323334353637383940&lt;style&gt; div &#123; position: relative; width: 100px; height: 100px; &#125; p &#123; position: absolute; font-size: 20px; width: 100px; height: 100px; &#125; .a &#123; background-color: blue; z-index: 1; &#125; .b &#123; background-color: green; z-index: 2; top: 20px; left: 20px; &#125; .c &#123; background-color: red; z-index: 3; top: -20px; left: 40px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt; &lt;p class="a"&gt;a&lt;/p&gt; &lt;p class="b"&gt;b&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p class="c"&gt;c&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; 效果：因为p.a、p.b、p.c三个的父元素div都没有设置z-index，所以不会产生层叠上下文，所以.a、.b、.c都处于由&lt;html&gt;&lt;/html&gt;标签产生的“根层叠上下文”中，属于同一个层叠上下文，此时谁的z-index值大，谁在上面。 栗子2：有两个div，p.a、p.b被包裹在一个div里，p.c被包裹在另一个盒子里，同时为两个div和.a、.b、.c设置position和z-index属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; div &#123; width: 100px; height: 100px; position: relative; &#125; .box1 &#123; z-index: 2; &#125; .box2 &#123; z-index: 1; &#125; p &#123; position: absolute; font-size: 20px; width: 100px; height: 100px; &#125; .a &#123; background-color: blue; z-index: 100; &#125; .b &#123; background-color: green; top: 20px; left: 20px; z-index: 200; &#125; .c &#123; background-color: red; top: -20px; left: 40px; z-index: 9999; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="box1"&gt; &lt;p class="a"&gt;a&lt;/p&gt; &lt;p class="b"&gt;b&lt;/p&gt; &lt;/div&gt; &lt;div class="box2"&gt; &lt;p class="c"&gt;c&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 效果：我们发下，虽然p.c元素的z-index值为9999，远大于p.a和p.b的z-index值，但是由于p.a、p.b的父元素div.box1产生的层叠上下文的z-index的值为2，p.c的父元素div.box2所产生的层叠上下文的z-index值为1，所以p.c永远在p.a和p.b下面。 同时，如果我们只更改p.a和p.b的z-index值，由于这两个元素都在父元素div.box1产生的层叠上下文中，所以，谁的z-index值大，谁在上面。 什么是“层叠顺序”说完“层叠上下文”和“层叠等级”，我们再来说说“层叠顺序”。“层叠顺序”(stacking order)表示元素发生层叠时按照特定的顺序规则在Z轴上垂直显示。由此可见，前面所说的“层叠上下文”和“层叠等级”是一种概念，而这里的“层叠顺序”是一种规则。 在不考虑CSS3的情况下，当元素发生层叠时，层叠顺讯遵循上面途中的规则。这里值得注意的是： 左上角”层叠上下文background/border“指的是层叠上下文元素的背景和边框。 inline/inline-block元素的层叠顺序要高于block(块级)/float(浮动)元素。 单纯考虑层叠顺序，z-index: auto和z-index: 0在同一层级，但这两个属性值本身是有根本区别的。 对于上面第2条，为什么inline/inline-block元素的层叠顺序要高于block(块级)/float(浮动)元素？这个大家可以思考一下！其实很简单，像border/background属于装饰元素的属性，浮动和块级元素一般用来页面布局，而网页设计之初最重要的就是文字内容，所以在发生层叠时会优先显示文字内容，保证其不被覆盖。 你要的“套路”上面说了那么多，可能你还是有点懵。这么多概念规则，来点最实际的，有没有一个“套路”当遇到元素层叠时，能很清晰地判断出他们谁在上谁在下呢？答案是——肯定有啊！ 1、首先先看要比较的两个元素是否处于同一个层叠上下文中：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1如果是，谁的层叠等级大，谁在上面（怎么判断层叠等级大小呢？——看“层叠顺序”图）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2如果两个元素不在统一层叠上下文中，请先比较他们所处的层叠上下文的层叠等级。2、当两个元素层叠等级相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上。 光说不练假把式对于技术学习，代码展示是最直观最易懂的方式之一。话不多说，直接上代码，我们通过以下几个“栗子”，来进一步验证掌握上面的结论。 栗子1：1234567891011121314151617181920212223242526272829303132333435&lt;style&gt; .box1, .box2 &#123; position: relative; z-index: auto; &#125; .child1 &#123; width: 200px; height: 100px; background: #168bf5; position: absolute; top: 0; left: 0; z-index: 2; &#125; .child2 &#123; width: 100px; height: 200px; background: #32c292; position: absolute; top: 0; left: 0; z-index: 1; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt; &lt;div class="child1"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="box2"&gt; &lt;div class="child2"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 效果：说明：.box1/.box2虽然设置了position: relative，但是z-index: auto的情况下，这两个div还是普通元素，并没有产生层叠上下文。所以，child1/.child2属于&lt;html&gt;&lt;/html&gt;元素的“根层叠上下文”中，此时，谁的z-index值大，谁在上面。 栗子2： 对于栗子1中的CSS代码，我们只把.box1/.box2的z-index属性值改为数值0，其余不变。12345.box1, .box2 &#123; position: relative; z-index: 1;&#125;... 效果：说明： 此时，我们发现，仅仅修改了.box1/.box2的z-index属性值改为数值0，最终结果完全相反。这时.child2覆盖在了.child1上面。原因是什么呢？很简单：因为设置z-index: 0后，.box1/.box2产生了各自的层叠上下文，这时候要比较.child1/.child2的层叠关系完全由父元素.box1/.box2的层叠关系决定。但是.box1/.box2的z-index值都为0，都是块级元素（所以它们的层叠等级，层叠顺序是相同的），这种情况下，在DOM结构中后面的覆盖前面的，所以.child2就在上面。 CSS3中的属性对层叠上下文的影响CSS3中出现了很多新属性，其中一些属性对层叠上下文也产生了很大的影响。如下： 父元素的display属性值为flex|inline-flex，子元素z-index属性值不为auto的时候，子元素为层叠上下文元素； 元素的opacity属性值不是1； 元素的transform属性值不是none； 元素mix-blend-mode属性值不是normal`； 元素的filter属性值不是none； 元素的isolation属性值是isolate； will-change指定的属性值为上面任意一个； 元素的-webkit-overflow-scrolling属性值设置为touch。 CSS3中，元素属性满足以上条件之一，就会产生层叠上下文。我们用第1条来做一个简单的解释说明。 栗子1： 12345678910111213141516171819202122232425262728&lt;style&gt; .box &#123; &#125; .parent &#123; width: 200px; height: 100px; background: #168bf5; /* 虽然设置了z-index，但是没有设置position，z-index无效，.parent还是普通元素，没有产生层叠上下文 */ z-index: 1; &#125; .child &#123; width: 100px; height: 200px; background: #32d19c; position: relative; z-index: -1; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="parent"&gt; parent &lt;div class="child"&gt;child&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 效果：说明： 我们发现，.child被.parent覆盖了。按照“套路”来分析一下：虽然.parent设置了z-index属性值，但是没有设置position属性，z-index无效，所以没有产生层叠上下文，.parent还是普通的块级元素。此时，在层叠顺序规则中，z-index值小于0的.child会被普通的block块级元素.parent覆盖。 对于上面的栗子，我们只修改.box的属性，设置display: flex，其余属性和DOM结构不变。123.box &#123; display: flex;&#125; 效果：说明： 当给.box设置display: flex时，.parent就变成层叠上下文元素，根据层叠顺序规则，层叠上下文元素的background/border的层叠等级小于z-index值小于0的元素的层叠等级，所以z-index值为-1的.child在.parent上面。 小测试下面的代码，我会把最终页面渲染的结果放在代码之后，有兴趣的“童鞋”可以分析一下，各个元素的层叠等级，最后来确定这些元素哪个在上哪个在下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;style&gt; .parent &#123; width: 100px; height: 200px; background: #168bf5; position: absolute; top: 0; left: 0; z-index: 0; &#125; .child1 &#123; width: 100px; height: 200px; background: #32d19c; position: absolute; top: 20px; left: 20px; z-index: 1; &#125; .child2 &#123; width: 100px; height: 200px; background: #e4c950; position: absolute; top: 40px; left: 40px; z-index: -1; &#125; .child2-1 &#123; width: 100px; height: 200px; background: #e45050; position: absolute; top: 60px; left: 60px; z-index: 9999; &#125; .child2-2 &#123; width: 100px; height: 200px; background: #db68a7; position: absolute; top: 80px; left: 40px; z-index: -9999; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="parent"&gt; parent &lt;div class="child1"&gt;child1&lt;/div&gt; &lt;div class="child2"&gt; child2 &lt;div class="child2-1"&gt;child2-1&lt;/div&gt; &lt;div class="child2-2"&gt;child2-2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 效果： 参考文章以上的内容有一部分内容参考了以下两位大神的博客，写的很好，也很清晰，推荐大家看一看，你会对相关知识点掌握的更清晰。 张鑫旭-《深入理解CSS中的层叠上下文和层叠顺序》AMInInsist-《CSS 中的z-index属性》]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[愿你拥有“太阳”，亦拥有“繁星”]]></title>
    <url>%2F2018%2F08%2F20%2Frandom-thoughts-2%2F</url>
    <content type="text"><![CDATA[近来在网上读到一段话，很是触动。网上标注这段话出自英国著名女作家，2007年诺贝尔文学奖获得者多丽丝·莱莘的长篇小说《幸存者回忆录》，我粗略地阅读原著后并未在文中找到这段话，但可以肯定的是这段话确实出自莱莘笔下。进来，计划通读此书，再对以上话语作出最后定论。 不论最终结论肯定与否，最重要的是，这段话的内容，值得每一个读到他的人深思。原文如下所言： 做孩子的时候，感到无聊，盼望着长大。长大后，又向往返回童年。我们浪费自己的健康，去赢得个人的财富,然后又浪费自己的财富去重建自己的健康。我们焦虑地憧憬着未来，忘记了眼前的生活，活得既不是为了现在，也不是为了未来。我们活得似乎永远不会死，我们死得好像从来没活过。 文中最后两句话，尤其触动我的内心。私以为，这两句话一针见血地、深刻地总结了很多人的生活方式和生活意义。莱莘，英国人，都说艺术源于生活但高于生活，我倒觉得，文中的话用来描述很多人的生活和生命历程也是再贴切不过了。 我们拼命地奔波，没日没夜的工作，放弃了休息团聚，忘记了春夏秋冬，看不到世界的“千里丹青”…… 我们苦苦追求，追求心中“向往的生活”。认为这只要现在“拼命”，以后就能过上想要的日子，就不用再“受罪”。我们总觉得来日方长，此时苦点儿没什么，以后“赢了”总有机会享受，好日子还在后头。可到后来，慢慢的，我们发现脖子不好了，腰不好了，胃不好了，血糖高了，血压也高了…… 迫不得已，再用浪费健康换得的为数不多的财富支付昂贵的医药费去重建自己的健康，之后再y因为巨额的花销更加“拼命”…… 就这样，一直“乐此不疲”、“义无反顾”地走在这个“死循环”里。我们活得似乎永远不会死。 到最后回首往昔，这一路走来却艰辛无比，我们反而失去很多，陪家人的时间少了，挚友少了，感情淡了，思考的时间少了，欢声笑语少了，甚至浪费了健康，却未见赢得多少财富，“好日子”似乎依旧遥遥无期。其实，我们忽略了一点，并非生活没有变好，也不是努力没有意义，真正在于需求与欲望也同样在膨胀，而且远远快于你努力的速度。于是，我们变得焦虑，焦虑于现在的不如人意，焦虑于将来可能的“不堪”，渐渐地忘记了眼前的生活。这样的生活，活得既不是为了现在，也不是为了未来。直到将要“告别”的时候，一切走到尽头，才恍然发现，我们没留下多少，更没有带走什么，我们死得好像从来没活过。真正的悲哀，莫过于此…… 泰戈尔在《飞鸟集》中有一首脍炙人口又富含哲理的诗： 如果你因错过太阳而哭泣，那么你也将失去繁星。 作者在洞察自然的同时用妙笔告诫人们：不要过分悲伤于错过的美好，珍惜眼前。短短二十几言，告诉了我们失与得联系，告诉我们化失望为希望，化悲伤为幸福的方法。而莱莘的文字中，正好描写了“铜币的另一面”——我们不仅错过了“太阳”，我们也失去了“繁星”。 大冰在《乖，摸摸头》如是说 ： 你我都明白，这从来就不是公平的世界。人们起点不同，路径不同，乃至遭遇不同，命运不同。有人认命，有人顺命，有人抗命，有人玩命，希望和失望交错而生，倏尔一生。 短短的一生中，有的人真正意义上获得的只是短暂的欣喜，更多的却是长久的自我煎熬。愿你的生活，与之相反，愿你拥有“太阳”，亦拥有璀璨的“繁星”。]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>阅读感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生命难以承受的“2 ℃"]]></title>
    <url>%2F2018%2F08%2F10%2Fjournal-2%2F</url>
    <content type="text"><![CDATA[“番茄炒蛋”近一个月来的西安城高温持续不下，与阴雨绵绵、凉爽怡人的7月初的差距算得上是天冠地屦，近几日的气温用“烁石流金”形容也是毫无夸张之嫌。在七八月份华南华北甚至全国“一片火热”的形势下，西安的温度也算是遥遥领先。当华南华北高温在地图上连上一片时，西安城的气温很多时候就像冬日那傲然的梅花，真可谓一枝独秀，也算是“雄鸡”中心最瞩目的一点。夏季的西安，在高温预报图上就是一个又红又紫，红得发紫的城市。 西安所处地理位置典型的温带季风性气候——夏季高温多雨，冬季寒冷干燥。看起来降水充足，但以个人的感受，西安的高温实在是有过之而无不及。下图是2018年8月13日，中央气象台发布的全国高温预报图，说西安“一枝独秀”、红得发紫，真的是名副其实。 下图是2018.07.14 - 2018.08.12全国高温分布图。每年七八月份，不仅是西安城，全国的气温预报图便成了一片又红又紫的“雄鸡”。网友也调侃着说，全国气温图看起来就像是一盘“番茄炒蛋”。 以上数据来源，中央气象台 最近的地球2018年，好像全球都比往年更加“火热”。 地球，好像发烧了，而且，高烧不退... 今年7月初，多个北非国家也出现热浪，撒哈拉沙漠地区最高气温达到51.3℃。世界气象组织说，这应该是阿尔及利亚可靠的温度记录中的最高值。持续的高温同样袭击了整个欧洲，瑞典、西班牙、葡萄牙、法国、意大利、德国、芬兰等几乎所有欧洲国家都出现了历史上罕见的高温天气。地处东欧的波兰，往年被视为避暑好去处，最近却连续遭遇30℃以上罕见高温，最高气温34℃。 北晚新视觉 - 《欧洲多地持续高温：局地或超47℃ 瑞典最高峰冰川融化4米》 此外，就连北极圈内也出现了罕见的超过30℃的高温，冰川融化，甚至严重威胁到北极熊的生存。茫茫无边的北极圈海面上天空阴沉昏暗，让人窒息，冰冷刺骨的海面上飘着一块孤零零的来自极地的冰山，一只北极熊蜷缩在上面睡着了。饥饿、劳累，但对于它来说，比海更广阔的是内心的孤独… 澎湃新闻 - 《四大洲同现极端高温北极圈罕见32℃，北极熊或40年内灭绝》百度百家号新闻 - 《北极圈出现罕见高温，北极熊将消失？》 这里，有一封来自北极熊的独白信。充满悲伤、孤独和无奈… 人类用了几十年就使几百万年的北极冰川大面积融化… 因饥饿与劳累北极熊溺死在北极冰冷的海水中… 以海豹为主食的北极熊，开始捕食鸟蛋、海豚，甚至撕碎并吃掉自己的孩子… 最后的图文中有一句话“不知道人类还记不记得，北极，Arctic，这个词源自希腊语，意思是 —— 被熊照耀的地方...” 如今的北极，好像也生病了… 而且，无法康复… 一串数字下面这一串数字，访问这里，你可以看到它在飞速增长。6240多亿（截止于2018.08.13，相信以后会越来越多），粗略估计大约每2秒就会增加1000。它代表什么？你所拥有的财富的增长？某个国家GDP总量的增长？地球氧气总量的增长？你可能会有很多猜测… 数据来源，这里 其实，它代表的是 自工业化以来，全球范围内人类在化石燃料使用、水泥制造、土地利用等活动中排放的二氧化碳总量，并且在实时更新 ，值得注意的是，该数值的单位是 吨。这就表示，自工业化以来全球目前排放二氧化碳 6240多亿吨 。第一次知道它代表的含义，在看着这飞速增长的数字，我心惊肉跳。我想让它走得慢一些… 我恨不得抓住它，抑制住它。可是，我无能为力，心有余而力不足… 那种焦虑和无助感，真的可以让你抓耳挠心塞。在这个网站页面主体的右下方，还有一个倒计时，目前，预计在2036年2月全球二氧化碳排放量达到10000亿吨，意味着那时全球平均温度较现在升高2℃左右。每一秒看着时间的走近，就让人觉得恐慌，灾难在一步步靠近… 笔者注：这一数据信息是我在阅读阮一峰大佬的这一片博客时获取到的，相信数据的真实性。个人对于这个数据，个人还存在一些疑问。 目前我还没有搞清楚该网站如何获得这一数据值的，同时也不清楚该网站如何做到实时同步全球二氧化碳排放量的。 这应该是一个估计值，个人感觉实际的二氧化碳排放量肯定是有过之而无不及。 全球变暖已经是活生生的现实。化石燃料的过度使用，温室气体大量排放，滥砍滥发，绿色植被逐年大幅减少，海平面上升… 现在的地球就像是一个天然的“烤炉”。 以下信息，引用自阮一峰博客科学家估计，目前的年平均气温比工业革命前已经升高了1度。《巴黎气候协议》的目标是，气温升高控制在2度，但是成功的希望据说只有5%。如果学过统计学，你就知道，5%的机会在统计学上可以视作不会发生。现在的计算是，如果人类排放10000亿吨二氧化碳，地球就会升高2度，千万不要觉得，2度不算什么，《纽约时报》描述了后果： 升高2度：热带珊瑚礁灭绝，海平面上升几米，波斯湾不适合人类居住。 升高3度：北极的森林和大多数沿海城市被淹没。 升高4度：欧洲永久干旱， 中国、印度和孟加拉国大部分地区变成沙漠，美国科罗拉多河接近干涸，美国西南部将不适合居住。 升高5度：人类文明终结。 我们到底要拯救谁第二次工业革命以来，人类社会飞速发展。起初，我们天真地以为地球资源取之不尽用之不竭，各个国家费劲一切力气开发一切可用资源——土地、石油、煤炭、天然气、海洋资源等等，为掠夺资源而发动战争也是屡见不鲜。我们错误地认为所谓位于食物链顶端的自由就是可以随意地拥有，我们陷入迷途肆意地挥洒，我们神仙迷途却毫不清楚、“义无反顾”… 到最后却要穷尽地球的所有… 我们的行为，极大地改变了地球生态，曾经的辉煌变成如今眼前的荒芜。全球气温升高，冰川面积锐减，海平面上升，极端天气骤多，臭氧层破坏，酸雨频发，生物多样性破坏，土地退化及荒漠化，森林面积锐减… 地球，愈来愈伤痕累累… 后来，我们“长大了”，意识到l 问题的严重性。政府颁布各种法律禁令，国际组织签订个多项协议公约，目的就是想尽力保护地球生态，而这些行为有一个几乎相同的口号——“保护地球，保护我们赖以生存的家园”。以前觉得这一口号言简意赅、目的明确，知错就改，还是“好孩子”。直到最近，在网上看到下面这样一段话，感触很深。 比起拯救地球，人类最需要拯救的是自己。地球她并不担心，因为她经历过更严重的灾难，毁灭般的气候变换，五次绝世大爆炸，数次核爆炸，数不清的火山喷发，社会动乱，彗星撞击，难以想象的冰川时期，各大洲错位的情况也时有发生，但是她都挺过来了，而且过得好好的。但，在这45亿年来，地球上96%的水生动物和70%的陆地脊椎动物都灭绝了。 太阳的寿命100亿年，它已经走过了漫长的50亿年，地球也已经46亿岁了。以一个最简单的模型估计，太阳的终结伴随着地球的湮灭，那么地球还有40多亿年的寿命。前45亿年，经历了那么多的“坎坷”，地球依旧好好的，我相信以后的40多亿年，也不会坏到哪去，可这并不代表人类就能一直好好好的。对于地球的“一生”来说，人类的出现好似沧海一粟那么渺小，在慢慢长河中，甚至比不上弹指一挥间的短暂。我们的出现，就像你在春日里看到的路边的野花，就像是夜晚昙花那一瞬的闪耀。 我们要明白，拯救地球，拯救的不是地球本身，地球也不需要我们来拯救。我们要拯救的，是自己，而这其中更多的是对人类自己过往的一种救赎。 也许，对于地球来说，在不久的将来，她会回到自己最初的模样，一切归于沉寂，一切会从头来过。而那时，她已失去所有，失去了日出月落，失去了碧海蓝天，失去了草长莺飞，失去了寒梅傲雪。更重要的，她失去了自己的“孩子”，失去了欢声笑语，失去了曾经的辉煌，曾经的一切… 可，她还在,在宇宙的一隅，叹一口长长的太息，哀婉于曾经“孩子”的欲望与迷途… 一首歌 最后，把我最喜欢的一位歌手——李健的一首歌曲《深海之寻》分享给大家。这是李健作为“国家海洋公益形象大使”为“世界海洋日暨中国海洋公益日”创作的宣传曲。在歌中采用与海洋“对话”式的表达，用反思的方式，写出了自然对人类的失望，人类对自然的亏欠。 深海之寻 作词：李健作曲：李健编曲：赵兆这无穷宇宙谁能看得透不知不觉中你已经远走我以为自由 是随意的拥有可是到最后 快一无所有我的辉煌让你黯淡了很久我的挥洒穷尽了你的所有在那拥挤的天空何止乌云密布我已经深陷迷途还不清楚竟义无反顾这无边海洋装不下欲望每一朵浪花都历经沧桑我的辉煌让你黯淡了很久我的挥洒穷尽了你的所有在那拥挤的天空何止乌云密布我已经深陷迷途还不清楚竟义无反顾曾经辉煌的地方如今已荒芜一路孤独铺满了你的去处在那风平浪静的下面暗流涌动我已经踏上征途 狂奔向你竟义无反顾Wu~ 这无穷宇宙Wu~ 谁能看得透Wu~ 让我奔向你Wu~ 给你我所有—— 李健·《深海之寻》 #iframe-ctn { padding: 0px; margin: 30px auto 30px; overflow: hidden; width: 800px; height: 95px; } #page-iframe { position: relative; left: 0px; top: -205px; } .data-resource { text-align:right; font-size: 12px; color: #999; } #arctic-pic img { float: left; height: 500px; } #content-ctn .content { width: 80%; margin: 0 auto; text-align: center; } #content-ctn .content span.date { padding-left: 100px; }]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>阅读感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇来自2016年的随想]]></title>
    <url>%2F2018%2F08%2F01%2Frandom-thoughts-1%2F</url>
    <content type="text"><![CDATA[序言这篇随想，其实不是近期的作品，实际写于2016年9月6日。当时的我还在读大三，按照学校的教学安排，那个时候需要进行生产实习，两种选择 —— 参加学校组织的或者自己找实习工作。我自己找了一家本地的互联网公司去实习，做前端开发工作，这也是真正意义上的第一份工作，这篇随想就写于实习期间。 当时的我刚开始尝试着从一个学生向一个职场IT工作者转变。说实话，并不是很顺利，自己也很不适应，所以那一阵子很煎熬，对未来正式工作也产生了迷茫。主要的原因是很多工作上和技术上的要求在学校学到的还差得很远，工作的环境氛围、压力和自己之前预想的、准备的差距较大，所以一时半会儿不太适应，当时也比较焦虑。实习期间，我一直住在学校宿舍，一天下班后，路过熟悉的校园，回想起过去近三年的大学生活，走在一条昏暗的小路上，突然有了一些感慨，回去就顺手写下了这篇随想。 图片摄于2016年07月15日-西安理工大学金花校区 正文 每个夜晚， 他都会向影子招手， 与草木问好， 昏暗幽静的小路上， 铺满一层层的煎熬与落寞。 他步伐缓慢， 一次次回望， 望见身后的挣扎先生， 神情依旧， 同样迈着缓缓的步子， 时不时也无奈地回头看。 一转身， 却又被自己撞到。 撞乱了春秋冬夏， 撞散了意念魂灵。 —— 2016.09.06 #content-ctn .content { width: 80%; margin: 0 auto; text-align: center; } #content-ctn .content span.date { padding-left: 100px; }]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>朝花夕拾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的工作是对生命的极大浪费]]></title>
    <url>%2F2018%2F08%2F01%2Fjournal-1%2F</url>
    <content type="text"><![CDATA[序言 这篇文章有一些桥段是我生活的影子，但本文的主人公完全虚构，不代表我和周围任何一个同事朋友。文章内容是我根据自己的经历更多是和不同朋友交流时了解到的加工而来。文章没有什么华丽的词藻，内容平铺直叙，但是我相信读下去你也许能在其中找到自己的影子或者是曾经熟悉的一幕。更多的是文章带有一些“魔幻”色彩，就是这一点点的“魔幻”成分才是文章中最大的暗示和思考。希望有兴趣的朋友能读下去，谢谢大家的支持！ 正文窗外，已经倾泻了一整夜的雨好像还是没有停下来的迹象。雨声伴着街道上汽车急促的鸣笛声再夹杂着发动机的轰鸣声传入屋内，又是一个繁忙嘈杂的早晨。窗内，昏昏沉沉，还在睡梦中的欧阳面色有些凝重，他应该又做梦了… 经济管理专业的欧阳，大学毕业后选择留在当地的一家民营私企从事行政相关的工作。平时就和一个朋友住在一起合租的小区公寓内。最近公司业务繁重，经常加班，他连续好几天加班到很晚，最近睡眠质量也不是很好。欧阳计划着，忙过这一阵，出去转一转，放松放松。 已经响过三次闹铃的手机再次响起，欧阳凭着仅仅清醒的些许意识，用手在枕边、枕头下一次次地摸索试探着，终于，在被窝里找到了“吵闹”了半天的手机。他缓缓睁开眼睛，眼皮重的就像是压在眼睛上的两座大山，双眼迷离，看了下时间 —— 2018年7月30日，早上8:00整。按下最后一遍闹铃开关，拖着“灌了铅”后又不听使唤的身躯，欧阳起身坐在床边，又闭上了眼睛，睁眼… 闭眼… 再睁眼… 每天起床就是一场持久的他和“周公”与“梦想”的拉锯战。一轮轮的交锋后，欧阳睁开眼睛，下床，懒散地拖着拖鞋，拿起洗漱用品，拖沓着身体走到卫生间，打开水龙头，欧阳看着镜子里的人，陌生又熟悉… 水漫出牙杯好一会儿，他才回过神，牙膏被肆意地挤在牙刷上，伸到嘴里漫无目的地游走一会儿，漱口。用冷水打湿面部，快速地搓一搓，反复几次，擦干，洗漱完毕。一瓶快要被挤得变形的“大宝”，勉勉强强地挤出一点到手上，在脸上四面八方地搓一搓，算是给他原本还帅气的脸上唯一“精致”的保养。穿上衣服，换上鞋，背上包，出门… 一天的工作又要开始了… 公寓电梯口，几乎层层都停的电梯好不容易停在自己面前，人快要挤满了… 欧阳挤进电梯，昨天好像也是这些人… 因为住在同一栋，遇到很正常，欧阳也没有多想。而所有人都像极了刚刚镜子里的自己，面无表情，睡眼惺忪，可能甚至都有人不知道电梯里又多了一个他。电梯下行，人越来越多，狭小的空间里越来越拥挤，早些进来的人也越来越着急。终于，几分钟过去，到了一层，所有人都急匆匆地涌出电梯，向小区门口赶去。欧阳似乎不善于争抢，踉踉跄跄的最后一个挤了出来。 外面还下着雨，公司离公寓说远不远，说近，将近5公里的距离，开“11路”走过去也不现实，况且早上时间本就不充裕。挤公交，住处到公司没有直达车，倒车、等车的时间换做骑车他骑个来回，这就很尴尬了… 所以，上班一年多以来，不论春夏秋冬，刮风下雨还是下雪，他都是骑车上班，也练就了一手撑伞一手骑车的“绝技”。撑着伞，在小区门口东张西望，不凑巧，今天运气不佳，“坐骑”被抢光了。欧阳住的小区是工薪族聚集地，一个小区八成左右都是上班族，每天早上稍微晚点,门口的共享单车就没你的份了。他也习以为常，老样子，沿着去公司的路先开“11路”吧，运气好路上还能捡到“宝”…几分钟后，他在街角发现一辆“某拜”，急匆匆赶过去，还没到跟前，被别人“截胡”了… 看着那人，欧阳脸上就是一幅复制版的“尴尬又不失礼貌的微笑”的表情包。再走一段路，又看见一辆，欧阳冲了过去，再被“截胡”的话今天就要迟到了！还好，没人和他抢，掏出手机，打开车锁，跨上车，刚骑没几米，发现后车轮有点瓢…“点儿真背！”，欧阳嘴里嘀咕着，“算了，赶时间，凑活着骑”，欧阳一手撑着伞，一手骑车把着方向，一路“哐啷…哐啷…”地往公司赶去… 一路晃荡，欧阳边骑边想：“早上看手机，今天是几号来着？”他在盘算着还有几天能休息？什么时候能放假，他想出去走走。一个不留神，车轮好像压到一块硬硬的东西，加上雨天路滑和这不争气的“坐骑”，欧阳连人带车就要摔倒在地上… 一瞬间，躺在床上的欧阳睁开眼睛，一身冷汗… 幸亏，幸亏，原来是个梦… 他看了一眼手机，2018年7月30日，早上8点10分，星期一。“靠！要迟到了！”，他下意识地喊了一句。着急忙慌穿上拖鞋，拿起洗漱用品来到卫生间，镜子里的自己依旧陌生又熟悉，这场景好像在哪见过？哪有功夫想那么多，同样的步骤，刷牙，洗脸，换衣服，背上包，出门，挤进依旧人满为患的电梯下楼，来到小区门口“抢”到一辆单车，今天还算幸运。一路狂飙来到公司楼下，电梯口长长的队伍，欧阳心里暗想：“妹的，又要迟到了…”。夏天高温，电梯里又闷又热，各种“迷人”的汗味混杂着各式早餐的味道，有点辣眼睛… 走进公司，伸手去打卡的瞬间，欧阳楞了一下，“咦，是不是已经打过卡了？”很快，他就否定了自己这个愚蠢的疑问。今天刚到公司，怎么可能打过卡？过糊涂了？没再多想，欧阳朝着自己的工位走了过去。跟往常一样，和同事打过招呼之后，欧阳坐在工位上，一刹那好像回到了昨天。“昨天同样如此坐在这，就好像是几小时甚至几分钟前的事”，欧阳心里一阵感叹… 看着电脑屏幕上隐约倒映出来的自己的脸，越看越陌生，越看越不像自己。毕业一年多来，由于工作和生活的压力，欧阳的确看起来憔悴了许多。每天的工作排得满满当当，加班几乎成了家常便饭，工作到凌晨一两点也是时不时会有的事。慢慢的，他也适应习惯了，唯一的就是身体逐渐消瘦了下来，还好，总体状况倒也健康。 “欧阳！”，背后的声音才让他回过神来，是老大 —— 一个最近让他烦透也恶心透了的人。平时大小事都不管，关键时刻总爱抛头露面装个13，没事总爱跪舔上级，最主要的，时不时话语中还不尊重同事。以前没发现，日子久了，欧阳真的是看不惯这种自以为是又没有素质的人，越看越觉得恶心。但，人家是领导，能有什么办法…? “昨天让你准备的材料真被好了没？今天郑总开会要用呢！”讨厌归讨厌，欧阳还是一脸不悲不喜的回到：“好了…” 他顺手把材料递过去，老大转身的时候欧阳一脸不屑的竖起中指。忙碌的一天又要开始了…欧阳像往常一样东奔西跑，前答后应，忙个不停，而这，只是他工作的日常罢了… 好不容易熬到中午，可以喘口气了。公司中午有两个小时的休息时间，也是白天唯一能放松的时段。七八月份，正是一年中最热的时候，欧阳和同事一起在楼下的小店里买了一份九块钱的快餐，因为公司能吹空调就带回了公司，坐在工位上开始了自己的午餐时间。一份快餐，三四个菜，荤腥少的可怜，吃饱可以，但毫无质量可言。十几分钟后，一天的主食也就结束了，简单收拾停当，欧阳趴在工位上玩起了手机，这是他一天中为数不多可以了解到“外面世界”的机会。刷一刷各类新闻，看一看明星八卦，欧阳又在盘算着，希望忙过这一段能出去转一转。毕竟，世界那么大，他也想去看看… 搁下手机，放下座椅靠背，躺下去，很快他就睡着了… “叮铃铃铃…”，一阵铃声在耳边响起，欧阳睁开眼睛确是傻了眼，“我靠！什么情况？怎么还躺在床上！？” 欧阳像见鬼了一样不敢相信眼前的自己竟然还躺在公寓的床上！“玩什么？‘盗梦空间’么？梦中梦！？还是…现在还是在做梦？”欧阳脑子飞转，却怎么也想不明白，刚才梦里的一切也太真实了吧！越像越瘆得慌，欧阳学电视里掐了一下自己，“靠，真的疼，不是梦…”拿起手机看了看时间，2018年7月30日，早上8:00整,到了上班的时间。上班第一，欧阳也没敢再想太多，还是每天按部就班的流程，洗漱，换衣服，出门，挤电梯，抢“坐骑”… 欧阳一路赶到公司，又开始了一天的忙碌… “欧阳，这堆报表按日期整理一下！”，“欧阳，这些财报一会给郑总送过去！”，“欧阳，公司该买电了！”，“欧阳，最近招聘季，注意注意有没有求职者应聘！”，“欧阳，明天张总要过来，提前联系一下！”，“欧阳”，“欧阳”… 因为公司规模不大，一个人顶两个人用，加上欧阳本身又比较勤恳办事也靠谱，所以作为行政岗的欧阳其实做了很多非本岗位的事情。就这样不可开交，“前赴后继”，等大事小事真正忙完又将近晚上11点了。欧阳看着窗外的夜色，街道上车水马龙黑，远处灯火阑珊，渐渐地他的眼神有些迷离。黑夜就像是深渊，盯着太久了，就出不来了，欧阳陷进去，沉思了很久….. 回过神来，欧阳收拾收拾工位，关了电脑，关上公司大门，乘着电梯下楼去了… 刚出写字楼，温热的风还在静静的吹，因为时间太晚，视野里已经找不到共享单车的踪迹，欧阳沿着回去的路，独自一人，慢慢地往回走… 回到公寓的时候已经近子夜时分了，夏天的夜晚温度依旧不低，这一路走来一身黏腻，卸下一身疲惫，欧阳简单地冲了个凉就躺下了。很快，他睡着了… 明天，又是普通却繁忙的一天，所有的一切还会继续… 当清晨的第一缕阳光划破天际，窗外，雨水好像早已停歇，鸣笛声和发动机的声音依旧“热热闹闹”。窗内，光线还是那么的昏暗。欧阳被最后一遍闹铃叫醒，惺忪的睡眼慢慢睁开，关掉闹钟，当看到手机上显示的时间，欧阳怔了一下，瞳孔瞬间扩大。他双手颤抖着把手机拿进，白色的眼球上瞬间布满血丝，全身寒毛卓竖，因为，手机上赫然是显示着时间：2028年7月31日，早上8:00整，星期一…… 后记 谢谢您能读完这篇文章。就像“序言”中全所言，全文内容并不华丽，但略带“魔幻”的“盗梦空间”情节，是文章最大的暗示，也是最发人深省的部分。主人公欧阳一天中总感觉很多事似乎刚发生，很多场景也很熟悉，其实是因为他每一天都在重复着相同的事情，被工作占据了几乎所有的生活，所以脑海中只有这些事情记忆最深刻。还有隐藏的一点，按照逻辑全文看似几乎都发生在2018年7月30日这一天，其实这一天只是欧阳一天天工作生活的一个缩影和循环。每一次从梦中醒来，实际暗示着已经过去了一天甚至是很多天。直到最后，欧阳再一次醒来，才发现，时间飞逝，已经是10年之后的2028年了。 其实很多时候，我们会发现繁忙的工作和沉重的生活压力，让我们每天都过得失去了色彩，更甚至我们每天都在重复做着几乎相同的事情，日复一日…… 转眼间，可能就是几年甚至十几年。这也是现代人经常感叹时间很快的一个重要原因。所以，希望大家能在繁重的工作之余，给自己的生活增添一抹亮丽的色彩。毕竟，这个世界以及来到这个世界的幸运从来不值得被我们辜负。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>生活工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CreateJS 入门]]></title>
    <url>%2F2018%2F07%2F18%2Fcreate-js%2F</url>
    <content type="text"><![CDATA[什么是CreateJS 官网介绍 （中文）：CreateJS 是一组模块化代码库和工具套件，可以独立工作也可以组合工作，用于通过HTML5技术来在网页上开发丰富的交互式内容。 四个核心库CreateJS主要包含如下四个类库： EaselJS – 简化处理HTML5画布（核心） TweenJS – 用来帮助设计H5动画，调整HTML5属性 SoundJS – 用来简化处理HTML5 audio 音频 PreloadJS – 帮助管理和协调加载中的一些资源 今天，主要来了解一下 EaselJS 库 EaselJS EaselJS 简介 EaselJS 是一个JavaScript库,用来简单快捷的操作 HTML5 Canvas 标签。在创建H5游戏，生成艺术作品、处理其他高级图形化等工作中有着很友好的体验。 EaselJS中的一些核心类 Stage Class – 创建舞台 Text Class – 绘制文字 Graphics Class – 绘制图形 Shape Class – 绘制图形 Bitmap Class – 绘制图片 Ticker Class – 定时广播 ……等 一些”栗子”绘制文本(Text Class)定义一个&lt;canvas&gt; &lt;/canvas&gt; 画布。123// HTML:&lt;!-- Text Class 文本类--&gt;&lt;canvas id="demo1" width="650" height="400"&gt;&lt;/canvas&gt; 调用EaselJS提供的API - new createjs.Text()，绘制文字12345678910111213141516171819202122232425262728293031323334353637// JS&lt;script src="https://code.createjs.com/1.0.0/createjs.min.js"&gt;&lt;/script&gt;&lt;script&gt; window.onload = () =&gt; &#123; /** * Test Class 文本类 -- demo */ let stage1 = new createjs.Stage("demo1"); let text1 = new createjs.Text("Text 1 !", "bold 26px Arial", "#ff7700"); text1.regX = -50; // 沿X轴负方向的偏移量 text1.regY = -50; // 沿Y轴负方向的偏移量 text1.x = 100; // 绘制源点 X坐标 text1.y = 50; // 绘制源点 Y坐标 let text2 = new createjs.Text("旋转+XY拉伸！", "bold 18px Arial", "#ff7700"); text2.x = 50; text2.y = 50; text2.rotation = 50; // 旋转角度 DEG text2.scaleX = 3; // X轴放大(拉伸) text2.scaleY = 2; // X轴放大(拉伸) let text3 = new createjs.Text("XY轴倾斜", "bold 50px Arial", "#ff7700"); text3.x = 300; text3.y = 200; text3.skewX = 45; // X轴倾斜角度 DEG text3.skewY = 20; // Y周倾斜角度 DEG let text4 = new createjs.Text("文字shadow", "bold 30px Arial", "#ff7700"); text4.x = 400; text4.y = 100; text4.shadow = new createjs.Shadow("#000000", 5, 5, 10); // 创建一个shadow实例Object stage1.addChild(text1, text2, text3, text4); stage1.update(); // 更新舞台，每次修改操作后需要更新真个舞台才有效果 &#125;&lt;/script&gt; 绘制图形(Graphics Class)定义一个&lt;canvas&gt; &lt;/canvas&gt; 画布。123// HTML:&lt;!-- Graphics Class 文本类--&gt;&lt;canvas id="demo2" width="650" height="400"&gt;&lt;/canvas&gt; 调用EaselJS提供的API - new createjs.Graphics()，绘制图形12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// JS&lt;script src="https://code.createjs.com/1.0.0/createjs.min.js"&gt;&lt;/script&gt;&lt;script&gt; window.onload = () =&gt; &#123; /** * Graphics Class 绘图类 -- demo * 用于生成矢量绘图指令 */ let stage2 = new createjs.Stage('demo2') // 画线 let g = new createjs.Graphics(); /* 同一个 Graphics 实例， 可以多次绘制，以下线段、折线都是用 g 实例绘制的*/ g.setStrokeStyle(10).beginStroke("#d23c4f").moveTo(400,10).lineTo(600,100) // 简写形式 g.ss(20).s('#fafa35').mt(400,100).lt(400,260) // 多点折线的简写形式 g.ss(1).s('#000').mt(600,400).lt(600, 200).lt(400,300).lt(500, 550) // Graphics 实例不能直接 addChild() 到舞台 stage 中，实例化为 Shape 实例后才可以 let line = new createjs.Shape(g) // 圆 let g1 = new createjs.Graphics(); g1.setStrokeStyle(1); // 描边 g1.beginStroke("#000000"); // 描边颜色 g1.beginFill("red"); // 图形填充 g1.drawCircle(0,0,100); // 绘制 (X, X, R) let c1 = new createjs.Shape(g1) // 实例化Shape对象 // 矩形 let g2 = new createjs.Graphics().beginStroke("red").beginFill("blue").drawRect(150, 0, 200, 100); // X, Y, W, H let c2 = new createjs.Shape(g2) // 命令对象 let g3 = new createjs.Graphics(); // 每个图形接口调用后会生成一个命令对象，可以使用.command访问，它保存对已创建或附加的最后一个命令的引用 let fillCommand = g3.beginFill("green").command; g3.drawCircle(200,200,50); // 绘制 (X, X, R) let c3 = new createjs.Shape(g3); // 一些异步操作后，更新填充样式/颜色: setTimeout(() =&gt; &#123; fillCommand.style = "gray"; stage2.update(); // 不更新舞台，不会重新渲染 &#125;, 2000); // 点击事件 //c3.addEventListener('click', () =&gt; &#123; // alert(123) // fillCommand.style = "gray"; // stage2.update(); // 不更新舞台，不会重新渲染 //&#125;) stage2.addChild(c1, c2, c3, line); stage2.update(); &#125;&lt;/script&gt; 绘制图像imgaes(Bitmap Class)定义一个&lt;canvas&gt; &lt;/canvas&gt; 画布。123// HTML:&lt;!-- Bitmap Class 图像类--&gt;&lt;canvas id="demo3" width="650" height="400"&gt;&lt;/canvas&gt; 调用EaselJS提供的API - new createjs.Bitmap()，绘制图像1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// JS&lt;script src="https://code.createjs.com/1.0.0/createjs.min.js"&gt;&lt;/script&gt;&lt;script&gt; window.onload = () =&gt; &#123; /** * bitmap Class 图像类 * 用于在画布显示列表中渲染图像 */ let stage3 = new createjs.Stage('demo3') // 渲染图片 let bitmap = new createjs.Bitmap('./assets/img/hill1.png') bitmap.alpha = 0.6 // 透明度 bitmap.cursor = 'help' // 创建一个shadow实例Object(color, offsetX, offsetY, blur) bitmap.shadow = new createjs.Shadow("#97c89e", 20, 10, 20); // 给图片添加遮罩 let bitmap2 = new createjs.Bitmap('./assets/img/avatar.jpg') bitmap2.x = 400; // 图片绘制的起始点X坐标 bitmap2.y = 0; // 图片绘制的起始点Y坐标 //遮罩图形 let shape = new createjs.Shape(); shape.graphics.beginFill('#000').drawCircle(0, 0, 100); shape.x = 500; // 圆心X坐标 shape.y = 100; // 圆心Y坐标 bitmap2.mask = shape; //给图片bg添加遮罩 // 绘制一片草地 let groundBg = new createjs.Bitmap("./assets/img/ground.png").image; let ground = new createjs.Shape(); w = stage3.canvas.width; // 650 h = stage3.canvas.height; // 400 stage3.addChild(ground) stage3.addChild(bitmap, bitmap2) stage3.update() // 此处刷新无效 // 监听定时广播 createjs.Ticker.timingMode = createjs.Ticker.RAF; createjs.Ticker.addEventListener('tick',(event) =&gt; &#123; ground.tileW = groundBg.width; ground.y = h - groundBg.height; ground.graphics.beginBitmapFill(groundBg).drawRect(0, 0, w, groundBg.height); ground.cache(0, 0, w, groundBg.height); stage3.update() &#125;); &#125;&lt;/script&gt; 一个小游戏(来自官网Demo) Running man定义一个&lt;canvas&gt;&lt;/canvas&gt;画布12345678910111213&lt;!-- HTML --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;running-man game&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="demoCanvas" width="960" height="400"&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt; JS代码这里就不写具体思路分析了，代码不长，注释也很详细，方便理解，直接上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// JS&lt;script src="https://code.createjs.com/1.0.0/createjs.min.js"&gt;&lt;/script&gt;&lt;script&gt; window.onload = () =&gt; &#123; let stage, w, h, loader; let sky, grant, ground, hill, hill2; function init() &#123; stage = new createjs.StageGL("demoCanvas"); // 获取画布的宽和高，后面计算使用 w = stage.canvas.width; // 960 h = stage.canvas.height; // 400 // 定义静态资源 let manifest = [&#123; src: "spritesheet_grant.png", id: "grant"&#125;, &#123; // 人物动作雪碧图 src: "sky.png", id: "sky"&#125;, &#123; // 天空 src: "ground.png", id: "ground"&#125;, &#123; // 地面 src: "hill1.png", id: "hill"&#125;, &#123; // 远山 src: "hill2.png", id: "hill2" // 近山 &#125;]; // Array, String, Object // 创建资源加载队列 // (Boolean) 用XHR还是用HTML标签来加载 // 如果是false的时候，就用标签来加载，如果不能用标签的话，就用XHR来加载。默认是true，用XHR来加载。 loader = new createjs.LoadQueue(false); // 添加"资源加载完成"事件 loader.addEventListener("complete", handleComplete); // 加载资源 loader.loadManifest(manifest, true, "./assets/img/"); // (manifest, loadNow, basePath) &#125; /** * 静态资源加载完成，处理函数 */ function handleComplete() &#123; // 渲染天空 sky = new createjs.Shape(); sky.graphics.beginBitmapFill(loader.getResult("sky")).drawRect(0, 0, w, h); // 定义缓存区域(整个天空的区域)) sky.cache(0, 0, w, h); // 渲染地面 let groundImg = loader.getResult("ground"); ground = new createjs.Shape(); // 注意：drawRect()宽度要躲绘制一个单位 ground.graphics.beginBitmapFill(groundImg).drawRect(0, 0, w + groundImg.width, groundImg.height); ground.tileW = groundImg.width; ground.y = h - groundImg.height; // 缓存区域(地面的区域) ground.cache(0, 0, w + groundImg.width, groundImg.height); // 随机渲染远处山脉 hill = new createjs.Bitmap(loader.getResult("hill")); // 设置图像转换 // setTransform([x=0], [y=0], [scaleX=1], [scaleY=1], [rotation=0], [skewX=0], [skewY=0], [regX=0], [regY=0]) hill.setTransform(Math.random() * w, h - hill.image.height * 4 - groundImg.height, 4, 4); hill.alpha = 0.5; // 设置透明度 // 随机渲染近处山脉 hill2 = new createjs.Bitmap(loader.getResult("hill2")); hill2.setTransform(Math.random() * w, h - hill2.image.height * 3 - groundImg.height, 3, 3); // 创建雪碧图动画 let spriteSheet = new createjs.SpriteSheet(&#123; framerate: 30, // 帧率 FPS "images": [loader.getResult("grant")], // 雪碧图原图 "frames": &#123;"width": 165, "height": 292, "count": 64, "regX": 82, "regY": 0&#125;, // 初始化 // 定义动画 "animations": &#123; "run": [0, 25, "run"], // name: [开始索引, 结束索引, '下一个动画名称', 倍率] "jump": [26, 63, "run"] &#125; &#125;); // 绘制动画 grant = new createjs.Sprite(spriteSheet, "run"); // 处理雪碧图人物下方空白 grant.y = 35; // 将生成的所有内容渲染至舞台 stage.addChild(sky, ground, hill, hill2, grant); // 监听舞台上的鼠标点击事件 stage.addEventListener("stagemousedown", () =&gt; &#123; // 跳转播放 jump 动画 grant.gotoAndPlay("jump"); &#125;); createjs.Ticker.timingMode = createjs.Ticker.RAF; // RAF / RAF_SYNCHED / TIMEOUT createjs.Ticker.addEventListener("tick", tick); &#125; /** * 定时器-重绘舞台 */ function tick(event) &#123; // event.delta -- 上一次tick到当前tick的ms let deltaS = event.delta / 1000; // 雪碧图人物移动距离 let position = grant.x + 150 * deltaS; // getBounds() -- 返回当前帧相对于雪碧图原点的边界 let grantW = grant.getBounds().width * grant.scaleX; grant.x = (position &gt;= w + grantW) ? -grantW : position; ground.x = (ground.x - deltaS * 150) % ground.tileW; // 从右至左移动山脉 hill.x = (hill.x - deltaS * 30); // 如果山脉从左侧离开屏幕 if (hill.x + hill.image.width * hill.scaleX &lt;= 0) &#123; hill.x = w; // 重置回屏幕最右侧 &#125; // 处理如上 hill2.x = (hill2.x - deltaS * 45); if (hill2.x + hill2.image.width * hill2.scaleX &lt;= 0) &#123; hill2.x = w; &#125; stage.update(); &#125; // 程序主入口-初始化 init() &#125;&lt;/script&gt; 完整代码 示例demo的GitHub地址：完整代码]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Create.JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伊 始]]></title>
    <url>%2F2018%2F07%2F11%2Fbeginning%2F</url>
    <content type="text"><![CDATA[开始的开始最近几天的西安城，阴雨绵绵，到哪都是湿漉漉的一片，给人一种身处烟雨江南的感觉。走在人少路窄的街道上，你也许能体会到戴望舒那“独自徘徊在悠长、悠长又寂寥的雨巷”朦胧而又幽深的美感，还会期待着“逢着一个丁香一样的结着愁怨的姑娘”。说实话，这不是西安第一次让我产生这样的错觉，今年夏天的西安，似乎更受雨水的青睐，总在温度快速攀升至30多度的时候迎来一场及时雨，之后又快速回落，这便被网友玩成了“满30立减20”的梗。的确，今年夏天西安少了一些往年的燥热，多了几分夏末秋初的凉爽。 善“思”我喜欢下雨天，不仅仅是因为雨天凉快，更重要的是我喜欢雨后万物如新洗的明丽和纯粹，洗去一身尘垢，显得本真色彩，这种雨后独有的清新秀丽在其他时间是看不到、体会不到的。其实，还有一个重要原因是我喜欢时不时地“胡思乱想”。一直觉得雨天最适合“天马行空”，尤其是雨后，觅一幽静之处，檐下雨水滴答，袖间凉风习习，雾气散尽之后，溢成满屋花香。这个时候，放空脑袋，忘却平日的紧张与忙碌，心随着眼睛漫无目的的在近处、远处、高处、低处肆意游荡。当有趣的事物映入眼帘，定睛多瞧几眼，之后会心一笑。仰望天空，乌云未散，依旧能感受到“黑云压城城欲摧”的气势。凝望着天空，就好似凝望着无尽的深渊，而此时，深渊也在凝望着你，看得愈久，陷得愈深，这便开始了天马行空般的“胡思乱想”。可能会从日常闲事想到人生哲理，也许会从方隅之间想到世界宇宙，会想东想西，会“思前想后”。这种思考不一定有多大意义，甚至可能有人认为毫无意义，但最重要的是这可以放松身心，在匆忙疲惫的生活中在精神上宽慰自己。心里的豁然开朗、风轻云淡，还有思维的释放，用语言很难表达出那种奇妙的感觉。据说每天给自己一定时间的冥想，能很好地平静内心，缓解压力，促进身心健康，更重要的是，也许某一时刻的灵光闪动，就会是改变你一生的“箴言”。 最近一直阴雨天，加上近来工作也相对清闲，便有了较多的时间做自己想做的事情，这对于我，可以说是如获至宝。因为真正忙碌的时候，没有时间更重要是没有心思去做其他的事情，也可能是长时间的“养老”氛围让我有些安逸和懒惰了。这一段时间，一直觉得过得有些浑浑噩噩，过于单调乏味。白天上班，空余看看技术文章，找找技术盲点研究研究，时间长了就会有些许疲惫。下班之后，便起身回到住处（我不太喜欢把租的公寓称之为“家”，不论是合租还是自己一个人住，因为在我觉得那不是“家”，称之为“住处”更为合适），回去便是“咸鱼躺”，然后刷刷新闻、微博，看看综艺（《向往的生活》一直是我很喜欢的一档综艺，很慢生活，很田园，推荐可以看看），隔三差五洗洗衣服。几乎每天都是这样，这让我每天起床睁眼，总觉得被“困”在了同一天，循环这一天所有的事情，就像电影《土拨鼠之日》一样。 这样的生活也有一段时了，刚开始没感到有什么不妥，也没察觉其中的可怕之处。这几天，总是觉得被这一天“困”得无法前进，觉得自己更像是一个“智能机器”，醒来之后便重复着几乎相同的事情，睡着后什么都像是忘掉了，可能连“梦”都没有。都说不做梦，是因为睡眠质量好，可一直不做梦是不是也有些可怜甚至可悲呢？这种循环最可怕的在于，你的记忆里就只有了早上起床洗漱、挤公交上班、枯燥地工作八小时甚至十几个小时、挤公交下班、洗漱睡觉这些事情，然后一天天地反复循环，没有尽头……这样的生活还会给人一种可怕的错觉 —— “时间过得真快”，对于一般的工薪上班族，这种感觉应该是格外明显。在我看来，这种生活是可怜的，也是可怕的，时间久了，如果渐渐适应或者说妥协，是一件很可怕的事情，就像“青蛙效应”。毕竟从“智人”进化而来的人类，是“智”、“思考”造就了今天的我们，生而为人，如果每天扮演一个“智能机器”的角色，还真是很不甘心啊…… 善“思”，亦应善“行”与其被困在原地，每天浑浑噩噩，那不如做一些改变。如果说没有意识到，或者说习惯了循环式的生活，那就另当别论。但如果选择改变，选择不妥协，那就应该做出改变。工作学习之余，合理安排时间，看看书，练练字，写写博客，跑跑步，健健身，学学厨艺，学学摄影，随处走走停停……对了，每天给自己冥想的时间，也是一个不错的选择，在善“思”的同时，亦应该做到善“行”。 每个人都应该有自己的爱好，有自己的乐趣所在，也应该有自己想要做但没来得及做的事情。一切都不算晚，一切都还有机会，最重要的是学会开始，毕竟“万事开头难”。改变并不意味着要短时间的巨变，给自己一个过渡的时间，一个循序渐进的过程，“量变到质变”是一个永恒不变的真理。 所以，我想，首先学会写博客，把自己的生活记录下来，再分享给大家。不一定要有很多人看，更不奢求有什么粉丝，只是希望看到文章的人在读到某一行，某一句的时候会心一笑，或者能帮你拨去心头的乌云。其实最简单的目的还是为了记录自己生活的点滴，记录自己的心路历程，同时也记录自己思想转变的过程，我相信日后回味起来，这将是一杯世间最醇的“美酒”…… 最后，把我很喜欢的一段话分享给大家，这是国产电影《大鱼·海棠》中女主人公 —— 椿 的一段独白： 你相信奇迹吗？生命是一场旅程，我们等了多少个轮回，才有机会去享受这一次旅程。这短短的一生，我们最终都会失去，不妨大胆一些，爱一个人，攀一座山，追一个梦。是的，不妨大胆一些。很多事我都不了解，很多问题也没有答案。但我相信，上天给我们生命，一定是为了让我们创造奇迹的。—— 电影《大鱼·海棠》]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分分钟教你用node.js写个爬虫]]></title>
    <url>%2F2018%2F06%2F08%2Fnews-spider%2F</url>
    <content type="text"><![CDATA[一、什么是爬虫 网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。WIKIPEDIA 爬虫介绍 二、爬虫的分类 通用网络爬虫（全网爬虫） 爬行对象从一些 种子URL 扩充到整个 Web，主要为门户站点搜索引擎和大型 Web 服务提供商采集数据。 聚焦网络爬虫（主题网络爬虫） 是 指选择性 地爬行那些与预先定义好的主题相关页面的网络爬虫。 增量式网络爬虫 指对已下载网页采取增量式更新和 只爬行新产生的或者已经发生变化网页 的爬虫，它能够在一定程度上保证所爬行的页面是尽可能新的页面。 Deep Web 爬虫 爬行对象是一些在用户填入关键字搜索或登录后才能访问到的深层网页信息的爬虫。 三、爬虫的爬行策略 通用网络爬虫（全网爬虫） 深度优先策略、广度优先策略 聚焦网络爬虫（主题网络爬虫） 基于内容评价的爬行策略（内容相关性），基于链接结构评价的爬行策略、基于增强学习的爬行策略（链接重要性），基于语境图的爬行策略（距离，图论中两节点间边的权重） 增量式网络爬虫 统一更新法、个体更新法、基于分类的更新法、自适应调频更新法 Deep Web 爬虫 Deep Web 爬虫爬行过程中最重要部分就是表单填写，包含两种类型：基于领域知识的表单填写、基于网页结构分析的表单填写 现代的网页爬虫的行为通常是四种策略组合的结果： 选择策略：决定所要下载的页面；重新访问策略：决定什么时候检查页面的更新变化；平衡礼貌策略：指出怎样避免站点超载；并行策略：指出怎么协同达到分布式抓取的效果； 四、写一个简单网页爬虫的流程 确定爬取对象（网站/页面） 分析页面内容（目标数据/DOM结构） 确定开发语言、框架、工具等 编码 测试，爬取数据 优化 一个简单的百度新闻爬虫确定爬取对象（网站/页面） 百度新闻 （http://news.baidu.com/） 分析页面内容（目标数据/DOM结构） ······ 确定开发语言、框架、工具等 node.js (express) + SublimeText 3 编码，测试，爬取数据 coding ··· Let’s start新建项目目录 1.在合适的磁盘目录下创建项目目录baiduNews（我的项目目录是：F:\web\baiduNews） 注：因为在写这篇文章的时候用的电脑真心比较渣。安装WebStorm或者VsCode跑项目有些吃力。所以后面的命令行操作我都是在Window自带的DOS命令行窗口中执行的。 初始化package.json 1.在DOS命令行中进入项目根目录 baiduNews2.执行npm init，初始化package.json文件 安装依赖 express （使用express来搭建一个简单的Http服务器。当然，你也可以使用node中自带的http模块）superagent （superagent是node里一个非常方便的、轻量的、渐进式的第三方客户端请求代理模块，用他来请求目标页面）cheerio （cheerio相当于node版的jQuery，用过jQuery的同学会非常容易上手。它主要是用来获取抓取到的页面元素和其中的数据信息） 1234// 个人比较喜欢使用yarn来安装依赖包,当然你也可以使用 npm install 来安装依赖，看个人习惯。yarn add expressyarn add superagentyarn add cheerio 依赖安装完成后你可以在package.json中查看刚才安装的依赖是否成功。安装正确后如下图： 开始coding 一、使用express启动一个简单的本地Http服务器 1、在项目根目录下创建index.js文件（后面都会在这个index文件中进行coding） 2、创建好index.js后，我们首先实例化一个express对象，用它来启动一个本地监听3000端口的Http服务。12345678910const express = require('express');const app = express();// ...let server = app.listen(3000, function () &#123; let host = server.address().address; let port = server.address().port; console.log('Your App is running at http://%s:%s', host, port);&#125;); 对，就是这么简单，不到10行代码，搭建启动一个简单的本地Http服务。 3、按照国际惯例，我们希望在访问本机地址http://localhost:3000的时候，这个服务能给我们犯规一个Hello World！在index.js中加入如下代码：123app.get('/', function (req, res) &#123; res.send('Hello World!');&#125;); 此时，在DOS中项目根目录baiduNews下执行node index.js,让项目跑起来。之后，打开浏览器，访问http://localhost:3000,你就会发现页面上显示’Hellow World!’字样。这样，在后面我们获取到百度新闻首页的信息后，就可以在访问http://localhost:3000时看到这些信息。 二、抓取百度新闻首页的新闻信息 1、 首先，我们先来分析一下百度新闻首页的页面信息。 百度新闻首页大体上分为“热点新闻”、“本地新闻”、“国内新闻”、“国际新闻”……等。这次我们先来尝试抓取左侧“热点新闻”和下方的“本地新闻”两处的新闻数据。 F12打开Chrome的控制台，审查页面元素，经过查看左侧“热点新闻”信息所在DOM的结构，我们发现所有的“热点新闻”信息（包括新闻标题和新闻页面链接）都在id为#pane-news的&lt;div&gt;下面&lt;ul&gt;下&lt;li&gt;下的&lt;a&gt;标签中。用jQuery的选择器表示为：#pane-news ul li a。 2、为了爬取新闻数据，首先我们要用superagent请求目标页面，获取整个新闻首页信息1234567891011121314151617181920// 引入所需要的第三方包const superagent= require('superagent');let hotNews = []; // 热点新闻let localNews = []; // 本地新闻/** * index.js * [description] - 使用superagent.get()方法来访问百度新闻首页 */superagent.get('http://news.baidu.com/').end((err, res) =&gt; &#123; if (err) &#123; // 如果访问失败或者出错，会这行这里 console.log(`热点新闻抓取失败 - $&#123;err&#125;`) &#125; else &#123; // 访问成功，请求http://news.baidu.com/页面所返回的数据会包含在res // 抓取热点新闻数据 hotNews = getHotNews(res) &#125;&#125;); 3、获取页面信息后，我们来定义一个函数getHotNews()来抓取页面内的“热点新闻”数据。12345678910111213141516171819202122232425262728/** * index.js * [description] - 抓取热点新闻页面 */// 引入所需要的第三方包const cheerio = require('cheerio');let getHotNews = (res) =&gt; &#123; let hotNews = []; // 访问成功，请求http://news.baidu.com/页面所返回的数据会包含在res.text中。 /* 使用cheerio模块的cherrio.load()方法，将HTMLdocument作为参数传入函数 以后就可以使用类似jQuery的$(selectior)的方式来获取页面元素 */ let $ = cheerio.load(res.text); // 找到目标数据所在的页面元素，获取数据 $('div#pane-news ul li a').each((idx, ele) =&gt; &#123; // cherrio中$('selector').each()用来遍历所有匹配到的DOM元素 // 参数idx是当前遍历的元素的索引，ele就是当前便利的DOM元素 let news = &#123; title: $(ele).text(), // 获取新闻标题 href: $(ele).attr('href') // 获取新闻网页链接 &#125;; hotNews.push(news) // 存入最终结果数组 &#125;); return hotNews&#125;; 这里要多说几点： async/await据说是异步编程的终级解决方案,它可以让我们以同步的思维方式来进行异步编程。Promise解决了异步编程的“回调地狱”，async/await同时使异步流程控制变得友好而有清晰，有兴趣的同学可以去了解学习一下，真的很好用。 superagent模块提供了很多比如get、post、delte等方法，可以很方便地进行Ajax请求操作。在请求结束后执行.end()回调函数。.end()接受一个函数作为参数，该函数又有两个参数error和res。当请求失败，error会包含返回的错误信息，请求成功，error值为null，返回的数据会包含在res参数中。 cheerio模块的.load()方法，将HTML document作为参数传入函数，以后就可以使用类似jQuery的$(selectior)的方式来获取页面元素。同时可以使用类似于jQuery中的.each()来遍历元素。此外，还有很多方法，大家可以自行Google/Baidu。 4、将抓取的数据返回给前端浏览器 前面，const app = express();实例化了一个express对象app。app.get(&#39;&#39;, async() =&gt; {})接受两个参数，第一个参数接受一个String类型的路由路径，表示Ajax的请求路径。第二个参数接受一个函数Function，当请求此路径时就会执行这个函数中的代码。1234567/** * [description] - 跟路由 */// 当一个get请求 http://localhost:3000时，就会后面的async函数app.get('/', async (req, res, next) =&gt; &#123; res.send(hotNews);&#125;); 在DOS中项目根目录baiduNews下执行node index.js,让项目跑起来。之后，打开浏览器，访问http://localhost:3000,你就会发现抓取到的数据返回到了前端页面。我运行代码后浏览器展示的返回信息如下：注：因为我的Chrome安装了JSONView扩展程序，所以返回的数据在页面展示的时候会被自动格式化为结构性的JSON格式，方便查看。 OK！！这样，一个简单的百度“热点新闻”的爬虫就大功告成啦！！ 简单总结一下，其实步骤很简单： express启动一个简单的Http服务 分析目标页面DOM结构，找到所要抓取的信息的相关DOM元素 使用superagent请求目标页面 使用cheerio获取页面元素，获取目标数据 返回数据到前端浏览器 现在，继续我们的目标，抓取“本地新闻”数据（编码过程中，我们会遇到一些有意思的问题）有了前面的基础，我们自然而然的会想到利用和上面相同的方法“本地新闻”数据。1、 分析页面中“本地新闻”部分的DOM结构，如下图： F12打开控制台，审查“本地新闻”DOM元素，我们发现，“本地新闻”分为两个主要部分，“左侧新闻”和右侧的“新闻资讯”。这所有目标数据都在id为#local_news的div中。“左侧新闻”数据又在id为#localnews-focus的ul标签下的li标签下的a标签中，包括新闻标题和页面链接。“本地资讯”数据又在id为#localnews-zixun的div下的ul标签下的li标签下的a标签中，包括新闻标题和页面链接。 2、OK！分析了DOM结构，确定了数据的位置，接下来和爬取“热点新闻”一样，按部就班，定义一个getLocalNews()函数，爬取这些数据。 123456789101112131415161718192021222324252627/** * [description] - 抓取本地新闻页面 */let getLocalNews = (res) =&gt; &#123; let localNews = []; let $ = cheerio.load(res); // 本地新闻 $('ul#localnews-focus li a').each((idx, ele) =&gt; &#123; let news = &#123; title: $(ele).text(), href: $(ele).attr('href'), &#125;; localNews.push(news) &#125;); // 本地资讯 $('div#localnews-zixun ul li a').each((index, item) =&gt; &#123; let news = &#123; title: $(item).text(), href: $(item).attr('href') &#125;; localNews.push(news); &#125;); return localNews&#125;; 对应的，在superagent.get()中请求页面后，我们需要调用getLocalNews()函数，来爬去本地新闻数据。superagent.get()函数修改为：1234567891011superagent.get('http://news.baidu.com/').end((err, res) =&gt; &#123; if (err) &#123; // 如果访问失败或者出错，会这行这里 console.log(`热点新闻抓取失败 - $&#123;err&#125;`) &#125; else &#123; // 访问成功，请求http://news.baidu.com/页面所返回的数据会包含在res // 抓取热点新闻数据 hotNews = getHotNews(res) localNews = getLocalNews(res) &#125;&#125;); 同时，我们要在app.get()路由中也要将数据返回给前端浏览器。app.get()路由代码修改为：12345678910/** * [description] - 跟路由 */// 当一个get请求 http://localhost:3000时，就会后面的async函数app.get('/', async (req, res, next) =&gt; &#123; res.send(&#123; hotNews: hotNews, localNews: localNews &#125;);&#125;); 编码完成，激动不已！！DOS中让项目跑起来，用浏览器访问http://localhost:3000 尴尬的事情发生了！！返回的数据只有热点新闻，而本地新闻返回一个空数组[ ]。检查代码，发现也没有问题，但为什么一直返回的空数组呢？经过一番原因查找，才返现问题出在哪里！！ 一个有意思的问题 为了找到原因，首先，我们看看用superagent.get(&#39;http://news.baidu.com/&#39;).end((err, res) =&gt; {})请求百度新闻首页在回调函数.end()中的第二个参数res中到底拿到了什么内容？12345678910111213141516171819202122232425// 新定义一个全局变量 pageReslet pageRes = &#123;&#125;; // supergaent页面返回值// superagent.get()中将res存入pageRessuperagent.get('http://news.baidu.com/').end((err, res) =&gt; &#123; if (err) &#123; // 如果访问失败或者出错，会这行这里 console.log(`热点新闻抓取失败 - $&#123;err&#125;`) &#125; else &#123; // 访问成功，请求http://news.baidu.com/页面所返回的数据会包含在res // 抓取热点新闻数据 // hotNews = getHotNews(res) // localNews = getLocalNews(res) pageRes = res &#125;&#125;);// 将pageRes返回给前端浏览器，便于查看app.get('/', async (req, res, next) =&gt; &#123; res.send(&#123; // &#123;&#125;hotNews: hotNews, // localNews: localNews, pageRes: pageRes &#125;);&#125;); 访问浏览器http://localhost:3000，页面展示如下内容： 可以看到，返回值中的text字段应该就是整个页面的HTML代码的字符串格式。为了方便我们观察，可以直接把这个text字段值返回给前端浏览器，这样我们就能够清晰地看到经过浏览器渲染后的页面。 修改给前端浏览器的返回值123app.get('/', async (req, res, next) =&gt; &#123; res.send(pageRes.text)&#125; 访问浏览器http://localhost:3000，页面展示如下内容： 审查元素才发现，原来我们抓取的目标数据所在的DOM元素中是空的，里面没有数据！到这里，一切水落石出！在我们使用superagent.get()访问百度新闻首页时，res中包含的获取的页面内容中，我们想要的“本地新闻”数据还没有生成，DOM节点元素是空的，所以出现前面的情况！抓取后返回的数据一直是空数组[ ]。 在控制台的Network中我们发现页面请求了一次这样的接口：http://localhost:3000/widget?id=LocalNews&amp;ajax=json&amp;t=1526295667917，接口状态 404。这应该就是百度新闻获取“本地新闻”的接口，到这里一切都明白了！“本地新闻”是在页面加载后动态请求上面这个接口获取的，所以我们用superagent.get()请求的页面再去请求这个接口时，接口URL中hostname部分变成了本地IP地址，而本机上没有这个接口，所以404，请求不到数据。 找到原因，我们来想办法解决这个问题！！ 直接使用superagent访问正确合法的百度“本地新闻”的接口，获取数据后返回给前端浏览器。 使用第三方npm包，模拟浏览器访问百度新闻首页，在这个模拟浏览器中当“本地新闻”加载成功后，抓取数据，返回给前端浏览器。 以上方法均可，我们来试试比较有意思的第二种方法 使用Nightmare自动化测试工具 Electron可以让你使用纯JavaScript调用Chrome丰富的原生的接口来创造桌面应用。你可以把它看作一个专注于桌面应用的Node.js的变体，而不是Web服务器。其基于浏览器的应用方式可以极方便的做各种响应式的交互 Nightmare是一个基于Electron的框架，针对Web自动化测试和爬虫，因为其具有跟PlantomJS一样的自动化测试的功能可以在页面上模拟用户的行为触发一些异步数据加载，也可以跟Request库一样直接访问URL来抓取数据，并且可以设置页面的延迟时间，所以无论是手动触发脚本还是行为触发脚本都是轻而易举的。 安装依赖12// 安装nightmareyarn add nightmare 为获取“本地新闻”，继续coding…给index.js中新增如下代码：123456789101112131415161718192021const Nightmare = require('nightmare'); // 自动化测试包，处理动态页面const nightmare = Nightmare(&#123; show: true &#125;); // show:true 显示内置模拟浏览器/** * [description] - 抓取本地新闻页面 * [nremark] - 百度本地新闻在访问页面后加载js定位IP位置后获取对应新闻， * 所以抓取本地新闻需要使用 nightmare 一类的自动化测试工具， * 模拟浏览器环境访问页面，使js运行，生成动态页面再抓取 */// 抓取本地新闻页面nightmare.goto('http://news.baidu.com/').wait("div#local_news").evaluate(() =&gt; document.querySelector("div#local_news").innerHTML).then(htmlStr =&gt; &#123; // 获取本地新闻数据 localNews = getLocalNews(htmlStr)&#125;).catch(error =&gt; &#123; console.log(`本地新闻抓取失败 - $&#123;error&#125;`);&#125;) 修改getLocalNews()函数为：123456789101112131415161718192021222324252627/** * [description]- 获取本地新闻数据 */let getLocalNews = (htmlStr) =&gt; &#123; let localNews = []; let $ = cheerio.load(htmlStr); // 本地新闻 $('ul#localnews-focus li a').each((idx, ele) =&gt; &#123; let news = &#123; title: $(ele).text(), href: $(ele).attr('href'), &#125;; localNews.push(news) &#125;); // 本地资讯 $('div#localnews-zixun ul li a').each((index, item) =&gt; &#123; let news = &#123; title: $(item).text(), href: $(item).attr('href') &#125;; localNews.push(news); &#125;); return localNews&#125; 修改app.get(&#39;/&#39;)路由为：12345678910/** * [description] - 跟路由 */// 当一个get请求 http://localhost:3000时，就会后面的async函数app.get('/', async (req, res, next) =&gt; &#123; res.send(&#123; hotNews: hotNews, localNews: localNews &#125;)&#125;); 此时，DOS命令行中重新让项目跑起来，浏览器访问https://localhost:3000，看看页面展示的信息，看是否抓取到了“本地新闻”数据！ 至此，一个简单而又完整的抓取百度新闻页面“热点新闻”和“本地新闻”的爬虫就大功告成啦！！ 最后总结一下，整体思路如下： express启动一个简单的Http服务 分析目标页面DOM结构，找到所要抓取的信息的相关DOM元素 使用superagent请求目标页面 动态页面（需要加载页面后运行JS或请求接口的页面）可以使用Nightmare模拟浏览器访问 使用cheerio获取页面元素，获取目标数据 ###完整代码 爬虫完整代码GitHub地址：完整代码 后面，应该还会做一些进阶，来爬取某些网站上比较好看的图片（手动滑稽），会牵扯到并发控制和反-反爬虫的一些策略。再用爬虫取爬去一些需要登录和输入验证码的网站，欢迎到时大家关注和指正交流。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Node.JS</tag>
      </tags>
  </entry>
</search>
