<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>布局篇 - 两栏式布局（左侧定宽，右侧自适应）</title>
      <link href="/2019/04/02/two-columns-layout/"/>
      <url>/2019/04/02/two-columns-layout/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面试中，另外一种经常被问到一种常用布局方式 —— <code>两栏式布局</code>（左侧栏定宽，右侧一栏宽度自适应），这样的布局方式用<code>CSS</code>应该如何来实现呢？今天我们来总结一下实现这种布局方式的<code>5种</code>不同方法。</p></blockquote><p>我们先来看看最终要实现的效果。</p><p><img src="/medias/article/coding/two-columns-layout/two-columns-layout.png" alt="两栏式布局"></p><h3 id="1-利用浮动（float）布局"><a href="#1-利用浮动（float）布局" class="headerlink" title="1. 利用浮动（float）布局"></a>1. 利用浮动（float）布局</h3><pre><code>&lt;!--HTML--&gt;&lt;body&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;aside class=&quot;left&quot;&gt;left(定宽200px)&lt;/aside&gt;        &lt;main class=&quot;main&quot;&gt;main(宽度自适应)&lt;/main&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><pre><code>/***CSS***/.left {    width: 200px;    background: #61daa5;    /* 左侧定宽栏左浮动 */  float: left;}main {    background: #78a5f1;    /* 多余10px，设置左右栏间隔 */  margin-left: 210px;}</code></pre><h3 id="2-利用绝对定位（position-absolute）布局"><a href="#2-利用绝对定位（position-absolute）布局" class="headerlink" title="2. 利用绝对定位（position: absolute）布局"></a>2. 利用绝对定位（position: absolute）布局</h3><pre><code>&lt;!--HTML--&gt;&lt;body&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;aside class=&quot;left&quot;&gt;left(定宽200px)&lt;/aside&gt;        &lt;main class=&quot;main&quot;&gt;main(宽度自适应)&lt;/main&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><pre><code>/***CSS***/#container {  /* 设置父元素相对定位 */  /* 目的是为了让左侧栏子元素想对他进行绝对定位 */  position: relative;}.left {    width: 200px;    background: #61daa5;    /* 左侧栏绝对定位 */  position: absolute;  top: 0;  left: 0;}main {    background: #78a5f1;  /* 多余10px，设置左右栏间隔 */    margin-left: 210px;}</code></pre><h3 id="3-利用table-table-cell布局"><a href="#3-利用table-table-cell布局" class="headerlink" title="3. 利用table/table-cell布局"></a>3. 利用table/table-cell布局</h3><p>注意，这种办法中，如果要设置左右栏的间隔，<code>margin</code>/<code>padding</code>在<code>table</code>/<code>table-cell</code>元素中不起作用。需要使用<code>border-collapse</code>/<code>border-spacing</code>设置。具体可以参考<a href="https://muki.tw/tech/fix-display-table-cell-not-affected-by-margin/" target="_blank" rel="noopener">这篇文章</a>。</p><pre><code>&lt;!--HTML--&gt;&lt;body&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;aside class=&quot;left&quot;&gt;left(定宽200px)&lt;/aside&gt;        &lt;main class=&quot;main&quot;&gt;main(宽度自适应)&lt;/main&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><pre><code>/***CSS***/#container {  /* 设置左右两栏元素的父元素 */    display: table;  /* 一定要设置宽度100%*/    width: 100%;}.left, .main {  /* 设置左右两栏元素 */    display: table-cell;}.left {    width: 200px;    height: 100vh;    background: #61daa5;}.main {    height: 100vh;    background: #78a5f1;}</code></pre><h3 id="4-利用弹性盒（flex）布局"><a href="#4-利用弹性盒（flex）布局" class="headerlink" title="4. 利用弹性盒（flex）布局"></a>4. 利用弹性盒（flex）布局</h3><pre><code>&lt;!--HTML--&gt;&lt;body&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;aside class=&quot;left&quot;&gt;left(定宽200px)&lt;/aside&gt;        &lt;main class=&quot;main&quot;&gt;main(宽度自适应)&lt;/main&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><pre><code>/***CSS***//* 设置父元素为弹性盒布局*/#container {    display: flex;}.left {    width: 200px;    background: #61daa5;}main {    background: #78a5f1;  /* 设置flex: 1，表示该元素占满所有剩余空间*/    flex: 1;  /* 左右栏间隔10px */  margin-left: 10px;}</code></pre><h3 id="5-利用栅格（Grid）布局"><a href="#5-利用栅格（Grid）布局" class="headerlink" title="5. 利用栅格（Grid）布局"></a>5. 利用栅格（Grid）布局</h3><p>关于grid布局的基础知识，大家可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout" target="_blank" rel="noopener">MDN-网格布局</a>和<a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">阮一峰-Grid 布局教程</a>以及<a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/" target="_blank" rel="noopener">张鑫旭-写给自己看的display: grid布局教程</a>三篇文章深入学习。</p><pre><code>&lt;!--HTML--&gt;&lt;body&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;aside class=&quot;left&quot;&gt;left(定宽200px)&lt;/aside&gt;        &lt;main class=&quot;main&quot;&gt;main(宽度自适应)&lt;/main&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><pre><code>/***CSS***/#container {  /* 设置父元素为grid */    display: grid;    /* 设置几个值代表布局为几行，每个值是行高 */    grid-template-rows: 100vh;    /* 设置几个值代表布局为几列，每个值是列宽 */    grid-template-columns: 200px auto;}.left {    height: 100vh;    background: #61daa5;}.main {    height: 100vh;    background: #78a5f1;  /* 左右栏间隔10px */    margin-left: 10px;}</code></pre><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>关于两栏式布局最常用的方法就是这些。本文总结的是左侧定宽，右侧宽度自适应的情况。而右侧定宽，左侧宽度自适应的实现方法与上面很类似。有兴趣的同学可以参考上面的方法试一试。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>布局篇 - 三栏布局（左右定宽，中间自适应）</title>
      <link href="/2019/04/02/three-columns-layout/"/>
      <url>/2019/04/02/three-columns-layout/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面试时，经常会被问到一种常用布局方式 —— <code>三栏式布局</code>（左右两栏定宽，中间一栏宽度自适应），这样的布局方式用<code>CSS</code>应该如何来实现呢？今天我们来总结一下实现这种布局方式的<code>5种</code>不同方法。</p></blockquote><p>我们先来看看最终要实现的效果。</p><p><img src="/medias/article/coding/three-columns-layout/three-columns-layout.png" alt="三栏式布局"></p><h3 id="1-利用浮动（float）布局"><a href="#1-利用浮动（float）布局" class="headerlink" title="1. 利用浮动（float）布局"></a>1. 利用浮动（float）布局</h3><pre><code>&lt;!--HTML--&gt;&lt;body&gt;  &lt;section id=&quot;container&quot;&gt;    &lt;!--注意！！.left和.right谁在前都可以，但是.center必须在它俩后面--&gt;    &lt;aside class=&quot;left&quot;&gt;left(定宽)&lt;/aside&gt;    &lt;aside class=&quot;right&quot;&gt;right(定宽)&lt;/aside&gt;    &lt;main class=&quot;center&quot;&gt;center(宽度自适应)&lt;/main&gt;  &lt;/section&gt;&lt;/body&gt;</code></pre><pre><code>/***CSS***/.left {    width: 200px;    height: 100vh;    background: #61daa5;    /* 左侧左浮动 */    float: left;}.right {    width: 200px;    height: 100vh;    background: #ffa7e9;    /* 右侧右浮动 */    float: right;}.center {    height: 100vh;    background: #78a5f1;    /* 多出10px，是给左中右三栏留出10px间距 */    margin-left: 210px;    margin-right: 210px;}</code></pre><h3 id="2-利用绝对定位（absolute）布局"><a href="#2-利用绝对定位（absolute）布局" class="headerlink" title="2. 利用绝对定位（absolute）布局"></a>2. 利用绝对定位（absolute）布局</h3><pre><code>&lt;!--HTML--&gt;&lt;body&gt;  &lt;section id=&quot;container&quot;&gt;    &lt;!--注意！！.left/.center/.right任意排序，不会影响最终结果--&gt;    &lt;aside class=&quot;left&quot;&gt;left(定宽)&lt;/aside&gt;    &lt;main class=&quot;center&quot;&gt;center(宽度自适应)&lt;/main&gt;    &lt;aside class=&quot;right&quot;&gt;right(定宽)&lt;/aside&gt;  &lt;/section&gt;&lt;/body&gt;</code></pre><pre><code>/***CSS***/.left {    width: 200px;    height: 100vh;    background: #61daa5;    /* 绝对定位 */    position: absolute;    left: 0;    top: 0;}.right {    width: 200px;    height: 100vh;    background: #ffa7e9;    /* 绝对定位 */    position: absolute;    right: 0;    top: 0;}.center {    height: 100vh;    background: #78a5f1;    /* 多出10px，是给左中右三栏留出10px间距 */    margin-left: 210px;    margin-right: 210px;}</code></pre><h3 id="3-利用表格（table-table-cell）布局"><a href="#3-利用表格（table-table-cell）布局" class="headerlink" title="3. 利用表格（table/table-cell）布局"></a>3. 利用表格（table/table-cell）布局</h3><pre><code>&lt;!--HTML--&gt;&lt;body&gt;  &lt;section id=&quot;container&quot;&gt;    &lt;!--注意！！.left/.center/.right/必须按照左中右顺序排序--&gt;    &lt;aside class=&quot;left&quot;&gt;left(定宽)&lt;/aside&gt;    &lt;main class=&quot;center&quot;&gt;center(宽度自适应)&lt;/main&gt;    &lt;aside class=&quot;right&quot;&gt;right(定宽)&lt;/aside&gt;  &lt;/section&gt;&lt;/body&gt;</code></pre><pre><code>/***CSS***//* .left,.center,.right的父元素 */#container {    display: table;    /* 一定要设置width: 100% */    width: 100%;}/* .left,.center,.right三个元素 */.left, .center, .right {    display: table-cell;}.left {    width: 200px;    height: 100vh;    background: #61daa5;}.right {    width: 200px;    height: 100vh;    background: #ffa7e9;}.center {    height: 100vh;    background: #78a5f1;}</code></pre><h3 id="4-利用弹性和（flex-box）布局"><a href="#4-利用弹性和（flex-box）布局" class="headerlink" title="4. 利用弹性和（flex-box）布局"></a>4. 利用弹性和（flex-box）布局</h3><pre><code>&lt;!--HTML--&gt;&lt;body&gt;  &lt;section id=&quot;container&quot;&gt;    &lt;!--注意！！.left/.center/.right/必须按照左中右顺序排序--&gt;    &lt;aside class=&quot;left&quot;&gt;left(定宽)&lt;/aside&gt;    &lt;main class=&quot;center&quot;&gt;center(宽度自适应)&lt;/main&gt;    &lt;aside class=&quot;right&quot;&gt;right(定宽)&lt;/aside&gt;  &lt;/section&gt;&lt;/body&gt;</code></pre><pre><code>/***CSS***/#container {    /* 设置父元素为弹性盒 */    display: flex;}.left {    width: 200px;    height: 100vh;    background: #61daa5;}.right {    width: 200px;    height: 100vh;    background: #ffa7e9;}.center {    height: 100vh;    background: #78a5f1;    /* 设置flex:1; 表示该元素占满剩余空间 */    flex: 1;    /* 左中右之间留出10px间距 */    margin: 0 10px;}</code></pre><h3 id="5-利用栅格（grid）布局"><a href="#5-利用栅格（grid）布局" class="headerlink" title="5. 利用栅格（grid）布局"></a>5. 利用栅格（grid）布局</h3><p>关于grid布局的基础知识，大家可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout" target="_blank" rel="noopener">MDN-网格布局</a>和<a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">阮一峰-Grid 布局教程</a>以及<a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/" target="_blank" rel="noopener">张鑫旭-写给自己看的display: grid布局教程</a>三篇文章深入学习。</p><pre><code>&lt;!--HTML--&gt;&lt;body&gt;  &lt;section id=&quot;container&quot;&gt;    &lt;!--注意！！.left/.center/.right/必须按照左中右顺序排序--&gt;    &lt;aside class=&quot;left&quot;&gt;left(定宽)&lt;/aside&gt;    &lt;main class=&quot;center&quot;&gt;center(宽度自适应)&lt;/main&gt;    &lt;aside class=&quot;right&quot;&gt;right(定宽)&lt;/aside&gt;  &lt;/section&gt;&lt;/body&gt;</code></pre><pre><code>/***CSS***/#container {    /* 设置父元素为grid */    display: grid;    /* 设置几个值代表布局为几行，每个值是行高 */    grid-template-rows: 100vh;    /* 设置几个值代表布局为几列，每个值是列宽 */    grid-template-columns: 200px auto 200px;}.left {    background: #61daa5;}.right {    background: #ffa7e9;}.center {    background: #78a5f1;    /* 左中右之间留出10px间距 */     margin: 0 10px;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6 - Generator函数</title>
      <link href="/2019/03/28/ES6-Generator/"/>
      <url>/2019/03/28/ES6-Generator/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是Generator函数"><a href="#一、什么是Generator函数" class="headerlink" title="一、什么是Generator函数"></a>一、什么是Generator函数</h3><p><code>Generator</code>函数是ES6标准中提出的一种异步编程的解决方案。这种函数与普通函数最大的区别在于它可以暂停执行，又可以从暂停的位置恢复继续执行。</p><p>从语法上看，<code>Generator</code>函数就是一个状态机，封装了许多内部状态。</p><p>从实质上看，<code>Generator</code>函数就是一个遍历器对象生成器。（关于遍历器对象，可以参考阮一峰老师的<a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">这篇文章</a>）<code>Generator</code>函数返回一个遍历器对象，遍历这个对象，就可以依次得到函数内部的每一个状态。</p><h3 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h3><h4 id="1、定义Generator函数"><a href="#1、定义Generator函数" class="headerlink" title="1、定义Generator函数"></a>1、定义Generator函数</h4><p>定义一个Generator函数和定义一个普通函数的区别在于：</p><ul><li>function关键字和函数名之间有一个 <code>*</code>（星号）。</li><li>函数内部使用<code>yield</code>来定义每一个函数内部的状态。</li><li>如果函数内部有<code>return</code>语句，那么他就是函数内部的最后一个状态。</li></ul><p>来看一个简单的例子：</p><pre><code>// 定义function* sayHello() {  yield &#39;hello&#39;;  yield &#39;world&#39;;  return &#39;ending&#39;;}// 调用// 注意，hw获取到的值是一个遍历器对象let g = sayHello();</code></pre><p>上面的例子，定义了一个名为<code>sayHello</code>的Generator函数，它内部有两个<code>yield</code>表达式和一个<code>return</code>表达式。所以，该函数内部有三个状态：<code>hello</code>，<code>world</code> 和 <code>return</code>语句（结束执行）。最后，调用这个函数，得到一个遍历器对象并赋值给变量<code>g</code>。</p><p>Generator函数的调用方法与普通函数完全一样，<code>函数名()</code>。不同的是：</p><ul><li>函数调用后，内部代码（从第一行开始）都不会立即执行。</li><li>函数调用后会有一个返回值，这个值是一个指向内部状态的指针对象，实质就是一个包含函数内部状态的遍历器对象。</li></ul><p>Generator函数调用后不会立即执行，那么，我们如何让它开始执行内部的代码呢？又如何获取它内部的每一个状态呢？此时，我们必须调用返回的生成器对象的.next()方法，才能开始代码的执行，并且使得指针移向下一个状态。</p><p>以上面的例子为例：</p><pre><code>g.next();// { value: &#39;hello&#39;, done: false }g.next();// { value: &#39;world&#39;, done: false }g.next();// { value: &#39;ending&#39;, done: true }g.next();// { value: undefined, done: true }</code></pre><p>上面的代码中，一共调用了四次<code>g</code>这个遍历器对象的<code>.next()</code>方法。第一次调用，<code>sayHello</code>这个Generator函数开始执行，直到遇到第一个<code>yield</code>表达式就会暂停执行。<code>.next()</code>方法会返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第二次再调用<code>.next()</code>，就会执行到第二个<code>yield</code>表达式处，并暂停执行，返回对应的对象。</p><p>第三次调用<code>.next()</code>，函数执行到最后的<code>return</code>语句，此时标志着遍历器对象<code>g</code>遍历结束，所以返回的对象中<code>value</code>属性值就是<code>return</code>后面所跟的值<code>ending</code>，<code>done</code>属性值为<code>true</code>，表示遍历已经结束。</p><p>第四次以及后面在调用.next()方法，返回的都会是<code>{value: undefined, done: true }</code>。</p><h4 id="2、yield表达式"><a href="#2、yield表达式" class="headerlink" title="2、yield表达式"></a>2、yield表达式</h4><p>由Generator函数返回的遍历器对象，只有调用<code>.next()</code>方法才会遍历到下一个内部状态，所以这其实是提供了一种可以暂停执行的函数，<code>yield</code>表达式就是暂停标志。</p><p>遍历器对象的<code>.next()</code>方法的运行逻辑如下。</p><ol><li>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</li><li>下一次调用<code>.next()</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</li><li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li><li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</li></ol><p><strong>值得注意的是：</strong></p><ol><li><p><strong><code>yield</code>关键字只能出现在Generator函数中，出现在别的函数中会报错。</strong></p><pre><code>// 出现在普通函数中，报错(function () {yield &#39;hello&#39;;})()// forEach不是Generator函数，报错[1, 2, 3, 4, 5].forEach(val =&gt; {yield val});</code></pre></li><li><p><strong><code>yield</code>关键字后面跟的表达式，是惰性求值的。</strong> 只有当调用<code>.next()</code>方法、内部状态暂停到当前<code>yield</code>时，才会计算其后面跟的表达式的值。这等于为JavaScript提供了手动的“惰性求值”的语法功能。</p><pre><code>function* step() {yield &#39;step1&#39;;// 下面的yield后面的表达式不会立即求值，// 只有暂停到这一行时，才会计算表达式的值。yield &#39;step&#39; + 2;yield &#39;setp3&#39;;return &#39;end&#39;;}</code></pre></li><li><p><strong><code>yield</code>表达式本身是没有返回值的，或者说它的返回值为<code>undefined</code></strong>。使用.next()传参可以为其设置返回值。（后面会讲到）</p><pre><code>function* gen() {for (let i = 0; i &lt; 5; i++) {let res = yield;  // yield表达式本身没有返回值console.log(res); // undefined}}let g = gen();g.next();   // {value: 0, done: false}g.next();   // {value: 1, done: false}g.next();   // {value: 2, done: false}</code></pre></li></ol><p><strong>yield与return的异同：</strong></p><p>相同点:</p><ul><li>两者都能返回跟在其后面的表达式的值。</li></ul><p>不同点：</p><ul><li>yield表达式只是暂停函数向后执行，return是直接结束函数执行。</li><li>yield表达式可以出现多次，后面还可以有代码。return只能出现一次，后面的代码不会执行，在一些情况下还会报错。</li><li>正常函数只能返回一个值，因为只能执行一次return。Generator函数可以返回一系列的值，因为可以有任意多个yield。</li></ul><h4 id="3、-next-方法传参"><a href="#3、-next-方法传参" class="headerlink" title="3、.next()方法传参"></a>3、.next()方法传参</h4><p>前面我们说到过，<code>yield</code>表达式自身没有返回值，或者说返回值永远是<code>undefined</code>。但是，我们可以通过给<code>.next()</code>方法传入一个参数，来设置<strong>上一个（是上一个）</strong><code>yield</code>表达式返回值。</p><p>来看一个例子：</p><pre><code>function* conoleNum() {  console.log(&#39;Started&#39;);  console.log(`data: ${yield}`);  console.log(`data: ${yield}`);  return &#39;Ending&#39;;}let g = conoleNum();g.next();      // 控制台输出：&#39;Started&#39;g.next(&#39;a&#39;);   // 控制台输出：&#39;data: a&#39;// 不传入参数&#39;a&#39;，就会输出&#39;data: undefined&#39;g.next(&#39;b&#39;);   // 控制台输出：&#39;data: b&#39;// 不传入参数&#39;a&#39;，就会输出&#39;data: undefined&#39;</code></pre><p>上面的例子，需要强调一个不易理解的地方。</p><p>第一次调用<code>.next()</code>，此时函数暂停在代码第三行的<code>yield</code>表达式处。记得吗？<code>yield</code>会暂停函数执行，<strong>此时打印它的<code>console.log()</code>，也就是代码第三行的console，由于暂停并没有被执行，所以不会打印出结果</strong>，只输出了代码第二行的’Started’。</p><p>当第二次调用<code>.next()</code>方法时，传入参数<code>&#39;a&#39;</code>，函数暂停在代码第四行的<code>yield</code>语句处。此时参数<code>&#39;a&#39;</code>会被当做<strong>上一个<code>yield</code>表达式</strong>的返回值，也就是代码第三行的<code>yiled</code>表达式的返回值，所以此时控制台输出<code>&#39;data: a&#39;</code>。而代码第四行的<code>console.log()</code>由于暂停，没有被输出。</p><p>第三次调用，同理。所以输出<code>&#39;data: b&#39;</code>。</p><h4 id="4、Generator-prototype-throw"><a href="#4、Generator-prototype-throw" class="headerlink" title="4、Generator.prototype.throw()"></a>4、Generator.prototype.throw()</h4><p>Generator函数返回的遍历器对象，都有一个<code>.throw()</code>方法，<strong>可以在函数体外抛出错误，然后在Generator函数体内捕获</strong>。</p><pre><code>function* gen() {  try {    yield;  } catch (e) {    console.log(&#39;内部捕获&#39;, e);  }};var g = gen();// 下面执行一次.next()// 是为了让gen函数体执行进入try语句中的yield处// 这样抛出错误，gen函数内部的catch语句才能捕获错误g.next();try {  g.throw(&#39;a&#39;);  g.throw(&#39;b&#39;);} catch (e) {  console.log(&#39;外部捕获&#39;, e);}</code></pre><p>上面例子中，遍历器对象<code>g</code>在<code>gen</code>函数体外连续抛出两个错误。第一个错误被<code>gen</code>函数体内的<code>catch</code>语句捕获。<code>g</code>第二次抛出错误，由于<code>gen</code>函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就会被抛出<code>gen</code>函数体，被函数体外的<code>catch</code>语句捕获。</p><p><strong>值得注意的是：</strong></p><ul><li>如果Generator函数内部没有部署<code>try...catch</code>代码块，那么遍历器对象的<code>throw</code>方法抛出的错误，将被外部<code>try...catch</code>代码块捕获。</li><li>如果Generator函数内部和外部都没有部署<code>try...catch</code>代码块，那么程序将报错，直接中断执行。</li></ul><p><strong>遍历器对象的<code>throw</code>方法被捕获以后，会附带执行一次<code>.next()</code>方法，代码执行会暂停到下一条<code>yield</code>表达式处</strong>。看下面这个例子：</p><pre><code>function* gen(){  try {    yield console.log(&#39;a&#39;);  } catch (e) {    console.log(e);   // &#39;Error&#39;  }  yield console.log(&#39;b&#39;);  yield console.log(&#39;c&#39;);}var g = gen();g.next();   // 控制台输出：&#39;a&#39;g.throw(&#39;Error&#39;);  // 控制台输出：&#39;b&#39;// throw的错误被内部catch语句捕获，// 会自动在执行一次g.next()g.next();   // 控制台输出：&#39;c&#39;</code></pre><h4 id="5、Generator-prototype-return"><a href="#5、Generator-prototype-return" class="headerlink" title="5、Generator.prototype.return()"></a>5、Generator.prototype.return()</h4><p>Generator函数返回的遍历器对象，还有一个<code>.return()</code>方法，可以返回给定的值，并且直接结束对遍历器对象的遍历。</p><pre><code>function* gen() {  yield 1;  yield 2;  yield 3;}var g = gen();g.next();        // { value: 1, done: false }// 提前结束对g的遍历。尽管yield还没有执行完// 此时done属性值为true，说明遍历结束g.return(&#39;foo&#39;); // { value: &quot;foo&quot;, done: true }g.next();        // { value: undefined, done: true }</code></pre><p>如果<code>.return()</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</p><h4 id="6、yield-表达式"><a href="#6、yield-表达式" class="headerlink" title="6、yield* 表达式"></a>6、yield* 表达式</h4><p><code>yield*</code> 用来在一个Generator函数里面执行另一个Generator函数。</p><p>如果在一个Generator函数内部，直接调用另一个Generator函数，默认情况下是没有效果的。</p><pre><code>function* gen1() {  yield &#39;a&#39;;  yield &#39;b&#39;;}function* gen2() {  yield &#39;x&#39;;  // 直接调用gen1()  gen1();  yield &#39;y&#39;;}// 遍历器对象可以使用for...of遍历所有状态for (let v of gen2()){  只输出了gen1的状态  console.log(v);   // &#39;x&#39; &#39;y&#39;}</code></pre><p>上面的例子中，<code>gen1</code>和<code>gen2</code>都是Generator函数，在<code>gen2</code>里面直接调用<code>gen1</code>，是不会有效果的。</p><p>这个就需要用到 <code>yield*</code> 表达式。</p><pre><code>function* gen1() {  yield &#39;a&#39;;  yield &#39;b&#39;;}function* gen2() {  yield &#39;x&#39;;  // 用 yield* 调用gen1()  yield* gen1();  yield &#39;y&#39;;}for (let v of gen2()){  输出了gen1、gen2的状态  console.log(v);   // &#39;x&#39; &#39;a&#39; &#39;b&#39; &#39;y&#39;}</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文主要讲解Generator函数的基本语法和一些细节，Generator函数的定义、<code>yield</code>表达式、<code>.next()</code>方法及传参、<code>.throw()</code>方法、<code>.return()</code>方法以及 <code>yield*</code> 表达式。</p><p>文章开头讲到，Generator函数时ES6提出的异步编程的一种解决方案。在实际应用中，<strong>一般在<code>yield</code>关键字后面会跟随一个异步操作，当异步操作成功返回后调用<code>.next()</code>方法，将异步流程交给下一个yield表达式。</strong>具体关于Generator函数的异步应用，大家可以参考阮一峰老师的<a href="http://es6.ruanyifeng.com/#docs/generator-async" target="_blank" rel="noopener">这篇文章</a>，或参考其他网上资料，继续深入学习。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Generator函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6 - Promise</title>
      <link href="/2019/03/25/ES6-Promise/"/>
      <url>/2019/03/25/ES6-Promise/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Promise是面试中最常见的问题之一，也是ES6中很有用、很核心的一个新特性。尤其在如今异步操作越来越多、越来越复杂的情况下，Prmoise更是显示出了它强大而又优雅的本质。这篇文章，我们来系统地讲解一下Promise相关的核心知识点。</p></blockquote><p>本文，我们按照以下的思路来逐步深入Promise：<br> 一、什么是Promise？(What)<br> 二、为什么需要Promise？或者说Promise的用途是什么？(Why)<br> 三、如何使用Promise？(How)<br> 四、Promise的其他方法。</p><h3 id="一、什么是Promise"><a href="#一、什么是Promise" class="headerlink" title="一、什么是Promise"></a>一、什么是Promise</h3><p><code>Promise</code>是一种异步编程的解决方案，它可以将异步操作以同步的流程表达出来，它比传统的使用回调函数和事件来处理异步问题更加合理，更符合人们线性处理问题的逻辑。<br>从语法上说，<code>Promise</code>是一个对象，它里面保存着一个将来才会发生的事情（一般是一个异步操作）的状态和结果。</p><p>听起来，有些抽象，全是概念性的东西。那接下来我们看看为什么ES6中会出现<code>Promise</code>？通过具体示例，可以帮助我们更好的理解什么是<code>Promise</code>。</p><h3 id="二、为什么需要Promise？它的用途是什么？"><a href="#二、为什么需要Promise？它的用途是什么？" class="headerlink" title="二、为什么需要Promise？它的用途是什么？"></a>二、为什么需要Promise？它的用途是什么？</h3><p>在ES6出现Promise之前，我们要处理一个异步请求，通常是这样的：</p><pre><code>// 利用回调函数来处理异步请求结果// 很多异步请求方法也会设计一些事件，在事件中处理异步请求结果asyncRequest(function(resData) {    // 处理请求结果});</code></pre><p>这样看着没什么问题，但需求总是各种各样甚至是变态的。如果我们需要在第一个请求返回结果后再发起第二个请求呢？再如果，第二个请求结果返回后后，我们需要再发起第三个请求呢？之后，再是第四个…第五个……此时，代码应该会变成这样：</p><pre><code>asyncRequest1(function(resData1) {    asyncRequest2(function(resData2) {        asyncRequest3(function(resData3) {            asyncRequest4(function(resData4) {                asyncRequest5(function(resData5) {                    // ......                    // 处理请求结果                });            });        });    });});</code></pre><p>这时，代码嵌套层次太深，再加上每次请求结束我们应该还需要做一些适当的逻辑处理，这样每个处理请求结果的地方还需要额外的代码，这样整个代码块显得很臃肿，一点也不优雅！最主要的是，这样的代码很容易出错，而且出错后不容易定位错误，阅读和维护起来十分费劲。</p><p>这就是异步编程最让人头疼和无语的地方：由于异步操作嵌套层次过深而导致的“<strong>回调地狱</strong>”！</p><p>出现这种情况，就需要思考新的异步编程的处理方法。有没有什么方法能在满足上面例子的需求的同时又能解决这种嵌套式的回调地狱呢？能不能不使用嵌套式回调，而使用链式回调呢？肯定是有的，这也就是<code>Promise</code>出现的原因。同时，能不能最好不使用回调的方式来处理异步请求呢？当然也是可以的，这就是我们后面文章会讲的<code>async/awiat</code>。</p><p>我们来看看，上面的例子，如果使用Promise来实现是什么样子？应该是这样：</p><pre><code>new Promise(asyncRequest1)    .then(asyncRequest2(resData1))    .then(asyncRequest3(resData2))    .then(asyncRequest4(resData3))    .then(asyncRequest5(resData4))    .catch(handleError(errorMsg))</code></pre><p>上面的例子，只有每个一步请求<code>asyncRequest</code>成功返回结果，才会进入下一个<code>.then()</code>方法中，从而进行下一个异步请求……以此类推。当任何一个请求出错时，就会进入<code>.catch()</code>方法中，可以在这里处理错误。这样的链式回调，既满足前面例子的需求，同时又避免了嵌套回调，从而避免了“回调地狱”的出现。</p><p>这里具体的语法看不懂，不要紧！不要慌！这个例子只是为了说明<code>Promise</code>是如何用链式回调来解决嵌套回调地狱的。接下来，我们就来说说如何使用<code>Promise</code>，讲讲它的基本语法。</p><h3 id="三、如何使用Promise（基本语法）"><a href="#三、如何使用Promise（基本语法）" class="headerlink" title="三、如何使用Promise（基本语法）"></a>三、如何使用Promise（基本语法）</h3><h4 id="1、创建一个Promise对象实例"><a href="#1、创建一个Promise对象实例" class="headerlink" title="1、创建一个Promise对象实例"></a>1、创建一个Promise对象实例</h4><p>ES6中规定，<code>Promise</code>是一个构造函数，可以用来实例化一个<code>Promise</code>对象。下面是一个简单的例子：</p><pre><code>// Promise构造函数接收一个函数作为参数let promise = new Promise(Function);</code></pre><h4 id="2、Promise的状态及其改变"><a href="#2、Promise的状态及其改变" class="headerlink" title="2、Promise的状态及其改变"></a>2、Promise的状态及其改变</h4><p>文章最开始介绍什么是Promise的时候说过：<code>Promise</code>是一个对象，它里面保存着一个将来才会发生的事情（一般是一个异步操作）的状态和结果。</p><p>我们先来看看Promise代表的异步操作的状态有哪几种？——一共只有三种状态：</p><ol><li>pending（进行中）</li><li>fulfilled（已成功）</li><li>rejected（已失败）</li></ol><p>这三种状态，不会共存，<code>Promise</code>只会处于其中某一种状态。当异步请求开始并且未结束（没有返回结果）时，处于<code>pending</code>状态。当异步请求返回结果后，可以根据请求返回的结果将<code>Promise</code>的状态修改为<code>fulfilled</code>或者<code>rejected</code>。并且，一旦<code>Promise</code>的状态第一次改变，就再也不能更改为其它任何状态。所以，<code>Promise</code>的状态改变过程<strong>只有</strong>两种情况：</p><ol><li>pending –&gt; fulfilled（进行中 –&gt; 已成功）</li><li>pending –&gt; rejected（进行中 –&gt; 已失败）</li></ol><p>那么，如何修改<code>Promise</code>的状态呢？这就需要了解调用<code>Promise</code>构造函数时，传递给构造函数的<code>Function</code>参数了。<code>Promise</code>会为这个函数设置两个参数，<code>resolve</code>、<code>reject</code>。这两个参数是两个函数，由JavaScript引擎提供，不用自己部署。</p><p><code>resolve()</code>函数，可以将<code>Promise</code>的状态由<code>pending</code>改变为<code>fulfilled</code>。<code>reject()</code>函数，可以将<code>Promise</code>的状态由<code>pending</code>改变为<code>rejected</code>。</p><p><strong>这里有两点需要注意的地方！！</strong></p><ol><li>在<code>Promise</code>内部只有用<code>resolve()</code>、<code>reject()</code>才能改变它的状态。<code>return</code>任何值（包括一个Error实例）都不会改变它的状态。</li><li><code>resolve()</code>、<code>reject()</code>和<code>return</code>的意义不同。它们只是改变了<code>Promise</code>的状态，并不会结束代码执行。也就是说<code>resolve()</code>、<code>reject()</code>之后的代码依旧会执行。（虽然不建议在他们后面再有代码出现）</li><li>在定义<code>Promise</code>时，参数函数中异步操作之外的同步代码都会立即执行。</li></ol><p>来看一个示例，简单明了地理解上面的文字。</p><pre><code>let promise = new Promise(function(resolve, reject) {    // 下面两行代码会立即执行，不会等待异步操作结果返回、状态改变    let a = &#39;123&#39;;    console.log(a); // &#39;123&#39;    // 一个异步请求    asyncRequest(function(resData) {        if (/* 异步操作成功 */){            // 将Promise的状态改为fulfilled（已成功）            resolve(resData);   // resData一般是异步操作的结果        } else {            // 将Promise的状态改为rejected（已失败）            reject(resData);    // resData一般是一些错误信息        }    });});</code></pre><p>上面的例子，在<code>Promise</code>内部发起了一个异步请求，当请求完成，拿到返回值<code>resData</code>时，我们可以根据具体的业务需求修改<code>Promise</code>的对应状态。</p><h4 id="3、Promise保存异步操作的结果"><a href="#3、Promise保存异步操作的结果" class="headerlink" title="3、Promise保存异步操作的结果"></a>3、Promise保存异步操作的结果</h4><p>细心的同学会发现，上面的例子中，我们在<code>resolve()</code>和<code>reject()</code>函数中传入了参数<code>resData</code>，这是在干什么？还记得么？<code>Promise</code>不仅能保存异步操作的状态，还能保存异步操作的结果。我们将将异步操作的结果<code>resData</code>传给这两个函数，就是将其保存到了<code>Promise</code>对象中。</p><h4 id="4、获取Promise中的状态和结果（-then-catch-）"><a href="#4、获取Promise中的状态和结果（-then-catch-）" class="headerlink" title="4、获取Promise中的状态和结果（.then()/.catch()）"></a>4、获取Promise中的状态和结果（.then()/.catch()）</h4><p>那么，<code>Prmoise</code>对象中保存了异步操作的最终状态和结果，我们如何获取呢？换句话说，我们怎么知道异步操作的状态和结果分别是什么呢？</p><p>其实，每个<code>Promise</code>的对象实例都会有一个<code>.then()</code>和<code>.catch()</code>方法，这两个方法都接收一个函数作为参数，这个函数会被<code>Promise</code>传入一个参数，这个参数就是传入<code>resolve()</code>、<code>reject()</code>方法中的异步请求的结果（上个例子中的<code>resData</code>）。当<code>Promise</code>内部状态变为<code>fulfilled</code>时，就会进入<code>.then()</code>方法中，执行里面的回调函数。同理，当<code>Promise</code>内部状态变为<code>rejected</code>时，就会进入<code>.catch()</code>方法中，执行里面的回调函数。</p><pre><code>/***接着上面例子***/promise.then(function(resData) {    // promise状态变为fulfilled，执行这里    console.log(resData);}).catch(function(resData) {    // promise状态变为rejected，执行这里    console.log(resData);});</code></pre><p>像上面这样，当执行进入<code>.then()</code>中，就说明<code>Promise</code>的状态是<code>fulfilled</code>。进入<code>.catch()</code>中，就说明状态是<code>rejected</code>，一般会在这里进行错误处理。同时，异步操作的结果会被传入定义在<code>.then()</code>、<code>.catch()</code>内部的函数中，我们可以直接访问使用。</p><h4 id="5、-then-catch-的链式调用"><a href="#5、-then-catch-的链式调用" class="headerlink" title="5、.then()/.catch()的链式调用"></a>5、.then()/.catch()的链式调用</h4><p><strong>在<code>.then()/.catch()</code>的返回值依旧是一个<code>Promise</code>实例。</strong>也就是说，在<code>.then()/.catch()</code>中<code>return</code>任何值，都会被转化成一个<code>Promise</code>实例。所以<code>.then()</code>后面可以链式继续调用<code>.then()/.catch</code>，<code>.catch()</code>后面同样也可以。于是，就有可能出现下面这样的代码：</p><pre><code>// 这样的代码是完全没有问题的。promise.then(function(resData) {    // 一些代码}).then(function(resData) {    // 一些代码}).catch(function(error) {    // 一些代码}).then(function(resData) {    // 一些代码}).catch(function(error) {    // 一些代码});</code></pre><p><strong>这里有一些需要注意的地方！！</strong></p><ol><li>前一个<code>.then()</code>中<code>return</code>任何值（包括一个<code>Error</code>实例），都会进入后面最邻近的<code>.then()</code>。</li><li>前一个<code>.then()</code>中<code>throw</code>任何值或者内部代码报错，都会进入后面最邻近的<code>.catch()</code>。</li><li>同理，上述原理在<code>.catch()</code>中的情况与<code>.then()</code>中完全一致。</li></ol><h3 id="四、Promise的其他方法"><a href="#四、Promise的其他方法" class="headerlink" title="四、Promise的其他方法"></a>四、Promise的其他方法</h3><h4 id="1、-Promise-resolve"><a href="#1、-Promise-resolve" class="headerlink" title="1、 Promise.resolve()"></a>1、 Promise.resolve()</h4><p><code>Promise.resolve</code>方法接收一个任意值作为参数，可以将其转换为Promise对象。</p><p>该方法对参数的处理，可以分为以下四种不同的情况：</p><h5 id="（1）参数是一个Promise实例"><a href="#（1）参数是一个Promise实例" class="headerlink" title="（1）参数是一个Promise实例"></a>（1）参数是一个Promise实例</h5><p>此时，<code>Promise.resolve</code>方法将不会做任何转换，直接原封不动的返回这个实例。</p><h5 id="（2）参数是一个thenable对象"><a href="#（2）参数是一个thenable对象" class="headerlink" title="（2）参数是一个thenable对象"></a>（2）参数是一个thenable对象</h5><p><code>thenable</code>对象是指对象内部实现了<code>then</code>方法的对象。此时，<code>Promise.resolve</code>方法会先将该对象转换为<code>Promise</code>对象，然后立即执行参数对象自己的<code>then</code>方法。</p><p><strong>最终，转换成的<code>Promise</code>对象的状态完全依赖于它内部<code>then</code>方法的具体实现，不一定是<code>fulfilled</code>状态，也有可能是<code>rejected</code>。</strong></p><pre><code>// 定义一个thenable对象let thenable = {    then: function(resolve, reject) {        resolve(42);        // 如果换成执行下面一行代码，后面将会进入.catch()中        // reject(&#39;error&#39;);    }};let p1 = Promise.resolve(thenable);p1.then(function(value) {    console.log(value);       // 42}).catch(function(value) {    console.log(value);     // &#39;error&#39;});</code></pre><h5 id="（3）参数不是thenable对象，或者不是一个对象"><a href="#（3）参数不是thenable对象，或者不是一个对象" class="headerlink" title="（3）参数不是thenable对象，或者不是一个对象"></a>（3）参数不是thenable对象，或者不是一个对象</h5><p>如果参数不是<code>thenable</code>对象，或者不是一个对象，<code>Promise.resolve</code>方法返回一个新的<code>Promise</code>对象，<strong>状态为<code>fulfilled</code></strong>，对象保存的值就是这个参数值。</p><pre><code>Promise.resolve(&#39;foo&#39;)// 等价于new Promise(resolve =&gt; resolve(&#39;foo&#39;));let p = Promise.resolve(&#39;Hello&#39;);p.then(function (s){    console.log(s);   // &#39;Hello&#39;});</code></pre><h5 id="（4）不传任何参数"><a href="#（4）不传任何参数" class="headerlink" title="（4）不传任何参数"></a>（4）不传任何参数</h5><p><code>Promise.resolve</code>方法允许调用时不带参数，直接返回一个<code>fulfilled</code>状态的<code>Promise</code>对象，对象保存的值为<code>undefined</code>。</p><pre><code>let p = Promise.resolve();p.then(function (value) {  console.log(value);   // undefined});</code></pre><h4 id="2、Promise-reject"><a href="#2、Promise-reject" class="headerlink" title="2、Promise.reject()"></a>2、Promise.reject()</h4><p><code>Promise.reject</code>方法也会返回一个新的<code>Promise</code>实例。<strong>不论传入的参数是什么数据类型，有没有<code>thenable</code>方法，该实例的状态一定为为<code>rejected</code>，且返回的<code>Promise</code>对象中保存的值就是传入<code>Promise.reject</code>方法时原封不动的参数值</strong>。</p><pre><code>例子一let p = Promise.reject(&#39;error&#39;);// 等同于let p = new Promise((resolve, reject) =&gt; reject(&#39;error&#39;));// 例子二let thenable = {    then(resolve, reject) {        /**         * 不论执行下面的哪一行，         * 最后Promise对象的状态都是rejected，         * 都会进入.catch中         *        reject(&#39;error&#39;);        // resolve(&#39;fulfilled&#39;);    }};Promise.reject(thenable).then(data =&gt; {    // 不会进入这里！！    console.log(&#39;进入then！&#39;);}).catch(e =&gt; {    console.log(&#39;进入catch！&#39;);    // ！注意！这里的e的值是传入Promise.reject()方法的thenable对象    console.log(e === thenable);  // true})</code></pre><h4 id="2、Promise-all"><a href="#2、Promise-all" class="headerlink" title="2、Promise.all()"></a>2、Promise.all()</h4><p><code>Promise.all</code>方法用于将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例。</p><pre><code>let p = Promise.all([p1, p2, p3]);</code></pre><p><code>Promise.all</code>方法接收一个数组作为参数，数组元素<code>p1</code>/<code>p2</code>/<code>p3</code>都是<code>Promise</code>实例。如果不是，就会先调用<code>Promise.resolve()</code>方法，将参数转为<code>Promise</code>实例，再进一步处理。</p><p>最终，<code>p</code>的状态由<code>p1</code>/<code>p2</code>/<code>p3</code>共同决定，分成两种情况：</p><ol><li>只有<code>p1</code>/<code>p2</code>/<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>。此时<code>p1</code>/<code>p2</code>/<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</li><li>只要<code>p1</code>/<code>p2</code>/<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>。此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</li></ol><h4 id="2、Promise-race"><a href="#2、Promise-race" class="headerlink" title="2、Promise.race()"></a>2、Promise.race()</h4><p><code>Promise.race</code>方法同样是将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例。</p><pre><code>let p = Promise.race([p1, p2, p3]);</code></pre><p><code>Promise.race</code>方法接收的参数与<code>Promise.all</code>方法一样，如果不是 <code>Promise</code> 实例，就会先调用<code>Promise.resolve()</code>方法，将参数转为 <code>Promise</code> 实例，再进一步处理。</p><p>上面的例子中，只要<code>p1</code>/<code>p2</code>/<code>p3</code>之中任意一个实例率先改变状态，不论变为哪种状态，<code>p</code>的状态就跟着改变。那个率先改变状态的<code>Promise</code>实例的返回值，就传递给<code>p</code>的回调函数。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6 - 箭头函数</title>
      <link href="/2019/03/24/ES6-arrow-function/"/>
      <url>/2019/03/24/ES6-arrow-function/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章我们来了解一下ES6中的箭头函数。首先会介绍一下箭头函数的基本语法，因为基本语法比较好理解，我们用示例做简单介绍即可。之后，我们重点来讨论一下箭头函数与普通函数之间的区别。</p></blockquote><h3 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h3><p>ES6中允许使用箭头<code>=&gt;</code>来定义箭头函数，具体语法，我们来看一个简单的例子：</p><pre><code>// 箭头函数let fun = (name) =&gt; {    // 函数体    return `Hello ${name} !`;};// 等同于let fun = function (name) {    // 函数体    return `Hello ${name} !`;};</code></pre><p>可以看出，定义箭头函在数语法上要比普通函数简洁得多。箭头函数省去了<code>function</code>关键字，采用箭头<code>=&gt;</code>来定义函数。函数的参数放在<code>=&gt;</code>前面的括号中，函数体跟在<code>=&gt;</code>后的花括号中。</p><p><strong>关于箭头函数的参数：</strong><br> <strong>①</strong> 如果箭头函数没有参数，直接写一个空括号即可。<br> <strong>②</strong> 如果箭头函数的参数只有一个，也可以省去包裹参数的括号。<br> <strong>③</strong> 如果箭头函数有多个参数，将参数依次用逗号(,)分隔，包裹在括号中即可。</p><pre><code>// 没有参数let fun1 = () =&gt; {    console.log(111);};// 只有一个参数，可以省去参数括号let fun2 = name =&gt; {    console.log(`Hello ${name} !`)};// 有多个参数let fun3 = (val1, val2, val3) =&gt; {    return [val1, val2, val3];};</code></pre><p><strong>关于箭头函数的函数体：</strong><br> <strong>①</strong> 如果箭头函数的函数体只有一句代码，就是简单返回某个变量或者返回一个简单的JS表达式，可以省去函数体的大括号{ }。</p><pre><code>let f = val =&gt; val;// 等同于let f = function (val) { return val };let sum = (num1, num2) =&gt; num1 + num2;// 等同于let sum = function(num1, num2) {  return num1 + num2;};</code></pre><p> <strong>②</strong> 如果箭头函数的函数体只有一句代码，就是返回一个对象，可以像下面这样写：</p><pre><code>// 用小括号包裹要返回的对象，不报错let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });// 但绝不能这样写，会报错。// 因为对象的大括号会被解释为函数体的大括号let getTempItem = id =&gt; { id: id, name: &quot;Temp&quot; };</code></pre><p> <strong>③</strong> 如果箭头函数的函数体只有一条语句并且不需要返回值（最常见是调用一个函数），可以给这条语句前面加一个<code>void</code>关键字</p><pre><code>let fn = () =&gt; void doesNotReturn();</code></pre><p>箭头函数最常见的用处就是简化回调函数。</p><pre><code>// 例子一// 正常函数写法[1,2,3].map(function (x) {  return x * x;});// 箭头函数写法[1,2,3].map(x =&gt; x * x);// 例子二// 正常函数写法var result = [2, 5, 1, 4, 3].sort(function (a, b) {  return a - b;});// 箭头函数写法var result = [2, 5, 1, 4, 3].sort((a, b) =&gt; a - b);</code></pre><h3 id="二、箭头函数与普通函数的区别"><a href="#二、箭头函数与普通函数的区别" class="headerlink" title="二、箭头函数与普通函数的区别"></a>二、箭头函数与普通函数的区别</h3><h4 id="1、语法更加简洁、清晰"><a href="#1、语法更加简洁、清晰" class="headerlink" title="1、语法更加简洁、清晰"></a>1、语法更加简洁、清晰</h4><p>从上面的基本语法示例中可以看出，箭头函数的定义要比普通函数定义简洁、清晰得多，很快捷。</p><h4 id="2、箭头函数不会创建自己的this（重要！！深入理解！！）"><a href="#2、箭头函数不会创建自己的this（重要！！深入理解！！）" class="headerlink" title="2、箭头函数不会创建自己的this（重要！！深入理解！！）"></a>2、箭头函数不会创建自己的this（重要！！深入理解！！）</h4><p>我们先来看看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">MDN</a>上对箭头函数<code>this</code>的解释。</p><blockquote><p>箭头函数不会创建自己的<code>this</code>，所以它没有自己的<code>this</code>，它只会从自己的作用域链的上一层继承<code>this</code>。</p></blockquote><p>箭头函数没有自己的<code>this</code>，它会捕获自己在<strong>定义时</strong>（注意，是定义时，不是调用时）所处的<strong>外层执行环境的<code>this</code></strong>，并继承这个<code>this</code>值。所以，箭头函数中<code>this</code>的指向在它被定义的时候就已经确定了，之后永远不会改变。</p><p>来看个例子：</p><pre><code>var id = &#39;Global&#39;;function fun1() {    // setTimeout中使用普通函数    setTimeout(function(){        console.log(this.id);    }, 2000);}function fun2() {    // setTimeout中使用箭头函数    setTimeout(() =&gt; {        console.log(this.id);    }, 2000)}fun1.call({id: &#39;Obj&#39;});     // &#39;Global&#39;fun2.call({id: &#39;Obj&#39;});     // &#39;Obj&#39;</code></pre><p>上面这个例子，函数<code>fun1</code>中的<code>setTimeout</code>中使用普通函数，2秒后函数执行时，这时函数其实是在全局作用域执行的，所以<code>this</code>指向<code>Window</code>对象，<code>this.id</code>就指向全局变量<code>id</code>，所以输出<code>&#39;Global&#39;</code>。<br>但是函数<code>fun2</code>中的<code>setTimeout</code>中使用的是箭头函数，这个箭头函数的<code>this</code>在定义时就确定了，它继承了它外层<code>fun2</code>的执行环境中的<code>this</code>，而<code>fun2</code>调用时<code>this</code>被<code>call</code>方法改变到了对象<code>{id: &#39;Obj&#39;}</code>中，所以输出<code>&#39;Obj&#39;</code>。</p><p>再来看另一个例子：</p><pre><code>var id = &#39;GLOBAL&#39;;var obj = {  id: &#39;OBJ&#39;,  a: function(){    console.log(this.id);  },  b: () =&gt; {      console.log(this.id);  }};obj.a();    // &#39;OBJ&#39;obj.b();    // &#39;GLOBAL&#39;</code></pre><p>上面这个例子，对象<code>obj</code>的方法<code>a</code>使用普通函数定义的，<strong>普通函数作为对象的方法调用时，<code>this</code>指向它所属的对象</strong>。所以，<code>this.id</code>就是<code>obj.id</code>，所以输出<code>&#39;OBJ&#39;</code>。<br>但是方法<code>b</code>是使用箭头函数定义的，箭头函数中的<code>this</code>实际是继承的它定义时所处的全局执行环境中的<code>this</code>，所以指向<code>Window</code>对象，所以输出<code>&#39;GLOBAL&#39;</code>。（<strong>这里要注意，定义对象的大括号<code>{}</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中！！</strong>）</p><h4 id="3、箭头函数继承而来的this指向永远不变（重要！！深入理解！！）"><a href="#3、箭头函数继承而来的this指向永远不变（重要！！深入理解！！）" class="headerlink" title="3、箭头函数继承而来的this指向永远不变（重要！！深入理解！！）"></a>3、箭头函数继承而来的this指向永远不变（重要！！深入理解！！）</h4><p>上面的例子，就完全可以说明箭头函数继承而来的<code>this</code>指向永远不变。对象<code>obj</code>的方法<code>b</code>是使用箭头函数定义的，这个函数中的<code>this</code>就<strong>永远指向</strong>它定义时所处的全局执行环境中的<code>this</code>，即便这个函数是作为对象<code>obj</code>的方法调用，<code>this</code>依旧指向<code>Window</code>对象。</p><h4 id="4、-call-apply-bind-无法改变箭头函数中this的指向"><a href="#4、-call-apply-bind-无法改变箭头函数中this的指向" class="headerlink" title="4、.call()/.apply()/.bind()无法改变箭头函数中this的指向"></a>4、.call()/.apply()/.bind()无法改变箭头函数中this的指向</h4><p><code>.call()</code>/<code>.apply()</code>/<code>.bind()</code>方法可以用来动态修改函数执行时<code>this</code>的指向，但由于箭头函数的<code>this</code>定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数<code>this</code>的指向，虽然这么做代码不会报错。</p><pre><code>var id = &#39;Global&#39;;// 箭头函数定义在全局作用域let fun1 = () =&gt; {    console.log(this.id)};fun1();     // &#39;Global&#39;// this的指向不会改变，永远指向Window对象fun1.call({id: &#39;Obj&#39;});     // &#39;Global&#39;fun1.apply({id: &#39;Obj&#39;});    // &#39;Global&#39;fun1.bind({id: &#39;Obj&#39;})();   // &#39;Global&#39;</code></pre><h4 id="5、箭头函数不能作为构造函数使用"><a href="#5、箭头函数不能作为构造函数使用" class="headerlink" title="5、箭头函数不能作为构造函数使用"></a>5、箭头函数不能作为构造函数使用</h4><p>我们先了解一下构造函数的new都做了些什么？简单来说，分为四步：<br> ① JS内部首先会先生成一个对象；<br> ② 再把函数中的this指向该对象；<br> ③ 然后执行构造函数中的语句；<br> ④ 最终返回该对象实例。</p><p>但是！！因为箭头函数没有自己的<code>this</code>，它的<code>this</code>其实是继承了外层执行环境中的<code>this</code>，且<code>this</code>指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用<code>new</code>调用时会报错！</p><pre><code>let Fun = (name, age) =&gt; {    this.name = name;    this.age = age;};// 报错let p = new Fun(&#39;cao&#39;, 24);</code></pre><h4 id="6、箭头函数没有自己的arguments"><a href="#6、箭头函数没有自己的arguments" class="headerlink" title="6、箭头函数没有自己的arguments"></a>6、箭头函数没有自己的arguments</h4><p>箭头函数没有自己的<code>arguments</code>对象。在箭头函数中访问<code>arguments</code>实际上获得的是外层局部（函数）执行环境中的值。</p><pre><code>// 例子一let fun = (val) =&gt; {    console.log(val);   // 111    // 下面一行会报错    // Uncaught ReferenceError: arguments is not defined    // 因为外层全局环境没有arguments对象    console.log(arguments); };fun(111);// 例子二function outer(val1, val2) {    let argOut = arguments;    console.log(argOut);    // ①    let fun = () =&gt; {        let argIn = arguments;        console.log(argIn);     // ②        console.log(argOut === argIn);  // ③    };    fun();}outer(111, 222);</code></pre><p>上面例子二，①②③处的输出结果如下：<br><img src="/medias/article/coding/arrow-function/arrow-function-arguments.png" alt="箭头函数的arguments"><br>很明显，普通函数<code>outer</code>内部的箭头函数<code>fun</code>中的<code>arguments</code>对象，其实是沿作用域链向上访问的外层<code>outer</code>函数的<code>arguments</code>对象。</p><p><strong>可以在箭头函数中使用rest参数代替arguments对象，来访问箭头函数的参数列表！！</strong></p><h4 id="7、箭头函数没有原型prototype"><a href="#7、箭头函数没有原型prototype" class="headerlink" title="7、箭头函数没有原型prototype"></a>7、箭头函数没有原型prototype</h4><pre><code>let sayHi = () =&gt; {    console.log(&#39;Hello World !&#39;)};console.log(sayHi.prototype); // undefined</code></pre><h4 id="8、箭头函数不能用作Generator函数，不能使用yeild关键字"><a href="#8、箭头函数不能用作Generator函数，不能使用yeild关键字" class="headerlink" title="8、箭头函数不能用作Generator函数，不能使用yeild关键字"></a>8、箭头函数不能用作Generator函数，不能使用yeild关键字</h4><p>这一点等到讲解Generator函数的时候我们在深入讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Function </tag>
            
            <tag> 箭头函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6 - 函数的扩展</title>
      <link href="/2019/03/22/ES6-function-extend/"/>
      <url>/2019/03/22/ES6-function-extend/</url>
      
        <content type="html"><![CDATA[<h3 id="1、函数参数的默认值"><a href="#1、函数参数的默认值" class="headerlink" title="1、函数参数的默认值"></a>1、函数参数的默认值</h3><p>在ES6之前，是不能直接给函数参数设置默认值的。如果需要设置默认值，就只能采用<code>||</code>（或）的短路原则来设置参数的默认值。</p><pre><code>function say (x, y) {    y = y || &#39;World&#39;;    console.log(x + &#39; &#39; + y + &#39;!&#39;);}say(&#39;Hello&#39;);           // &#39;Hello World!&#39;say(&#39;Hello&#39;, &#39;China&#39;);  // &#39;Hello China!&#39;say(&#39;Hello&#39;, &#39;&#39;);       // &#39;Hello World!&#39;</code></pre><p>像上面这样定义函数默认值，虽然基本能达到想要的结果，但也存在一个最大的问题：如果想要传给函数的参数值本身就是<code>&#39;&#39;</code>（空字符串,比如上面例子最后一次函数调用）、<code>0</code>、<code>false</code>、<code>null</code>这样的值，但使用<code>||</code>短路原则却会使默认值生效。</p><p>所以，我们需要在函数中加以判断，当某个参数确定未传值时，再赋默认值。</p><pre><code>function say (x, y) {    if (typeof x === &#39;undefined&#39;) {        y = &#39;World&#39;    }}</code></pre><p>这样虽然解决了前面所说的问题，但是，当一个函数的参数较多时，尤其在函数参数值需要做多种数据类型判断的时候，可能需要写很多<code>if</code>语句来判断，或者<code>if</code>语句的条件会变得很复杂，这样也不利于阅读和维护。</p><p>所以，为了解决以上问题，ES6中允许在函数声明时在形参的位置就给函数参数设置默认值，直接将默认值赋值在形参后面即可。</p><pre><code>function say (x, y = &#39;World&#39;) {    console.log(x + &#39; &#39; + y + &#39;!&#39;);}say(&#39;Hello&#39;);           // &#39;Hello World!&#39;say(&#39;Hello&#39;, &#39;China&#39;);  // &#39;Hello China!&#39;// 传入 &#39;&#39;、null、0、false都取值所传参数的值，不会使默认值生效say(&#39;Hello&#39;, &#39;&#39;);       // &#39;Hello !&#39;say(&#39;Hello&#39;, null);       // &#39;Hello null!&#39;say(&#39;Hello&#39;, 0);       // &#39;Hello 0!&#39;say(&#39;Hello&#39;, false);       // &#39;Hello false!&#39;// 只有参数未传值或者所传参数值严格等于undefined时，默认参数才生效say(&#39;Hello&#39;, undefined);       // &#39;Hello World!&#39;// 构造函数也可以定义参数默认值function Point(x = 0, y = 0) {  this.x = x;  this.y = y;}const p = new Point(1);console.log(p);     // { x: 1, y: 0 }</code></pre><p>显然，ES6这种定义函数参数默认值的方法要简单、清晰得多。<strong>最重要的是，这种方法定义的参数默认值只有当参数未传值或者传值严格等于<code>undefined</code>的时候，默认值才会生效</strong>。</p><p>这里，还有一些需要格外注意的地方！！</p><p><strong>① 函数参数（不论是否设置了默认值）都是JS内部默认声明过的，所以不能在函数体内再使用let/const重复声明。</strong>否则，会报错！</p><pre><code>function createArr(x, y = 0) {    let x = 0;      // 报错    let y = 0;      // 也会报错    return [x, y];}</code></pre><p><strong>② 如果一个函数设置了参数默认值，则该函数任何一个参数（包括设置了默认值的参数）都不能重名！</strong></p><pre><code>// 没有参数设置默认值，这不会报错function fn1(x, x, y) {  console.log(x, y);}// 注意，最终x输出为2。因为第二个参数覆盖了第一个fn1(1, 2, 3);   // 2 3// 参数设置了默认值，x又重名，所以会报错function fn2(x, x, y = 1) {  // ...}</code></pre><p><strong>③ 函数参数的默认值可以是任何JS表达式，但每调用一次函数，该表达式都会重新计算求值！</strong></p><pre><code>let x = 99;function cal(p = x + 1) {  console.log(p);}cal();  // 100x = 100;cal();  // 101</code></pre><p>上面的例子，每调用一次<code>cal</code>函数，参数<code>p</code>都会重新计算默认值<code>x + 1</code>，并不会记住上次调用所求得的<code>p</code>的默认值！</p><h3 id="2、参数默认值可以和解构赋值结合使用"><a href="#2、参数默认值可以和解构赋值结合使用" class="headerlink" title="2、参数默认值可以和解构赋值结合使用"></a>2、参数默认值可以和解构赋值结合使用</h3><p>函数参数的默认值可以和解构赋值、解构赋值的默认值，结合起来使用。</p><h4 id="2-1-只使用解构赋值默认值"><a href="#2-1-只使用解构赋值默认值" class="headerlink" title="2.1 只使用解构赋值默认值"></a>2.1 只使用解构赋值默认值</h4><pre><code>// 这里只使用了解构赋值的默认值，未使用参数默认值function foo({x, y = 5}) {  console.log([x, y]);}/** * 下面调用时传的参数， * 会与{x, y = 5}进行模式匹配，进行解构赋值 */foo({});        // [undefined, 5]foo({x: 1});    // [1, 5]foo({x: 1, y: 2});      // [1, 2]foo();      // TypeError: Cannot read property &#39;x&#39; of undefined</code></pre><p>上面的例子，只使用了解构赋值的默认值，未使用参数默认值。如果将一个对象传给<code>foo</code>函数，那么这个对象就会和{x, y = 5}进行模式匹配，最终为参数解构赋值。但如果不给函数传参（例如最后一行——<code>foo()</code>），或者传参为<code>null</code>，那么就会报错。因为，<code>undefined</code>、<code>null</code>无法进行解构赋值。</p><p>上面的例子的报错问题，其实可以通过结合使用函数参数默认值的方法来避免。</p><h4 id="2-2-同时使用解构赋值默认值和参数默认值"><a href="#2-2-同时使用解构赋值默认值和参数默认值" class="headerlink" title="2.2 同时使用解构赋值默认值和参数默认值"></a>2.2 同时使用解构赋值默认值和参数默认值</h4><pre><code>// 这里不仅使用了解构赋值默认值，同时使用了函数参数默认值function foo({x, y = 5} = {}) {  console.log(x, y);}// 这样调用不会报错foo();  // undefined 5</code></pre><p>上面的例子，调用<code>foo</code>函数未传入参数。此时，首先会使函数参数的默认值（也就是声明函数时的<code>= {}</code>）生效。接下来，参数默认值<code>{ }</code>会与<code>{x, y = 5}</code>再进行解构赋值。其中解构赋值中，参数<code>y</code>具有默认值为<code>5</code>。</p><p>作为练习，请思考下面两种写法有什么区别？</p><pre><code>// 写法一function f1({x = 0, y = 0} = {}) {  return [x, y];}// 写法二function f2({x, y} = { x: 0, y: 0 }) {  return [x, y];}</code></pre><h3 id="3、需要设置默认值的参数最好放在其余参数最后面"><a href="#3、需要设置默认值的参数最好放在其余参数最后面" class="headerlink" title="3、需要设置默认值的参数最好放在其余参数最后面"></a>3、需要设置默认值的参数最好放在其余参数最后面</h3><p>一般情况下，建议将需要设置默认值的参数放在其余参数最后面。原因主要有以下两点：</p><ul><li>因为这样比较容易看出来，到底省略了哪些参数。</li><li>如果非尾部的参数设置默认值，实际上这个参数是没法省略的,必须显式传入<code>undefined</code>才能使默认值生效。</li></ul><pre><code>function f(x, y = 5, z) {  return [x, y, z];}f();    // [undefined, 5, undefined]f(1);   // [1, 5, undefined]f(1, ,2);   // 省略第二个参数，会报错// 需要显式传入undefined作为第二个参数值f(1, undefined, 2);     // [1, 5, 2]</code></pre><h3 id="4、函数的rest参数"><a href="#4、函数的rest参数" class="headerlink" title="4、函数的rest参数"></a>4、函数的rest参数</h3><p>ES6引入了<code>rest</code>参数（形为<code>...变量名</code>）。这个变量名对应的值是一个数组，里面按参数传入的顺序存放着函数除了具名参数以外的剩余参数。</p><p><strong>剩余参数只能/必须是函数的最后一个参数</strong>。但它有可能保存的是传入函数的所有参数值，也可能是传入函数的一部分参数值。</p><pre><code>// 这个rest参数——param保存的就是所有传入参数的值function r1(...param) {    console.log(param);}r1(1, 2, 3, 4, 5);  // [1, 2, 3, 4, 5]// 这个rest参数——param保存的就是除具名参数以外的参数值function r2(param1, param2, ...param) {    console.log(param1, param2, ...param)}r2();   // 1 2 [3, 4, 5]</code></pre><p>我们可以使用<code>rest</code>参数来代替函数的<code>arguments</code>对象。最重要的是，<code>rest</code>参数是一个数组，可以使用所有数组的方法。但是，<code>arguments</code>只是一个类数组对象，很多数组的方法无法使用。</p><h3 id="5、函数的length、name属性"><a href="#5、函数的length、name属性" class="headerlink" title="5、函数的length、name属性"></a>5、函数的length、name属性</h3><p>首先，要明确一点：所有函数都是Function类型的一个实例对象。所以每个函数都有一些自己的属性和方法。最后我们就来了解一下函数对象的<code>length</code>和<code>name</code>属性。</p><h4 id="5-1、length属性"><a href="#5-1、length属性" class="headerlink" title="5.1、length属性"></a>5.1、length属性</h4><p>函数的<code>length</code>属性一般情况下表示函数期望接收到的参数的个数。但在设置了参数默认值或者rest参数时，会有一些变化。</p><pre><code>(function (a) {}).length;           // 1(function (a = 0, b, c) {}).length; // 0(function (a, b = 1, c) {}).length; // 1(function (a, b, c = 5) {}).length; // 2(function(arg1, ...args) {}).length;      // 1  (function(...args) {}).length;      // 0</code></pre><p>可以看出：</p><ul><li>一般情况下，<code>length</code>属性返回的是函数声明时所定义的的参数的个数；</li><li>当设置了参数默认值时，<code>length</code>属性返回的是<strong>第一个设置了默认值的参数之前的参数个数，之后的参数不再计入</strong>；</li><li>当设置了<code>rest</code>参数，因为<code>rest</code>参数只能是函数的最后一个参数。所以<code>length</code>返回的是<code>rest</code>参数之前的参数个数。</li></ul><h4 id="5-2、name属性"><a href="#5-2、name属性" class="headerlink" title="5.2、name属性"></a>5.2、name属性</h4><p>函数的<code>name</code>属性，返回的是该函数的函数名。</p><pre><code>// 函数声明function fun1() {}console.log(fun1.name);  // &#39;fun1&#39;（ES5/ES6）// 函数表达式let fun2 = function() {};// ES5：&#39;&#39;(空字符串)// ES6：&#39;fun2&#39;console.log(fun2.name);// 将具名函数赋值给一个变量let temp = function fun3() {};console.log(temp.name);// &#39;fun3&#39;(ES5/ES6)// Function()构造函数——返回&#39;anonymous&#39;console.log((new Function).name);   // &#39;anonymous&#39;// .bind()方法返回的函数，name属性值会加上&#39;bound &#39;（带个空格）前缀。function fun4() {};console.log(fun4.bind({}).name);     // &#39;bound fun4&#39;console.log((function(){}).bind({}).name);  // &#39;bound &#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Function </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6 - 字符串的扩展</title>
      <link href="/2019/03/21/ES6-templateString/"/>
      <url>/2019/03/21/ES6-templateString/</url>
      
        <content type="html"><![CDATA[<h3 id="一、模板字符串"><a href="#一、模板字符串" class="headerlink" title="一、模板字符串"></a>一、模板字符串</h3><blockquote><p>模板字符串是增强版的字符串，用两个反引号（` `）包含来表示。</p></blockquote><h4 id="1、当做普通字符串使用"><a href="#1、当做普通字符串使用" class="headerlink" title="1、当做普通字符串使用"></a>1、当做普通字符串使用</h4><p>在` `中如果只包含简单的字符串字面量，那么它和用引号（单/双引号）定义的字符串没有什么区别。</p><pre><code>let s = `Hello World !`;console.log(s);     // &#39;Hello World !&#39;// 注意！！如果在模板字符串中本身就要输出反引号 ` ,请使用反斜杠（\）转义。let greeting = `\`Hello\` World!`;console.log(greeting);      // &#39;`Hello` World!&#39;</code></pre><h4 id="2、模板字符串可以保留字符串的格式"><a href="#2、模板字符串可以保留字符串的格式" class="headerlink" title="2、模板字符串可以保留字符串的格式"></a>2、模板字符串可以保留字符串的格式</h4><p>使用模板字符串来定义多行字符串，包括换行、缩进、多个空格等都会保留其中的格式。<br>最常见的就是用来定义一个HTML模板字符串，在编码时可以很好地保留HTML字符串的换行、缩进等…，也便于阅读维护。</p><pre><code>let htmlStr = `    &lt;ul&gt;        &lt;li&gt;first&lt;/li&gt;        &lt;li&gt;second&lt;/li&gt;    &lt;/ul&gt;`;console.log(htmlStr);let s = `    He   l  l o,        W or    l d!`console.log(s);</code></pre><p>以上两个例子，定义了带有格式（换行、缩进、多个空格）的模板字符串，模板字符串会保留所有的格式。在控制台输出的结果如下：<br><img src="/medias/article/coding/template-string/console-templateStr.png" alt="模板字符串输出结果"></p><h4 id="3、模板字符串可以嵌入变量"><a href="#3、模板字符串可以嵌入变量" class="headerlink" title="3、模板字符串可以嵌入变量"></a>3、模板字符串可以嵌入变量</h4><p>在以前，如果我们需要用一些固定的字符串与一些动态的变量值来拼接形成一个最终字符串，最常用的做法是像下面这样：</p><pre><code>let name = &#39;cao&#39;;let age = 24;let result = &#39;Hello &#39; + name + &#39;,&#39; + &#39; You are &#39; + age + &#39; years old !&#39;；// 拼接一个HTML字符串let basket = {    count: 10,    onSale: 3};let resultHTML =     &#39;There are &lt;b&gt;&#39; + basket.count + &#39;&lt;/b&gt; &#39; +    &#39;items in your basket, &#39; +    &#39;&lt;em&gt;&#39; + basket.onSale +    &#39;&lt;/em&gt; are on sale!&#39;</code></pre><p>像上面这样拼接字符串显然很麻烦。例子中还是较为简单的字符串，如果字符串内容过于复杂，甚至像HTML文本字符串带有缩进和结构，上面这样显然很容易出错——因为不仅要保证引号配对无误，还要保证拼接符（+）没有遗漏，这样显然不已阅读和维护。然而，使用模板字符串会方便而且清晰得多。</p><p>上面的例子使用模板字符串也可以达到相同的效果，且方便、清晰。<strong>模板字符串中嵌入的变量必须写在 <code>${ }</code> 的大括号中，大括号之外的字符都会被当做一般的字符串。</strong></p><pre><code>let name = &#39;cao&#39;;let age = 24;let result = `Hello ${name}, You are ${age} years old !`；// 拼接一个HTML字符串let basket = {    count: 10,    onSale: 3};let resultHTML =     `There are &lt;b&gt; ${basket.count} &lt;/b&gt;    items in your basket,    &lt;em&gt; ${basket.onSale}    &lt;/em&gt; are on sale!`;</code></pre><p><code>${ }</code>大括号内部可以放入任意的JS表达式，可以进行运算、引用对象属性或者调用函数。<strong>如果表达式计算结果不是一个字符串，那就会自动将其转换为字符串</strong>。比如，大括号中是一个对象，将默认调用对象的toString方法。</p><pre><code>let x = 1;let y = 2;console.log(`${x} + ${y} = ${x + y}`);      // &quot;1 + 2 = 3&quot;console.log(`${x} + ${y * 2} = ${x + y * 2}`);      // &quot;1 + 4 = 5&quot;let obj = {x: 1, y: 2};console.log(`${obj.x + obj.y}`);        // &quot;3&quot;function fn() {  return &quot;Hello World&quot;;}console.log(`foo ${fn()} bar`);      // &quot;foo Hello World bar&quot;</code></pre><h3 id="二、标签模板"><a href="#二、标签模板" class="headerlink" title="二、标签模板"></a>二、标签模板</h3><blockquote><p>模板字符串可跟在函数后面，表示将模板字符串作为参数来调用该函数。这杯称作<code>“标签模板”</code>功能。</p></blockquote><pre><code>alert`Hello World !`;// 相当于alert(&#39;Hello World !&#39;);</code></pre><p><strong>标签模板其实不是模板，而是函数调用的一种特殊形式。</strong> “ 标签 ” 指的就是函数，紧跟在后面的模板字符串就是它的参数。</p><p>使用标签模板调用函数大致分为两种情况：</p><ol><li>模板字符串中只有一般字符串；</li><li>模板字符串中有嵌入的变量</li></ol><h4 id="1、模板字符串中只有一般字符串"><a href="#1、模板字符串中只有一般字符串" class="headerlink" title="1、模板字符串中只有一般字符串"></a>1、模板字符串中只有一般字符串</h4><p>标签模板调用函数时，如果模板字符串中只有一般字符串，那么这个字符串就直接被当做参数传给调用的函数。</p><pre><code>function sayHello(name) {    return `Hello ${name} !`;}sayHello`world`;        // &#39;Hello world !&#39;// 等同于 sayHello（&#39;world&#39;);</code></pre><h4 id="2、模板字符串中有嵌入的变量"><a href="#2、模板字符串中有嵌入的变量" class="headerlink" title="2、模板字符串中有嵌入的变量"></a>2、模板字符串中有嵌入的变量</h4><p>如果模板字符里面有嵌入的变量，就不是简单的调用了。JS会自动将模板字符串先处理转换成多个参数，再调用函数。具体转换方式如下：</p><pre><code>let a = 5;let b = 10;function tag(strArr, val1, val2) {    let s = `${strArr[0]}-${val1}-${strArr[1]}-${val2}-${strArr[2]}`;    console.log(s);}// 标签模板调用tag`Hello ${ a + b } world ${ a * b }`;// 等同于下面// ！！注意：字符串中的空格是会被保留下来的tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50);// 以上两个调用输出结果都是：&#39;Hello -15- world -50-&#39;</code></pre><p>也就是说，用标签模板调用函数的时候，如果模板字符里面嵌有变量，JS会将嵌入变量${…}以外的字符串（包括空格）按顺序组合成一个字符串数组，作为函数的第一个参数；再将嵌入的变量值依次作为第二个参数、第三个参数……。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>乐游原 - 青龙寺樱花</title>
      <link href="/2019/03/21/qinglong-sakura/"/>
      <url>/2019/03/21/qinglong-sakura/</url>
      
        <content type="html"><![CDATA[<p>大学母校与佛教八大宗派之一 —— 密宗祖庭，唐朝佛教真言宗祖庭的青龙寺只有两站路程，算得上是西安城内离青龙寺最近的高校，也是一种难得的缘分。然而，大学四年却未能亲身领略青龙寺的千年樱花美景。</p><p>近日，稍有闲暇，与朋友一同前去，也算是弥补了往日的遗憾，再续大学四年的缘分。此次前去，是三月下旬，时间稍早，算是早春时节，樱花并未全部开放，但依然有络绎不绝的游人前来观赏，其中也不乏许多外地游客。</p><p>游玩的过程中，拍得些许美丽景致，挑选其中几张满意之作，成此影集，与大家分享，也望朋友们不吝赐教。</p><p><img src="/medias/galleries/qinglong-sakura/IMG_20190320_144732.jpg" alt="日本垂樱-娥眉"></p><div class="gallery-tip-ceter">2019.03.20-摄于西安市青龙寺</div><p><img src="/medias/galleries/qinglong-sakura/IMG_20190320_145046.jpg" alt="日本垂樱-蜜蜂"></p><div class="gallery-tip-ceter">2019.03.20-摄于西安市青龙寺</div><p><img src="/medias/galleries/qinglong-sakura/IMG_20190320_145943.jpg" alt="樱花"></p><div class="gallery-tip-ceter">2019.03.20-摄于西安市青龙寺</div><p><img src="/medias/galleries/qinglong-sakura/IMG_20190320_150139.jpg" alt="樱花-阁楼"></p><div class="gallery-tip-ceter">2019.03.20-摄于西安市青龙寺</div><p><img src="/medias/galleries/qinglong-sakura/IMG_20190320_151655.jpg" alt="摄于西安市青龙寺"></p><div class="gallery-tip-ceter">2019.03.20-摄于西安市青龙寺</div><p><img src="/medias/galleries/qinglong-sakura/IMG_20190320_160616.jpg" alt="青龙寺遗址出土文物"></p><div class="gallery-tip-ceter">2019.03.20-摄于西安市青龙寺</div><style>  #galleryContent img#sina-blog-img,  #galleryContent img#sina-blog {    width: auto;  }</style>]]></content>
      
      
      <categories>
          
          <category> 影集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青龙寺(影集) </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6 - 解构赋值</title>
      <link href="/2019/03/18/ES6-destructuring/"/>
      <url>/2019/03/18/ES6-destructuring/</url>
      
        <content type="html"><![CDATA[<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><blockquote><p>ES6允许按照<strong>一定的模式</strong>，从数组和对象中提取值，然后对变量赋值，这被称为<code>解构赋值</code>。</p></blockquote><p>这听起来比较抽象。我们来用一个简单的例子，直观明了的解释什么是解构赋值。</p><p>在解构赋值之前，我们如果需要一次性声明并赋值多个变量，需要这样操作：</p><pre><code>let a = 123;let b = &#39;bbb&#39;;let c = true;</code></pre><p>这样，如果要声明初始化的变量很多（假设有十几二十个），这样写显得很麻烦，不够优雅。ES6中的解构赋值，就简化了这一操作。</p><p>上面的例子用解构赋值，可以像下面这样操作，同样可以达到相同的效果。</p><pre><code>// 为了让大家先直观了解什么是解构赋值，我们先用数组的结构赋值来演示讲解。let [a, b, c] = [123, &#39;bbb&#39;, true]</code></pre><p>这样一次性声明赋值多个变量就方便了很多。其实，这种写法属于<code>“模式匹配”</code>，只要等号两边的模式相同，就能将左边模式对应的值赋值给最右边对应模式处的变量。</p><p>所以，本质上<strong>解构赋值就是采用<code>模式匹配</code>的方法，从数组/对象中提取对应位置或者对应名称属性的值，对变量进行赋值</strong>。</p><h4 id="一、数组的解构赋值"><a href="#一、数组的解构赋值" class="headerlink" title="一、数组的解构赋值"></a>一、数组的解构赋值</h4><h5 id="1、常用的数组解构赋值"><a href="#1、常用的数组解构赋值" class="headerlink" title="1、常用的数组解构赋值"></a>1、常用的数组解构赋值</h5><p>我们先来看看数组解构赋值都有哪些方式。</p><pre><code>// 最基本的数组解构赋值let [a, b, c] = [1, &#39;2&#39;, false];console.log(a, b, c);       // 1 &#39;2&#39; false// 使用嵌套数组进行解构赋值let [d, [e, f], g] = [1, [2, &#39;3&#39;], [4]];console.log(d, e, f, g);    // 1 2 &#39;3&#39; [4]// 左边（声明变量）的模式中，可以有缺省let [ , h, , i] = [&#39;one&#39;, [1, 2, 3], null, {hProperty: &#39;HHH&#39;}];console.log(h, i);          // [1, 2, 3] {hProperty: &#39;HHH&#39;}// 数组解构赋值可以使用rest参数let [first, ...rest] = [1, 2, 3, 4, 5];console.log(first, rest);   // 1 [2, 3, 4, 5]// !!!这个例子需要特别注意!!!let [x, y, ...z] = [&#39;a&#39;];console.log(x, y, z);       // &#39;a&#39; undefined []/** * 1、使用数组解构赋值，如果rest参数（上面的例子为变量z）没有对应赋值匹配 *    那么该变量会被赋值为空数组。 * 2、如果有的变量模式匹配失败，上面的例子中变量y没有匹配到赋值， *    则会被赋值为 undefined */</code></pre><h5 id="2、等号左侧（变量）模式匹配不成功"><a href="#2、等号左侧（变量）模式匹配不成功" class="headerlink" title="2、等号左侧（变量）模式匹配不成功"></a>2、等号左侧（变量）模式匹配不成功</h5><p>如果左侧模式匹配不成功，则变量会被赋值为<code>undefined</code>。</p><pre><code>let [a] = [];       // a匹配失败console.log(a);     // undefinedlet [a, b] = [&#39;AAA&#39;];   // b匹配失败console.log(a, b);      // &#39;AAA&#39; undefined</code></pre><h5 id="3、等号右侧（赋值）模式匹配不成功"><a href="#3、等号右侧（赋值）模式匹配不成功" class="headerlink" title="3、等号右侧（赋值）模式匹配不成功"></a>3、等号右侧（赋值）模式匹配不成功</h5><p>如果等号左边（变量）的模式只匹配等号右边（赋值）的模式中的一部分，称为<code>不完全结构</code>。这样也是可以成功解构赋值的。</p><pre><code>// 等号右边的值&#39;string&#39;并未匹配到左侧的变量let [a, b] = [1, {bProperty: &#39;BBB&#39;}, &#39;string&#39;];console.log(a, b);      // 1 {bProperty: &#39;BBB&#39;}// 等号右侧的值3，并未匹配到左侧的变量let [c, [d], e] = [1, [2, 3], 4];console.log(c, d, e);      // 1 2 4</code></pre><p>以上的例子都是不完全结构，依旧可以正常运行，完成解构赋值。</p><h5 id="4、等号右侧不具备-Iterator-接口"><a href="#4、等号右侧不具备-Iterator-接口" class="headerlink" title="4、等号右侧不具备 Iterator 接口"></a>4、等号右侧不具备 Iterator 接口</h5><p>如果等号的右边不是数组（或者严格地说，不具备 Iterator 接口），那么将会报错。下面的解构赋值都会报错！！</p><pre><code>// 作为简单类型的值，解构赋值时，会将其转换为对象（基本包装类型）let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;// 本身就不具备 Iterator 接口let [foo] = {};</code></pre><p>在解构赋值时，简单类型的值会被临时转换为对象（基本包装类型），它不具备 Iterator 接口，<code>{ }</code>本身也不具备 Iterator 接口，所以上面的解构赋值都会报错。</p><h5 id="5、数组解构赋值设置默认值"><a href="#5、数组解构赋值设置默认值" class="headerlink" title="5、数组解构赋值设置默认值"></a>5、数组解构赋值设置默认值</h5><p>数组结构赋值时，允许为任何一个变量设置默认值。并且，<strong>当且仅当</strong>等号右侧的赋值严格等于（<code>===</code>，三个等号的严格等于）<code>undefined</code>时，默认值才会生效。</p><pre><code>/** * 下面这个例子，首先是变量a匹配右侧失败，被设置为默认的 undefined * 因为a为 undefined，所以默认值生效 */let [a = 123] = [];console.log(a);     // 123let [b, c = &#39;CCC&#39;] = [[1, 2]];console,log(b, c);  // [1, 2] CCClet [d = false] = [true];console.log(d);     // truelet [e = {}, f = 100, g = {gProperty: &#39;GGG&#39;}] = [false, 0, undefined];console.log(e, f, g);       // false 0 {gProperty: &#39;GGG&#39;}</code></pre><p>还有一个细节需要明确！<strong>默认值取值是<code>惰性求值</code>的</strong>。也就是说，当一个默认值是一个JS表达式的时候，如果默认值不需要生效，那么这个表达式是不会运行计算求值的。</p><pre><code>// 因为 null 并不严格等于 undefined，所以 b 的默认值不会生效// 因此，a + 1是不会执行的。let [a, b = a + 1] = [1, null]console.log(a, b);      // 1 null// 这个例子同上function calDefault() {    return 123}let [c, d = calDefault()] = [1, 2];console.log(c, d);      // 1 2</code></pre><h4 id="二、对象的解构赋值"><a href="#二、对象的解构赋值" class="headerlink" title="二、对象的解构赋值"></a>二、对象的解构赋值</h4><p>对象的解构赋值和数组的类似，区别在于数组的解构赋值是有顺序的，是按照对应位置顺序来解构并赋值的。但是，对象的解构赋值不受顺序影响，是按照变量名和属性名相同的对应关系来解构并赋值的。</p><h5 id="1、常用的对象解构赋值"><a href="#1、常用的对象解构赋值" class="headerlink" title="1、常用的对象解构赋值"></a>1、常用的对象解构赋值</h5><pre><code>// 最简单的对象解构赋值let {name, age} = {name: &#39;cao&#39;, age: 24};console.log(name, age);     // &#39;world&#39; 24// 嵌套对象解构赋值let person = {    base: {        name: &#39;cao&#39;,        age: 24    },    address: &quot;Xi&#39;An&quot;}let {base: {name, age}, address} = person;console.log(name, age, address);        // &#39;cao&#39; 24 &quot;Xi&#39;An&quot;</code></pre><h5 id="2、嵌套对象解构赋值的特别说明！！（重要，一定要理解！）"><a href="#2、嵌套对象解构赋值的特别说明！！（重要，一定要理解！）" class="headerlink" title="2、嵌套对象解构赋值的特别说明！！（重要，一定要理解！）"></a>2、嵌套对象解构赋值的特别说明！！（重要，一定要理解！）</h5><pre><code>// 多层次嵌套let node = {  loc: {    start: {      line: 1,      column: 5    }  }};let { loc, loc: { start }, loc: { start: { line }} } = node;console.log(loc,);      // {start: {line: 1, column: 5}}console.log(start);     // {line: 1, column: 5}console.log(line);      // 1</code></pre><p><strong>！！注意！！</strong>这里要特别说明，对<code>line</code>进行解构赋值的时候，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不是变量。</p><h5 id="3、等号左侧模式匹配不成功"><a href="#3、等号左侧模式匹配不成功" class="headerlink" title="3、等号左侧模式匹配不成功"></a>3、等号左侧模式匹配不成功</h5><p>和数组解构赋值类似，对象解构赋值中，如果等号左侧的变量名未匹配到右侧对象中相同的属性名，那么该变量默认赋值为<code>undefined</code>。</p><pre><code>// 左侧 b 匹配失败let {a, b} = {a: [1, 2], c: &#39;CCC&#39;};console.log(b);     // undefined// 左侧c、d都匹配失败let {c, d} = {};console.log(c, d);      // undefined undefined</code></pre><h5 id="4、等号右侧模式匹配不成功"><a href="#4、等号右侧模式匹配不成功" class="headerlink" title="4、等号右侧模式匹配不成功"></a>4、等号右侧模式匹配不成功</h5><p>等号右侧模式匹配不成功依旧可以成功解构赋值。</p><pre><code>let val = {    a: &#39;AAA&#39;,    b: {        c: &#39;CCC&#39;    },    d: [1, 2, 3]};// 右侧属性 d 未匹配到左侧对应变量，不完全结构，不会报错let {a, b: {c}} = val;  // 这里b是模式，不是变量。console.log(a, c);      // &#39;AAA&#39; &#39;CCC&#39;</code></pre><h5 id="5、变量名与属性名不一致时"><a href="#5、变量名与属性名不一致时" class="headerlink" title="5、变量名与属性名不一致时"></a>5、变量名与属性名不一致时</h5><p>从上面对象解构赋值可以看出，要声明的变量名和属性名相同时才能成功解构并赋值。但如果要声明的变量名和对象名不一致呢？或者说我们需要将和属性名相同而解构赋值得到的同名变量定义成别的名字呢？这种情况，<strong>只能（只能）</strong>像下面这样。</p><pre><code>// 这相当于把右侧的属性n的值解构到左侧，并重新起名为变量namelet {n: name, a: age} = {n: &#39;cao&#39;, a: 24};console.log(name, age);     // &#39;cao&#39; 24</code></pre><p>上面的例子，其实我们最终定义的是<code>name</code>、<code>age</code>两个变量。相当于把右侧对象的属性<code>n</code>的值解构到左侧变量<code>n</code>（实际不存在变量<code>n</code>），并重新起名为变量<code>name</code>。变量<code>age</code>同理。</p><h5 id="6、对象解构赋值设置默认值"><a href="#6、对象解构赋值设置默认值" class="headerlink" title="6、对象解构赋值设置默认值"></a>6、对象解构赋值设置默认值</h5><p>和数组解构赋值类似，对象的解构赋值也可以指定默认值。默认值生效的条件是，<strong>当且仅当</strong>对象的属性值<strong>严格等于</strong><code>undefined</code>。</p><pre><code>let {a = 3} = {};console.log(a);     // 3let {b, c = 5} = {b: 1};console.log(b, c);     // 1 5let {c: d = 3} = {};console.log(d);     // 3let {c: e = 3} = {c: 5};console.log(e);     // 5let {message: msg = &#39;msg Content&#39;} = {};console.log(msg);     // &#39;msg Content&#39;</code></pre><h4 id="三、基本数据类型的解构赋值"><a href="#三、基本数据类型的解构赋值" class="headerlink" title="三、基本数据类型的解构赋值"></a>三、基本数据类型的解构赋值</h4><h5 id="1、字符串解构赋值"><a href="#1、字符串解构赋值" class="headerlink" title="1、字符串解构赋值"></a>1、字符串解构赋值</h5><p>字符串也可以解构赋值。因为解构时，字符串会被转换成了一个类似数组的对象。</p><pre><code>const [a, b, c, d, e] = &#39;hello&#39;;console.log(a, b, c, e);        // &#39;h&#39; &#39;e&#39; &#39;l&#39; &#39;l&#39; &#39;o&#39; let {length} = &#39;hello&#39;;console.log(length);        // 5</code></pre><h5 id="2、数值、布尔值的解构赋值"><a href="#2、数值、布尔值的解构赋值" class="headerlink" title="2、数值、布尔值的解构赋值"></a>2、数值、布尔值的解构赋值</h5><p>解构赋值时，如果等号右边是数值和布尔值，则会先将其转换为对象（基本包装类型）。</p><pre><code>let {toString: s1} = 123;console.log(s1 === Number.prototype.toString);   // truelet {toString: s2} = true;console.log(s2 === Boolean.prototype.toString); // true</code></pre><h5 id="3、undefined-和-null-的解构赋值（报错！！）"><a href="#3、undefined-和-null-的解构赋值（报错！！）" class="headerlink" title="3、undefined 和 null 的解构赋值（报错！！）"></a>3、undefined 和 null 的解构赋值（报错！！）</h5><p><strong>解构赋值的规则是，只要等号右边的值不是数组或者对象，就先将其转为对象</strong>。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p><pre><code>let { x } = undefined;  // TypeErrorlet { y } = null;       // TypeError</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6 - let、const、var的区别</title>
      <link href="/2019/03/15/ES6-let-const/"/>
      <url>/2019/03/15/ES6-let-const/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了使JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言，<code>ECMAScript 6.0</code>（简称<code>ES6</code>）在标准中添加了很多新的特性。我们将用几篇文章总结一下ES6标准中一些常用的新特性。本片文章主要讲解ES6中的<code>let</code>、<code>const</code>命令，并区分其与<code>var</code>命令的区别。</p></blockquote><h3 id="let-与-var-的区别"><a href="#let-与-var-的区别" class="headerlink" title="let 与 var 的区别"></a>let 与 var 的区别</h3><h4 id="一、let声明的变量只在其所在的块级作用于有效"><a href="#一、let声明的变量只在其所在的块级作用于有效" class="headerlink" title="一、let声明的变量只在其所在的块级作用于有效"></a>一、let声明的变量只在其所在的块级作用于有效</h4><p>所谓块级作用域是指：将多个代码语句封装在一起，通常是包含在一个大括号中，没有返回值。比如：</p><pre><code>if (true) {  // 块级作用域  }for (let i = 0; i &lt; 10; i++) {  // 块级作用域  }while (true) {  // 块级作用域  }switch (case) {  // 块级作用域  }</code></pre><p>以上例子，大括号（{…}）中形成的都属于块级作用域。</p><p>众所周知，在ES6之前，JavaScript中只有全局作用域和局部（函数）作用域，不存在块级作用域。而且也只能使用关键字<code>var</code>来声明变量。所以用<code>var</code>声明的变量要么是属于全局作用域的全局变量，要么就是属于局部（函数）作用域的局部变量。</p><p>在ES6标准中，添加了使用<code>let</code>声明变量的方式。使用<code>let</code>声明的变量只在块级作用域中有效，在其外层作用域访问时就会报错。</p><pre><code>if (true) {    // 这个用let声明的变量a，只在当前块级作用域中有效    let a = 123;    // 这个用var声明的变量b，在全局作用域中都有效    var b = &#39;123&#39;;    console.log(a);     // 123    console.log(b);     // &#39;123&#39;}console.log(a);     // 报错 —— ReferenceError: a is not defined.console.log(b);     // &#39;123&#39;</code></pre><p>上面的例子中，因为变量<code>a</code>是使用<code>let</code>声明的，它只在其所在的块级作用域——<code>if</code>后面的大括号({…})之中有效，在块级作用域外层访问时就会报错。而用<code>var</code>声明的变量<code>b</code>，不受块级作用域的约束，可以跨块级作用域访问。这个例子中，变量<code>b</code>实际是属于全局作用域的全局变量。</p><p>那么，为什么ES6中需要引入块级作用域的概念呢？为什么要增加使用<code>let</code>来声明变量的方式呢？</p><p>因为，如果没有块级作用域会导致一些不合理的情形出现。</p><p>1、 内层变量可能会覆盖外层变量。</p><pre><code>var a = &#39;Global&#39;;function inner() {    if (true) {        console.log(a);     // undefined        var a = &#39;inner&#39;;        /**         * 以上两行代码相当于         * var a;         * console.log(a);         * a = &#39;inner&#39;;          * 再次使用var声明同名变量a，会覆盖全局变量a         */    }}inner();</code></pre><p>这个例子，当在函数<code>inner</code>内部<code>if</code>代码块内首先访问变量<code>a</code>时，却得到的是<code>undefined</code>。这是因为紧随其后<code>var</code>声明的同名变量<code>a</code>会变量提升并覆盖全局变量<code>a</code>。所以打印出<code>a</code>的值为<code>undefined</code>。</p><p>2、计数的循环变量会泄露为全局变量</p><pre><code>for (var i = 0; i &lt; 10; i++) {    // 一些循环操作}console.log(i);     // 10</code></pre><p>上面的例子，<code>for</code>循环中的循环变量按道理来说应该只属于<code>for</code>循环体，循环结束就不能再访问。但实际这样用<code>var</code>声明的<code>i</code>，属于外层作用域中的变量，也就是说<code>i</code>泄露为全局变量。所以当执行到<code>console.log(i)</code>时，因为<code>i</code>经过循环已经增加到<code>10</code>，所以打印出<code>i</code>的值为<code>10</code>。</p><h4 id="二、let声明的变量不存在变量提升过程"><a href="#二、let声明的变量不存在变量提升过程" class="headerlink" title="二、let声明的变量不存在变量提升过程"></a>二、let声明的变量不存在变量提升过程</h4><p>用<code>var</code>声明的变量，会在其作用域中<strong>发生<code>变量提升</code>的过程</strong>。变量会被提升到作用域顶部，JS默认给变量一个<code>undefined</code>值。在使用<code>var</code>声明一个变量前访问它，得到的值永远是<code>undefined</code>。</p><p>但是，在ES6中<strong>使用<code>let</code>声明的变量，不存在<code>变量提升</code>过程</strong>。也就是说，不能在使用<code>let</code>声明任何一个变量前访问它，否则都会报错。</p><pre><code>console.log(a);     // 报错——ReferenceError: a is not definedlet a = &#39;Hello World!&#39;；</code></pre><h4 id="三、let声明的变量存在“暂时性死区”"><a href="#三、let声明的变量存在“暂时性死区”" class="headerlink" title="三、let声明的变量存在“暂时性死区”"></a>三、let声明的变量存在“暂时性死区”</h4><p>只要使用<code>let</code>声明了一个变量，那这个变量就“绑定”到了这个作用域（全局/局部/块级），该变量就不再受外层作用域的影响。</p><p>ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为<code>“暂时性死区”</code>（temporal dead zone，简称 TDZ）。</p><pre><code>let g = &#39;Global&#39;;if (true) {    g = &#39;Block&#39;;    // 报错——ReferenceError: g is not defined    let g;}</code></pre><p>上面的例子中，<code>if</code>代码块最顶部一直到<code>let</code>声明变量<code>g</code>之前，都是<code>g</code>的“暂时性死区”。在该范围内访问<code>g</code>都会报错。</p><h4 id="四、let声明的变量不允许再次重复声明"><a href="#四、let声明的变量不允许再次重复声明" class="headerlink" title="四、let声明的变量不允许再次重复声明"></a>四、let声明的变量不允许再次重复声明</h4><p>使用<code>var</code>声明变量，可以多次重复声明一个同名变量。最终变量的值为最后一次声明赋值的结果。</p><pre><code>var a = 123;var a = &#39;Hello World!&#39;;console.log(a);     // &#39;Hello World!&#39;</code></pre><p>但是，<strong>在同一作用域（全局/局部/块级）中不允许使用let重复声明变量。或者说不允许存在与用<code>let</code>声明的变量同名的变量</strong>。以下代码都会报错！</p><pre><code>// 先var，后letvar a = 123;// ...一些代码let a = &#39;Hello World!&#39;;     // 报错——Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared// 先let，后varlet b = 123;// ...一些代码var b = &#39;Hello World!&#39;;     // 报错——Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared// 先let，再letlet c = 123;// ...一些代码let c = &#39;Hello World!&#39;;     // 报错——Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared</code></pre><h4 id="五、let声明的全局变量不会作为window对象的一个属性"><a href="#五、let声明的全局变量不会作为window对象的一个属性" class="headerlink" title="五、let声明的全局变量不会作为window对象的一个属性"></a>五、let声明的全局变量不会作为window对象的一个属性</h4><p>使用<code>var</code>声明的全局变量，会被JS自动添加在全局对象<code>window</code>上，作为该对象的一个属性。</p><pre><code>var myVar = &#39;myName&#39;;console.log(window.myVar);      // &#39;myName&#39;console.log(window.hasOwnProperty(&#39;myVar&#39;));    // true</code></pre><p>但是，使用let声明的全局变量不会作为window对象的一个属性。</p><pre><code>let yourVar = &#39;yourName&#39;;console.log(window.yourVar);      // undefinedconsole.log(window.hasOwnProperty(&#39;yourVar&#39;));    // false</code></pre><p>这个例子可以看出，<code>let</code>声明的全局变量<code>yourVar</code>，并没有被添加到<code>window</code>对象上，没有作为<code>window</code>的一个属性。</p><h3 id="let-与const-的区别"><a href="#let-与const-的区别" class="headerlink" title="let 与const 的区别"></a>let 与const 的区别</h3><p>在ES6中，上述所有<code>let</code>所具有的特性，对于<code>const</code>来说同样存在。但<code>const</code>与<code>let</code>、<code>var</code>的区别在于<code>const</code>是用来声明<strong>常量</strong>的。</p><p>常量具有以下特点：</p><h4 id="一、常量值不可修改"><a href="#一、常量值不可修改" class="headerlink" title="一、常量值不可修改"></a>一、常量值不可修改</h4><p>一个常量，一旦声明，任何时间、任何地点都不能修改它的值。</p><pre><code>const PI = 3.1415926;console.log(PI);    // 3.1415926PI = 3; // 报错——Uncaught TypeError: Assignment to constant variable.</code></pre><h4 id="二、常量在声明时必须必须立即初始化（赋初始值）"><a href="#二、常量在声明时必须必须立即初始化（赋初始值）" class="headerlink" title="二、常量在声明时必须必须立即初始化（赋初始值）"></a>二、常量在声明时必须必须立即初始化（赋初始值）</h4><p>不能只声明一个常量名，但不对其进行初始化赋值。否则在声明常量时就会报错。</p><pre><code>const PI;   // 报错——Uncaught SyntaxError: Missing initializer in const declarationPI = 3.1415926;</code></pre><h4 id="三、常量的值不可修改的实质（重要！！）"><a href="#三、常量的值不可修改的实质（重要！！）" class="headerlink" title="三、常量的值不可修改的实质（重要！！）"></a>三、常量的值不可修改的实质（重要！！）</h4><p>实际上，常量的值不变，是指常量指向的那个内存地址中所保存的数据不可更改。对于简单的数据类型（数值，字符串、布尔值），他们本身具体的值就保存在常量所指向的那个内存地址中，所以不能修改改简单类型的数据值。</p><p>但是，如果一个常量的值是一个引用类型值，那么常量所指向的内存地址中实际保存的是指向该引用类型值的一个指针（也就是引用类型值在内存中的地址）。所以const只能保证该引用类型地址不变，但该地址中的具体数据是可以变化的。</p><p>下面的例子，代码不会报错，可以正常运行！</p><pre><code>// !!!常量OBJ中实际保存的是后面的对象在内存中的地址!!!const OBJ = {};/** * !!!!!!!!!! * 修改OBJ.prop1，实际只是修改了对象的属性， * 但并没有改变该对象在内存中的地址， * 所以常量OBJ并没有发生变化 * !!!!!!!!!! */OBJ.prop1 = 123;OBJ.prop2 = &#39;Hello World!&#39;/** * !!!!!!!!!! * 下面这一行就会报错, * 因为此时OBJ指向了另一个对象，OBJ中保存的地址发生了变化 * !!!!!!!!!! */OBJ = {};   // 报错——Uncaught TypeError: Assignment to constant variable.</code></pre><p>下面的例子和上面同理。</p><pre><code>const ARR = [];ARR.push(&#39;Hello&#39;);  // 可执行ARR.length = 0;     // 可执行ARR = [&#39;Dave&#39;];     // 报错，因为ARR重新指向了数组[&#39;Dave&#39;]所在的内存地址</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript - 执行环境、作用域、作用域链、闭包</title>
      <link href="/2019/03/13/ECtx-scope-closure/"/>
      <url>/2019/03/13/ECtx-scope-closure/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JavaScript中的执行环境、作用域、作用域链、闭包一直是一个非常有意思的话题，很多博主和大神都分享过相关的文章。这些知识点不仅比较抽象，不易理解，更重要的是与这些知识点相关的问题在面试中高频出现。之前我也看过不少文章，依旧是似懂非懂，模模糊糊。最近，仔细捋了捋相关问题的思路，对这些问题的理解清晰深入了不少，在这里和大家分享。</p></blockquote><p>这篇文章，我会按照执行环境、作用域、作用域链、闭包的顺序，结合着JS中函数的运行机制来梳理相关知识。因为这样的顺序刚好也是这些知识点相互关联且递进的顺序，同时这些知识点都又与函数有着千丝万缕的联系。这样讲解，会更容易让大家彻底理解，至少我就是这样理解清晰的。</p><p>废话不再多说，我们开始。</p><h3 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h3><p>首先，我们还是要理解一下什么是执行环境，这也是理清后面问题的基础。</p><blockquote><p>执行环境是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。——《JavaScript高级程序设计》</p></blockquote><p>抽象！不理解！没关系，我来解释：其实，执行环境就是JS中提出的一个概念，它是为了保证代码合理运行采用的一种机制。</p><p>一种概念…机制…更抽象，那它到底是什么？<strong>实际上，执行环境在JS机制内部<code>就是用一个对象来表示的</code>，称作<code>执行环境对象</code>，简称<code>环境对象</code></strong>。</p><p>那么，这个执行环境对象到底又是何时、怎么产生的呢？有以下两种情况：</p><ol><li>在页面中的脚本开始执行时，就会产生一个“全局执行环境”。它是最外围（范围最大，或者说层级最高）的一个执行环境，对应着一个全局环境对象。在Web浏览器中，这个对象就是<code>Window</code>对象。</li><li>当一个函数被调用的时候，也会创建一个属于该函数的执行环境，称作“局部执行环境”（或者称作函数执行环境），它也对应着自己的环境对象。</li></ol><p>因此，执行环境就分为<code>全局执行环境</code>和<code>局部执行环境</code>两种，每个执行环境都有一个属于自己的环境对象。</p><p>既然执行环境是使用一个对象表示的，那么对象就有属性。我们来看看环境对象的三个有意思的属性。<code>变量对象</code>、<code>[[scope]]</code>、<code>this</code>。</p><p><img src="/medias/article/coding/ectx-scope-closure/context-object.jpg" alt="环境对象"></p><h4 id="环境对象中的变量对象"><a href="#环境对象中的变量对象" class="headerlink" title="环境对象中的变量对象"></a>环境对象中的变量对象</h4><p>《JS高程》中明确说明，执行环境定义了变量或函数有权访问的其他数据。那么这些数据到底被放（存储）在哪里呢？</p><p>其实，每个执行环境都有一个与之关联的变量对象，在环境中定义的所有变量和函数都保存在这个对象中。我们在代码无法访问这个对象，但解析器在处理数据时会在内部使用它。</p><p>通俗地说就是：一个执行环境中的所有变量和函数都保存在它对应的环境对象的变量对象（属性）中。</p><h4 id="认识-scope-前先理解作用域"><a href="#认识-scope-前先理解作用域" class="headerlink" title="认识[[scope]]前先理解作用域"></a>认识[[scope]]前先理解作用域</h4><p>在讲<code>[[scope]]</code>前，我们就需要先弄清楚什么是<strong>作用域</strong>了。因为作用域与<code>[[scope]]</code>之间存在着非常紧密的关系。</p><blockquote><p>《JS高程》中没有明确给出作用域的定义和描述。其实，作用域就是变量或者函数可以被访问的代码范围，或者说作用域就是变量和函数所起作用的范围。</p></blockquote><p>这样看来作用域也像是一个概念，它是用来描述一个区域（或者说范围）的。在JS中，作用域分为<code>全局作用域</code>、<code>局部作用域</code>两种。</p><p>我们来看看这两种作用域的具体描述：</p><p>  <strong>①</strong>在页面中的脚本开始执行时，就会产生一个“全局作用域”。它是最外围（范围最大，或者说层级最高）的一个作用域。全局作用域的变量、函数<br>可以在代码的任何地方访问到。<br>  <strong>②</strong>当一个函数被创建的时候，会创建一个“局部作用域”。局部作用域中的函数、变量只能在某些局部代码中可以访问到。</p><p>看一个例子：</p><pre><code>var g = &#39;Global&#39;;function outer() {  var out = &#39;outer&#39;;  function inner() {    var inn = &#39;inner&#39;;  }} </code></pre><p>上面这个例子，产生的作用域就如下图所示：</p><p><img src="/medias/article/coding/ectx-scope-closure/scope.jpg" alt="作用域"></p><p><strong>请注意上面</strong>①<strong>、</strong>②<strong>这两段话！！！</strong>是不是觉得很熟悉，似曾相识？！没错，这两段话和介绍全局/局部执行环境（全局/局部环境对象）时候的描述几乎一摸一样！作用域是不是和环境对象有着千丝万缕的联系呢？与此同时，我们再仔细回忆一下：1、作用域就是变量或者函数可以被访问的代码范围。2、一个执行环境中定义的所有变量和函数都保存在它对应的环境对象中。</p><p>结合上面所述，其实不难得出：尽管作用域的描述更像是一个概念，但如果一定要将它具象化，问它到底是什么东西，与执行环境有什么关系？<strong><code>其实，作用域所对应的（不是相等、等于）是环境对象中的变量对象。</code></strong></p><p>明白了这些，我们就可以来看看环境对象中的<code>[[scope]]</code>属性。</p><h4 id="环境对象中的-scope"><a href="#环境对象中的-scope" class="headerlink" title="环境对象中的[[scope]]"></a>环境对象中的[[scope]]</h4><p>首先，要明确的是，环境对象中的<code>[[scope]]</code>属性值是一个指针，它指向该执行环境的作用域链。</p><p>到底什么是作用域链呢？<strong>作用域链本质上就是一个<code>有序的列表</code>，而列表中的每一项都是一个<code>指向不同环境对象中的变量对象的指针</code>。</strong></p><p>那么，这个作用域链到底是怎么形成的呢？它里面指向变量对象的指针的顺序又是如何规定的呢？我们用下面这个简单的例子说明。</p><pre><code>var g = &#39;Hello&#39;;function inner() {  var inn = &#39;Inner&#39;;  var res = g + inn;  return res;}inner();</code></pre><p>当执行了<code>inner();</code>这一行代码后，代码执行流进入<code>inner</code>函数内部，此时，JS内部会先创建<code>inner</code>函数的局部执行环境，然后创建该环境的作用域链。这个作用域链的最前端，就是<code>inner</code>执行环境自己的环境对象中的<code>变量对象</code>，作用域链第二项，就是全局环境的环境对象中的<code>变量对象</code>。这条作用域链如下图所示：</p><p><img src="/medias/article/coding/ectx-scope-closure/scope-chain.jpg" alt="作用域链"></p><p>形成了这样的作用域链之后，就可以有秩序地访问一个变量了。以这个例子为例：当执行<code>inner();</code>进入函数体内后，执行<code>g + inn;</code>一行，需要访问变量<code>g、inn</code>，此时JS内部机制就会沿着这条作用域链查找所需变量。在当前<code>inner</code>函数的作用域中找到了变量<code>inn</code>，值为<code>&#39;Inner&#39;</code>，查找终止。但是却没有找到变量<code>g</code>，于是沿着作用域链向上查找，进入全局作用域，在全局变量对象中找到了变量<code>g</code>，值为<code>&#39;Hello&#39;</code>，查找终止。计算得出<code>res</code>为<code>&#39;HelloInner&#39;</code>，并在最后返回结果。</p><p>与上面所讲机制完全相同，如果是多层执行环境嵌套，则作用域链是这么形成的：</p><blockquote><p>当代码执行进入一个执行环境时，JS内部会开始创建该环境的作用域链。作用域链的<strong>最前端</strong>，始终都是<strong>当前执行环境的执行环境对象中的变量对象</strong>。如果这个环境是<strong>局部执行环境（函数执行环境）</strong>，则将其<strong>活动对象</strong>作为<strong>变量对象</strong>。作用域链中的下一个是来自<strong>外层环境对象的变量对象</strong>，而再下一个则是来自<strong>再外层环境对象的变量对象</strong>…… 这样<strong>一直延续到全局环境对象的变量对象</strong>。所以，全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p></blockquote><p>讲到这里，可能你已经对执行环境、执行环境对象、变量对象、作用域、作用域链的理解已经他们之间的关系有了一个较清晰的认识。也有可能，对这么多的抽象问题还是有些懵懵懂懂。没关系，我们用下面这一张图，将上面的所有内容串联起来，来直观感受和理解他们。</p><pre><code>var g = &#39;Global&#39;;function outer() {  var out = &#39;outer&#39;;  function inner() {    var inn = &#39;inner&#39;;  }  inner();}outer();</code></pre><p><img src="/medias/article/coding/ectx-scope-closure/ctx-ctxObj-varObj-scope-scopeChain.jpg" alt="环境、环境对象、变量对象、作用域、作用域链"></p><p><strong>对于这张图，有一些需要注意的地方：</strong></p><ol><li>当函数调用时，才会创建函数的执行环境和它的环境对象，再创建函数的活动对象，再创建函数环境的作用域链。</li><li>上图中间一列变量对象中，<code>outer</code>、<code>inner</code>的变量对象其实是该函数的活动对象。<strong>全局环境是没有活动对象的，只有在函数环境中，才会使用函数的活动对象来作为它的变量对象</strong>。</li><li>函数的活动对象，是在函数创建时使用函数内置的<code>arguments</code>类数组和<strong>其他命名参数</strong>来初始化的。所以实际上，<strong>函数的变量对象中应该还包含一个指向<code>arguments</code>类数组的指针</strong>。</li></ol><p>有了对作用域、作用域链的理解，最后，我们来说一说闭包。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h4><blockquote><p>闭包就是有权访问另一个函数作用域中的变量的函数。——《JavaScript高级程序设计》</p></blockquote><p>对于闭包，最简单的大白话可以这么理解：</p><blockquote><p><strong>①</strong>外部函数声明内部函数，内部函数引用外部函数的局部变量，这些变量不会被释放！——这是我曾经看到的别人的说法</p></blockquote><p>或者这么理解：</p><blockquote><p><strong>②</strong>当在一个函数中返回另一个函数的时候（是返回一个函数，不是返回函数的调用或者函数的执行结果），就会形成闭包，被返回的这个函数就叫做闭包函数。——这是我自己的理解</p></blockquote><p>上面两句话看似不同，其实本质是一样的。来看一个最简单的闭包的例子：</p><pre><code>function sum() {  var num1 = 100;  // 这里返回的是函数(体)，不是函数的调用  return function(num2) {    return num1 + num2;  }}// 此时result指向sum返回的那个匿名函数// 注意！此时该匿名函数并没有被执行let result = sum()；result(200);</code></pre><p>那么，上面几行代码，为什么就会形成闭包呢？我们来分析一下，代码执行中JS内部到底做了什么？</p><p>首先，有一点必须明确，就是<strong>一般情况下，一个函数执行完内部的代码，函数调用时所创建的执行环境、环境对象（包括变量对象、[[scope]]等）都会被销毁，它们的生命周期就只有函数调用到函数执行结束这一段时间</strong>。</p><p>但是上面的例子，就会出现例外。</p><p>当执行<code>sum()</code>时，调用该函数，创建它的环境对象，其中作用域链中第一项是自己环境的变量对象，第二项是全局环境的变量对象。当创建匿名函数的时候，也会创建匿名函数的环境对象，其中作用域链第一项是自己环境的变量对象，第二项是<code>sum</code>环境的变量对象，第三项是全局变量对象。</p><p>这时，问题就来了。按说，当函数<code>sum</code>执行完<code>return</code>之后，他的执行环境、变量对象、作用域链都会被销毁。<strong>可是这时候却不能销毁他的变量对象，因为返回的匿名函数（此时由<code>result</code>指向该函数）并没有执行，这个匿名函数的作用域链中还引用着<code>sum</code>函数的变量对象</strong>。换句话说，即使，<code>sum</code>执行完了，其执行环境的作用域链会被销毁，但是<strong>它的变量对象还会保存在内存中</strong>，我们在<code>sum</code>函数外部，还能访问到它内部的变量<code>num1</code>、<code>num2</code>，这就是形成闭包的真正原因。但是，当result()执行完后，这些变量对象、作用域链就会被销毁。</p><h4 id="闭包存在的问题"><a href="#闭包存在的问题" class="headerlink" title="闭包存在的问题"></a>闭包存在的问题</h4><p>因为闭包形成后，会在函数执行完仍将他的变量对象保存在内存中，当引用时间过长或者引用对象很多的时候，会占用大量内存，严重影响性能。</p><p>来看下面的例子：（这个例子曾经是Tencent微众银行的笔试原题，出现在《JS高程》的7.2.3章节——P184）</p><pre><code>function assignHandler() {  var element = document.getElementById(&quot;someElement&quot;);  element.onclick = function(){    alert(element.id);  };}</code></pre><p><code>assignHandler</code>函数中定义的匿名函数是作为<code>element</code>元素的事件处理函数的，且内部使用了<code>element</code>元素（访问元素的<code>id`</code>），因此<code>assignHandler</code>函数执行完，对于<code>element</code>的引用也会一直存在，<code>element</code>元素会一直保存在内存中。</p><p>将上面的例子改成下面这样，就能解决这个问题。</p><pre><code>function assignHandler(){  var element = document.getElementById(&quot;someElement&quot;);  // 这里获取element的id，为其创建一个副本  // 这样是为了在下面事件处理函数中解除对element元素的引用  var id = element.id;  element.onclick = function(){    alert(id);  };  // 将element置为null，断开对element元素的引用  // 这样方便垃圾回收机制回收element所占的内存  element = null;} </code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript - Function</title>
      <link href="/2019/03/12/JavaScript-Function/"/>
      <url>/2019/03/12/JavaScript-Function/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JavaScript中的函数一直是一个很有讨论性的话题点。函数本身不仅仅是一个引用类型——所有函数都是Function类型的实例，更重要的是因为函数还会涉及到执行环境、作用域、闭包以及让人头疼的this等等…这篇文章我们来回顾一下与函数有关的一些值得注意的地方。</p></blockquote><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>定义函数有三种方法：<br>1、函数声明 2、函数表达式 3、使用Function构造函数</p><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><pre><code>function sum (num1, num2) {  return num1 + num2;}</code></pre><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>用函数表达式的方式定义函数，就是将一个匿名函数赋值给一个变量。<br>文章开头说道，所有函数都是Function类型的一个实例，所以，这个变量（引用类型）最终就是一个指向该匿名函数实例的指针。</p><pre><code>var sum = function (num1, num2) {  return num1 + num2;}</code></pre><p>以上两种函数定义方式，从效果上看是相同的，几乎相差无几，但它们之间还是存在一些细微的差别，我们稍后再讲。</p><h4 id="使用Function构造函数"><a href="#使用Function构造函数" class="headerlink" title="使用Function构造函数"></a>使用Function构造函数</h4><p>因为所有函数都是Function类型的实例，所以调用<code>new Function()</code>构造函数，也可以定义函数。</p><pre><code>// 构造函数中最后一个参数始终都被看成是函数体，而前面的所有参数则是枚举出的函数的形参。var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 +num2&quot;)</code></pre><p>实际开发中，很少使用这种方法定义函数。原因主要有两点：</p><ol><li>定义不方便。如果函数体代码过长，使用这种方法，因为最后一个参数是字符串格式，不易换行高亮等。</li><li>这种方式会导致解析两次代码，影响性能。第一次是解析常规JS代码，第二次是解析传入构造函数中的字符串。</li></ol><h4 id="函数声明和函数表达式的区别（重要）"><a href="#函数声明和函数表达式的区别（重要）" class="headerlink" title="函数声明和函数表达式的区别（重要）"></a>函数声明和函数表达式的区别（重要）</h4><p>虽然函数声明和函数表达式都可以定义函数，但是解析器在处理他们的时候还是存在着一些差别。</p><p>当解析器进入一个执行环境并向环境中加载数据的时候，对于用函数声明定义的函数，解析器会率先读取他们，保证在执行任何代码之前，就可以访问调用这些函数。</p><pre><code>console.log(sum(10, 20));   // 30// ...省略很多代代码// 函数声明定义函数function sum (num1, num2) {  return sum1 + sum2;}</code></pre><p>上面的例子，先调用函数<code>sum</code>，在之后的代码中再声明该函数，完全没有问题。因为，<strong>在执行<code>sum(10, 20)</code>以及其他任何代码之前，JS解析器会先将<code>sum</code>函数的声明定义提升到当前执行环境的代码树的最顶端，保证之后随时可以访问调用该函数。这个过程叫做——<code>函数声明提升</code>。</strong></p><p>而用函数表达式定义函数的方式，不会存在函数声明提升的过程。也就是说，必须等到解析器执行到函数表达式定义所在的代码行之后，函数才算被定义成功，之后才可以访问调用该函数。</p><p>像下面这样调用<code>sum</code>函数式，代码运行后会报错，因为<strong>用函数表达式定义函数不会存在函数声明提升的过程</strong>，必须在函数表达式定义函数代码之后才能调用。</p><pre><code>console.log(sum(10,10));    // 这里会报错// ...省略很多代代码// 函数表达式定义函数var sum = function(num1, num2){   return num1 + num2; };</code></pre><p><strong>对于函数声明和函数表达式定义函数的区别，还有一点一定要更加注意：</strong></p><p><strong>首先，JavaScript是支持动态创建函数的。</strong>也就是根据不同的需求或条件来动态定义函数。但是，动态创建须采用函数表达式的方式定义，使用函数声明方式会导致意想不到的错误。</p><p>来看下面的例子：</p><pre><code>function createFunction () {  // 像下面这样根据某个条件来动态声明一个函数很容易导致问题或出错！！！  // arguments是函数中内置的类数组对象，本文后面会讲到  if (arguments.length &gt; 1) {    function sum() {      // ...一种定义    }  } else {    function() {      // ...另一种定义    }  }}</code></pre><p>实际上，上面的动态定义函数的方式，在ECMAScript中属于无效语法，JavaScript引擎会尝试修正错误，将其转换为合理的状态。但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明，忽略<code>arguments.length</code>条件；Firefox会在<code>arguments.length &gt; 1</code>时返回第一个函数声明，因此这种使用方式很危险！！！</p><p>但是利用函数表达式的方式来动态定义函数，是可以达到预想的目的的！！</p><p>上面的例子改写成下这样，就不会出现问题。</p><pre><code>var sum = null;   // 也可以不赋初始值function createFunction () {  // arguments是函数中内置的类数组对象，本文后面会讲到  if (arguments.length &gt; 1) {    sum = function() {      // ...一种定义    }  } else {    sum = function() {      // ...另一种定义    }  }}</code></pre><p>仔细想想，这样能够完美达到目的也很好理解。我们先定义了一个<code>sum</code>变量，最后根据<code>arguments.length</code>是否大于0定义两个不同的匿名函数并赋值给<code>sum</code>变量，这和根据不同条件来为一个变量赋不同的值本质是完全一样的，当然不会有任何问题。</p><h3 id="JS中函数没有重载（重要）"><a href="#JS中函数没有重载（重要）" class="headerlink" title="JS中函数没有重载（重要）"></a>JS中函数没有重载（重要）</h3><p>不论是以哪种方式定义的函数，<strong>函数名实际就是一个指向函数实例的指针，本质上函数名和普通变量没什么区别。</strong>这也就好理解为什么JS中没有函数重载的概念。<br>看下面的例子：</p><pre><code>function sum(num){   return num + 100; } function sum(num) {   return num + 200; } console.log(addSomeNumber(100));    // 300 </code></pre><p>上面这个例子中声明了两个同名<code>sum</code>函数，而结果则是后面的函数定义覆盖了前面的函数，更准确的说<code>sum</code>现在指向后面定义的函数。</p><p>为什么会这样？就是因为JS中函数不存在重载，其实上面的代码实际上与下面的代码没有什么区别。</p><pre><code>var sum = function (num){   return num + 100; }; sum = function (num) {   return num + 200; }; console.log(sum(100));    // 300 </code></pre><p>原来，当第一次定义<code>sum</code>之后，<code>sum</code>指向第一个函数实例，当再次定义第二个函数时，<code>sum</code>会重新指向第二个函数实例。</p><h3 id="函数可以作为值传递"><a href="#函数可以作为值传递" class="headerlink" title="函数可以作为值传递"></a>函数可以作为值传递</h3><p>我们多次强调函数名实际就是一个指向函数实例的指针，本质上函数名和普通变量没什么区别。既然是变量，那么函数也就可以作为另一些函数的参数和返回值来传递。</p><h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><pre><code>function add (num) {  return num + 100;}function cal(calFun, num) {  return calFun(num);}cal(add, 100);    // 200</code></pre><p>上面的例子中，函数<code>cal</code>接收一个函数和一个数值作为参数，最终返回值是第二个参数（数值）在第一个参数（函数）中的执行结果。而第一个参数——函数中具体做的事情，就是将传入的数值参数与100求和。</p><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>此外，函数也可以作为另一个函数的返回值。对上面例子进行稍微的改造，也可达到相同的目的。</p><pre><code>function cal() {  function add (num) {    return num + 100;  }  // 这里返回的是add函数名，而不是函数的调用  return add;}let res = cal();res(100);     // 200</code></pre><p>上面的例子，当执行<code>cal()</code>时，该函数返回了内部声明的<code>add</code>函数，我们将返回值再赋值给<code>res</code>变量，此时，<code>res</code>也就指向了<code>add</code>所指向的函数实例。之后我们再调用<code>res</code>函数，并传入参数，得到的结果也是<code>200</code>。</p><h3 id="函数的内部属性"><a href="#函数的内部属性" class="headerlink" title="函数的内部属性"></a>函数的内部属性</h3><h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>函数中包含一个内置的<code>arguments</code>对象，它是一个类数组对象，包含着所有传入函数中的参数，你可以用数组下标的方式访问其中的元素。</p><pre><code>function show (a, b, c, d, e, f) {  console.log(arguments[4]);    // 输出[333, 444]}show(1, &#39;222&#39;, true, null, [333, 444], {aa: &#39;aaa&#39;, b: function() {}});</code></pre><p><code>arguments</code>对象自己还有一个<code>callee</code>属性，该属性是一个指针，指向拥有这个<code>arguments</code>对象的函数，也就是这个<code>arguments</code>所属的函数。</p><h4 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h4><p>在递归函数中，我们可能会经常使用到<code>arguments.callee</code>这一属性。以一个经典的阶乘函数为例:</p><pre><code>// 递归阶乘的经典例子function factorial(num) {  if (num &lt;=1) {    return 1;  } else {    return num * factorial(num-1);  }}// 递归阶乘的优化例子function factorial(num) {  if (num &lt;=1) {    return 1;  } else {    // 这里的arguments.callee又指向factorial函数    return num * arguments.callee(num-1);  }}</code></pre><p>这样写的好处是，当指向该递归函数的函数名发生变化时，递归函数也能顺利执行完成。如果采用上面经典例子的写法，当出现如下代码逻辑时，就会出错。</p><pre><code>// 将另一变量指向递归阶乘函数var trueFactorial = factorial;// 改写原递归阶乘函数factorial = function() {  return 0;};console.log(trueFactorial(5));console.log(factorial(5));</code></pre><p>如果以递归阶乘的经典例子定义<code>factorial</code>函数，那么<code>trueFactorial(5)</code>这一行就会出错。因为执行到<code>trueFactorial</code>函数内部<code>return num * factorial(num-1);</code>代码时，<code>factorial</code>实际已经指向了<code>function() {return 0;}</code>，计算结果就会出错。但用递归阶乘的优化例子就不会出现这个问题，因为执行<code>trueFactorial(5)</code>语句时，<code>arguments.callee</code>指向<code>trueFactorial</code>函数。</p><h4 id="arguments-callee-caller"><a href="#arguments-callee-caller" class="headerlink" title="arguments.callee.caller"></a>arguments.callee.caller</h4><p><code>arguments.callee.caller</code>这个属性中保存着调用当前函数的函数的引用。也就是说我们可以通过该属性来获得<code>arguments</code>所属于的那个函数（<code>arguments.callee</code>）是在哪个函数（<code>arguments.callee.caller</code>）中被调用的。</p><p>需要注意的是：如果是在全局作用域中调用的当前函数，<code>arguments.callee.caller</code>的获取到的值为<strong><code>null</code></strong>。</p><p>ES5后，我们也可以直接通过函数实例对象的caller属性来直接访问这一属性。</p><pre><code>function outer(){  inner();}function inner(){  console.log(inner.caller);    // 打印出outer函数的源码。因为inner是在outer中被调用的}outer();</code></pre><p>也可以这么写：</p><pre><code>function outer(){  inner();}function inner(){  alert(arguments.callee.caller);   // 打印出outer函数的源码。}outer();</code></pre><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>函数中另一个有意思又令人头疼的属性——this，由于this指向涉及的内容较多，情况稍微复杂一些，我们将会专门用一篇文章来探讨this相关问题。<br>但概括来说，<strong>this引用的是函数据以执行的环境对象</strong>。当this所在的函数在全局作用域中调用时，它指向window对象；当作为对象的方法调用时，它指向该对象。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Function </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript - 事件（基础篇）</title>
      <link href="/2019/03/04/JavaScript-Event/"/>
      <url>/2019/03/04/JavaScript-Event/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是事件"><a href="#什么是事件" class="headerlink" title="什么是事件"></a>什么是事件</h3><blockquote><p>事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。——《JavaScript高级程序设计》<br>事件就是用户或者浏览器自身执行的某种动作。——《JavaScript高级程序设计》</p></blockquote><p>通俗地讲，事件就是用户与文档页面、浏览器交互时做的事情，或者浏览器自身做的某些事情。比如：当用户点击页面中某个元素触发的click事件，在文本框输入文字时的input事件，关闭当前页面的unload事件，调整浏览器窗口大小的resize事件等等…</p><h3 id="事件的作用"><a href="#事件的作用" class="headerlink" title="事件的作用"></a>事件的作用</h3><blockquote><p>事件最早是在 IE3 和 Netscape Navigator 2 中出现的，当时是作为分担服务器运算负载的一种手段。——《JavaScript高级程序设计》<br>JS与HTML之间的交互就是通过事件来实现的。——《JavaScript高级程序设计》</p></blockquote><p>所以很明显，总结起来，事件的核心作用有两点：</p><ol><li>把一些允许的业务逻辑处理，数据计算在前端完成，分担服务器的运算负载。（在事件处理程序中完成）</li><li>完成JS代码和页面HTML的一些交互。</li></ol><p>我们都知道，一个HTML文档是一个树状的DOM结构。那么，试想这样一个DOM情况：</p><pre><code>&lt;div id=&quot;grand&quot;&gt;  &lt;div id=&quot;parent&quot;&gt;    &lt;div id=&quot;child&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><p>上面这三个依次嵌套的div元素，当点击最内层的div#child元素时，是否也算点击了嵌套在它外面的#parent、#grand元素呢？如果是，那么是先点击了哪个元素呢？到底应该是哪个元素的click事件会先触发呢？这就涉及到接下来要说的事件流的概念。</p><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><blockquote><p>事件流是用来描述从页面中接收事件的顺序。——《JavaScript高级程序设计》</p></blockquote><p>针对上面提出的问题，事件流就是来描述：当点击了#child时，到底是#child、#parent、#grand中哪个元素先触发click事件。</p><p><strong>事件流分为<code>捕获流（事件捕获）</code>、<code>冒泡流（事件冒泡）</code>两种。</strong></p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><blockquote><p>事件由最具体（嵌套层次最深）的元素最先接收，逐级向上传播，直到传播到<code>document</code>对象为止（大部分浏览器会将事件一直冒泡到<code>window</code>对象上）。</p></blockquote><p>上面的例子，事件冒泡的过程就如下图所示：<br><img src="/medias/article/coding/event/event-bubbling.jpg" alt="事件冒泡流"></p><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><blockquote><p>事件由最不具体（嵌套层次最外层）的元素最先接收，逐级向下传播，直到事件的目标元素为止。</p></blockquote><p>事件捕获的用意在于：在事件到达目标元素前捕获（拦截）它。上面的例子，事件捕获的过程就如下图所示：</p><p><img src="/medias/article/coding/event/event-capturing.jpg" alt="事件捕获流"></p><p><strong>“DOM2级事件”规范要求：事件捕获的起始对象和事件冒泡的终止对象为<code>document</code>对象，但大部分浏览器都把这一对象设置为<code>window</code>。</strong></p><h4 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h4><blockquote><p>“DOM2级事件”规定的事件流包括三个阶段：<code>事件捕获阶段、处于目标阶段、事件冒泡阶段</code>。</p></blockquote><p>所以上面的例子在“DOM2级事件流”规范中，事件触发的事件流就变成了这样：</p><p><img src="/medias/article/coding/event/dom-event-flow.jpg" alt="DOM事件流"></p><p><strong>这里有一些值得注意的地方：</strong></p><ol><li>“事件捕获阶段”到事件的目标元素紧邻的父级元素（上面的例子中就是到第<strong>⑤</strong>步div#parent元素）就结束了，之后事件流进入“处于目标元素阶段”，目标元素的事件被触发。</li><li>目标元素的事件处理（也就是执行事件处理程序）又被看成是“冒泡阶段”的一部分。这也就是为什么上面的图中阶段<strong>⑥</strong>会显示在事件冒泡阶段这一侧的原因。</li><li>之后，事件流进入事件“冒泡阶段”。</li></ol><p>尽管“DOM2级事件”规范要求：捕获阶段不会触发目标元素的事件，但大部分浏览器都会在捕获阶段也触发目标元素的事件。这样，主流浏览器的DOM事件流就变成了这样：</p><p><img src="/medias/article/coding/event/dom-event-flow-browser.jpg" alt="主流浏览器中的DOM事件流"></p><p>这样的事件流，就导致一个结果：<strong>在“事件捕获阶段”和“事件冒泡阶段”都可以对目标元素的事件进行处理。</strong></p><p>我们不仅需要了解元素的事件以什么顺序触发，何时出发，更重要的是，当元素的事件被触发时，我们经常需要做点什么，这就是我们下来要讲的事件处理程序。</p><h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><blockquote><p>当某事件发生时，响应事件的函数就叫做事件处理程序（或事件侦听器）。——《JavaScript高级程序设计》</p></blockquote><p>通俗地说，事件处理程序就是事件发生时我们响应事件对应要执行的JS代码。</p><p>事件处理程序名由 “on”+事件名组成。如：onclick，onload…</p><p>那如何为一个元素指定（定义/注册）事件处理程序呢？有三种方式：</p><ol><li>HTML事件处理程序（行内式）</li><li>DOM0级事件处理程序</li><li>DOM2级事件处理程序</li></ol><p>下面，我们对这三种方式的核心与值得注意的地方做以说明。</p><h4 id="HTML事件处理程序（行内式）"><a href="#HTML事件处理程序（行内式）" class="headerlink" title="HTML事件处理程序（行内式）"></a>HTML事件处理程序（行内式）</h4><blockquote><p>所有元素支持的事件都可以用与事件处理程序名相同的HTML属性来指定，属性值就是需要执行的JS代码。</p></blockquote><p>如：</p><pre><code>&lt;button onclick=&quot;alert(&#39;你好！&#39;)&quot;&gt;&lt;/button&gt;</code></pre><p>当事件处理程序的逻辑比较复杂，代码较多时，可以将代码定义成一个函数，将属性值赋值为<code>函数的调用</code>。</p><p>如：</p><pre><code>&lt;button onclick=&quot;sayHello()&quot;&gt;&lt;/button&gt;&lt;script&gt;  function sayHello() {    alert(&#39;你好！&#39;);  }&lt;/script&gt;</code></pre><p><strong>以这种方式指定事件处理程序值得注意的是：</strong></p><ol><li>函数是运行在元素的作用域中的，所以函数中的this指向绑定该事件的元素本身。</li><li>事件处理程序中的代码执行时，有权访问全局作用域中的任何代码。</li></ol><p><strong>这种方法也存在问题和局限性：</strong></p><ol><li>时差问题。当绑定事件的元素渲染到页面上时，其对应的事件处理程序脚本可能还未加载，此时触发事件，可能会导致出错。</li><li>HTML和JS脚本紧密耦合，不方便维护。</li></ol><p>正是存在以上原因，许多开发人员摒弃了这一方法，转而使用JavaScript的方式来定义事件处理程序。</p><h4 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h4><blockquote><p>将一个函数赋值给目标元素对象的事件处理程序属性。——《JavaScript高级程序设计》</p></blockquote><p>通俗地讲，我们获取一个DOM元素的引用（DOM对象），该对象具有一个和事件处理程序名相同的属性（或者叫方法）。将要执行的事件处理程序定义成函数，并将函数赋值给这一属性。<br>如：</p><pre><code>let btn = document.getElementById(&quot;btn&quot;); btn.onclick = function(){   alert(&quot;你好！&quot;); }; </code></pre><p><strong>以这种方式指定事件处理程序值得注意的是：</strong></p><ol><li>函数运行在元素的作用域中，所以函数中的this指向绑定该事件的元素。（上面的例子中，this指向#btn元素）</li><li>该方法指定的事件处理程序是在<code>事件冒泡阶段</code>被调用执行的。</li><li>DOM0级方式不能为同一元素指定多个事件处理程序，如果为同一元素指定了多个事件处理程序，触发事件只会执行最后一次指定的事件处理程序，因为后指定的事件处理程序会覆盖前面指定的。</li></ol><p>如果要移除以DOM0级事件处理程序方式指定的事件，将元素对象的事件属性值置为<code>null</code>即可。如：</p><pre><code>btn.onclick = null;</code></pre><h4 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h4><blockquote><p>“DOM2级事件”中，用addEventListener()方法和 removeEventListener()方法来为DOM元素注册和移除事件处理程序。</p></blockquote><p>这两个方法都接受三个参数，依次是：</p><ol><li>事件名。（String，如：’click’…）</li><li>事件处理函数。（Funtion）</li><li>是否在事件捕获阶段触发调用。（Boolean，true——捕获阶段执行，false——（默认值）冒泡阶段执行）</li></ol><p>下面是一个简单的例子：</p><pre><code>let btn = document.getElementById(&quot;myBtn&quot;);// 注意，第二个参数为事件名&quot;click&quot;，没有&quot;on&quot;btn.addEventListener(&quot;click&quot;, function(){  alert(&#39;你好！&#39;);}, false);// false表示事件在冒泡阶段被触发。</code></pre><p><strong>以这种方式指定事件处理程序值得注意的是：</strong></p><ol><li>函数运行在元素的作用域中，所以函数中的this指向绑定该事件的元素。（上面的例子中，this指向#btn元素）</li><li>用addEventListener()添加的事件处理程序<code>必须且只能</code>用removeEventListener()来移除。</li><li>用removeEventListener()移除事件处理程序时，第二个参数事件处理函数，必须是添加时那个事件处理函数的引用。</li></ol><p>对于上述第3点，下面是一个错误的例子：</p><pre><code>let btn = document.getElementById(&quot;myBtn&quot;);btn.addEventListener(&quot;click&quot;, function(){  alert(&#39;你好！&#39;);}, false);.../** * 错误！！！ * 像下面这样移除前面为#btn元素注册的click事件是无效的， * 因为虽然这里的第二个参数与上面添加事件时定义的函数内容相同， * 但是这是两个相互独立的匿名函数，并不是同一个函数的引用。 **/btn.removeEventListener(&quot;click&quot;, function(){  alert(&#39;你好！&#39;);}, false); </code></pre><p>正确的移除方法，应该是这样：</p><pre><code>let btn = document.getElementById(&quot;myBtn&quot;);let handler = function(){  alert(&#39;你好！&#39;);};btn.addEventListener(&quot;click&quot;, handler, false);...// 第二个参数handler是对同一事件处理函数的引用，有效！btn.removeEventListener(&quot;click&quot;, handler, false);</code></pre><p><strong>讲到这里，想来说说DOM0级和DOM2级事件处理程序之间存在的一些差别：</strong></p><ol><li>DOM0级方式，不能为同一元素指定多个事件处理程序，DOM2级可以指定多个。</li><li>如果采用DOM0级方式为同一元素指定了多个事件处理程序，触发事件只会执行最后一次指定的事件处理程序，因为后面指定的事件处理程序会覆盖前面指定的。</li><li>DOM2级方式指定的多个事件处理程序，事件触发时会按照其添加的顺序依次执行。</li></ol><p>最后，我们来讲讲让很多前端开发者都头疼的IE浏览器 —— IE浏览器中的事件处理程序</p><h4 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h4><blockquote><p>IE 实现了与 DOM 中类似的两个方法：attachEvent()和 detachEvent()来为元素添加和移除事件处理程序。</p></blockquote><p>这两个方法都接受两个参数，依次是：</p><ol><li>事件处理程序名。（String，如：’onclick’…，这和DOM2级不同！！！）</li><li>事件处理函数。（Funtion）</li></ol><p>上面的例子，在IE中代码如下：</p><pre><code>let btn = document.getElementById(&quot;btn&quot;); // 注意！！！这里第一个参数和DOM2级不同！！！为&quot;onclick&quot;,DOM2为&quot;clcik&quot;btn.attachEvent(&quot;onclick&quot;, function(){   alert(&quot;你好！&quot;); }); </code></pre><p><strong>IE事件处理程序中值得注意的是：</strong></p><ol><li>由于 IE8 及更早版本只支持事件冒泡，所以通过attachEvent()添加的事件处理程序都会被添加到<code>事件冒泡阶段</code>。</li><li>通过attachEvent()添加的事件处理程序<code>运行在全局作用域</code>（而不像DOM0级和DOM2级那样运行在元素作用域）。所以，函数中this指向<code>window</code>对象。</li><li>与 addEventListener()类似，attachEvent()方法也可以为同一个元素添加多个事件处理程序。</li><li>但是，attachEvent()方法添加的多个事件处理程序，事件触发时会按照与添加顺序相反的顺序来执行。</li><li>与removeEventListener()类似，用detachEvent()移除事件处理程序，第二个参数——事件处理函数，必须是添加时那个事件处理函数的引用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如果没有2018</title>
      <link href="/2018/12/31/if-there-is-no-2018/"/>
      <url>/2018/12/31/if-there-is-no-2018/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有人说，2018是告别的一年，说着江湖已远，说着时代落幕……也有人说，2018年是启航的一年，说着见证历史，说着荣光与梦……可如果没有2018，我们的生活又将会怎样？</p></blockquote><p><img src="/medias/article/journal/2019.png" alt="2019新年快乐"></p><h3 id="如果没有2018"><a href="#如果没有2018" class="headerlink" title="如果没有2018"></a>如果没有2018</h3><p><strong>如果没有2018，我们应该会少涨很多“姿势”。</strong></p><p>如果没有2018，我们不会知道原来“<code>蓝月亮</code>”不仅仅是洗衣液，还是夜空中的一轮明月；我们不会知道就算“<code>卡路里</code>”被注入灵魂，也依旧逃不过“<code>来了，老弟！</code>”的“<code>真香</code>”定律；我们没想到一只“<code>爱旅行的青蛙</code>”会让我们朝思暮想，夜夜盼“蛙”归；我们更没想到的是别人<code>“逃掉”的税款</code>，就有可能是你几辈子都挣不来的“天文数字”。</p><p>2018年，我们知道原来“<code>佛系</code>”不是大学的院系，但我们中的很多人却都是“佛系”的高材生；我们知道原来“<code>山竹</code>”不仅味道酸甜可口，而且还威力无穷；我们无数次“<code>确认过眼神</code>”，遇到各种各样的人，却总是没有“<code>遇见对的人</code>”；不再相信“我们”的誓言，同时又被“<code>官宣</code>”惊得措手不及；我们知道了不仅<code>烤面筋</code>又麻又辣，“中暑”、“忧郁”的<code>竹鼠</code>烤起来也是又香又脆。</p><p><strong>如果没有2018，我们应该会少了很多自豪。</strong></p><p>当苏炳添<code>亚运百米夺冠</code>，我们自豪于黄种人同样可以打破短跑世界纪录，同样可以被称作“飞人”。当武大靖平昌冬奥会冲过<code>500米短道速滑</code>的终点，我们热血沸腾，中国人同样可以在冬奥会赛场上“更高、更快、更强”，而真正的强者从来不需要在背地里为对手使绊子。</p><p>我们自豪于大型水陆两栖大飞机“<code>鲲龙号</code>”成功首飞，我们自豪于“<code>天眼FAST</code>”让我们听到宇宙的心跳声，我们自豪于<code>港珠澳大桥</code>在蔚蓝的海面上气贯长虹，同样自豪于它接受了16及超强台风“<code>山竹</code>”的亲自验收。我们自豪于“<code>嫦娥4号</code>”成功奔月，自豪于世界第一张<code>高清月背图</code>由中国制造，更自豪于“<code>玉兔号</code>”的月背旅行，从此月球的背面不再神秘。</p><p>当<code>华为</code>引领<code>5G时代</code>，当孟晚舟无理由被捕，我们自豪于华为的伟大，我们更知道“<code>伟大的背后都是苦难”</code>。当<code>外交部天团</code>霸气回应各方记者提问，我们自豪于自己的背后有这样一个强大的祖国。</p><p><strong>如果没有2018，我们应该会晚几年见证一些历史性的时刻。</strong></p><p>当韩朝领导人在板门店进行那历史性的握手时，总给人一种似曾相识的感觉；当跨过“三八线”的那一刻，这是两个人的一小步，却是人类的一大步；当韩朝双方运动员共举半岛旗帜歩入平昌冬奥会会场时，我们知道半岛和平迎来了新希望。让人不由得感慨：<code>柏林墙倒了，三八线模糊了，何时在外的“游子”那心中沉甸甸的思念能跨越那一湾浅浅的海峡？</code></p><p><strong>如果没有2018，我们应该会少一些告别和缅怀。</strong></p><p>9月，注定是中国文艺界最悲痛的一个月。常宝华、常贵田、刘文步、张文霞、师胜杰等相声大师相继离世，今后，我们也只能在录影录像中感受他们的风采，感受他们带来的欢笑和相声的魅力。</p><p>10月，李咏走了，走得那么突然，那么悄无声息。就像咏哥曾经在节目演讲《生命中的最后一天》里说的：“<code>我会找一个安静的地方，静静地待着，我不会有道歉，也不会有离别，更不会有抱怨，我只会有感谢......所有电视机前的观众朋友们，感谢你们给我留下了美好的回忆</code>”。当哈文“永失我爱”之时，我能看到照片中咏哥眼眶里那一滴平静而又不舍的泪。</p><p>第二天，金庸先生驾鹤仙逝，带走了无数人的江湖梦，更甚至带走了一个时代。江湖之梦杳不灭，侠影远去侠气长存，从此，我们只能在“<code>飞雪连天射白鹿，笑书神侠倚碧鸳</code>”的文字中领悟江湖侠义，继续我们儿时就有的江湖梦。</p><p>也许是上天想听曲了，臧天朔、盛中国老师去了；想看小说了，二月河老师去了；想听评书了，单田芳老师去了，想看剧了，蓝洁瑛、计春华老师也去了……</p><p>2018年，好像世界也是悲痛的。3月，霍金逝世，世界失去了一位伟大的理论物理学家。那浩瀚无垠的宇宙、“深不见底”的黑洞好像变得更加神秘莫测。11月，“漫威之父” —— 斯坦·李去世。漫威迷哭了，比告别“狼叔”的时候哭得还伤心，“超级英雄”流泪了，比灭霸完成“梦想”的时候还要绝望。而我们，再也看不到那个爱客串的老爷爷惊喜般地出现在荧幕的任何一个角落。<code>我在想，在平行宇宙里，还会有一个老先生微笑着出现在各种超级英雄的身边么？</code></p><p>2018年，我们体会了因爱而痛，我们学会了挥手告别。但我们告别的岂止是某些人，我们更像是告别了一个时代……</p><p><strong>如果没有2018，我们应该会少一些悲痛。</strong></p><p>当听闻米脂三中校门口，花季的学生被丧心病狂的歹徒袭击造成9死19伤时，我们怒发冲冠，愤恨不已。但当无偿献血的队伍排成长龙，人山人海之时，我们又体会到什么是人间大爱。<code>愿离开这个世界的孩子都能化作天上最亮的一颗星，愿破碎的家庭能够早日走出悲痛，拥抱新的生活</code>。</p><p>当听闻普吉岛游船倾覆致47人遇难时，在心生悲痛之余依旧警醒着我们<code>诗和远方固然美丽，但依存在看不见的危险</code>。</p><p>当听闻重庆万州公交坠江后，我们默默祈祷，救援人员全力以赴。当我们知道车内15人无一生还时，心中更是悲痛难忍！当看到视频发布的那一刻，痛心疾首，那种惊恐绝望的呼喊声，足矣刺痛每个人的心。那种求生的歇斯底里的呼喊，那种对死亡的恐惧，足矣唤醒那些麻木不仁的、自以为是的、丑恶的灵魂！当真相水落石出之后，我们更加惊讶于因为短短的一站路，会让无情的江水吞没15条鲜活的生命。多少事故的发生，多少无辜生命的离去，就是因为一些人对于生命缺乏发自内心的敬畏。我依旧想提醒刘某：<code>一场无谓的纷争，拉十几人“陪葬”，不论你今生如何，也无论你来世在哪，都别忘了那呼喊和呻吟在冰冷的江水下的无辜的冤魂。</code></p><p>不要停留于愤怒，痛定思痛，为何乘客与司机互殴何以一再出现？如果司机能合理处理纠纷，停止互殴，如果其他乘客能上前阻止，如果所有人能对生命多一些敬畏，是否就能减少甚至避免此类悲剧的发生。无彻底反思就无真正救赎，同样，不形成制度正义，类似悲剧便难断绝。</p><p><strong>如果没有2018，我们应该会少一些愤怒。</strong></p><p>我们愤怒于<code>网约车</code>女乘客屡遭侵害。花季的生命被“兽性大发”的禽兽侮辱杀害，这不禁让人感叹：<code>地狱空荡荡，魔鬼在人间</code>。人们胸中的怒火难以熄灭，就像某位知名演员所说:“<code>删了也不会变好...对吧？</code>”。网约车公司审查规则不严格，监管力度不彻底，应急措施不完善，响应制度不灵活就是导致这类恶心事件发生的主要原因。同样，法律法规制定层面恐怕同样也难辞其咎。</p><p>我们愤怒于<code>高铁霸座事件</code>屡次发生。第一次的“我站不起来，你帮我呗”，就好似给那些不知羞耻的老赖们做了一个很好的“榜样”，这些人一次次刷新我们的价值观，我们不禁冷笑：<code>世界上竟会有如此厚颜无耻之人！</code>此类现象频发固然与无赖的素质低有关，恐怕也与执法者的弱势、旁观者的冷漠有很大关系。</p><p>我们愤怒于<code>毒疫苗</code>的危害。小时候，每次打完疫苗，就像美国队长注射了“超级强化药剂”一样，总觉得自己拥有了超能力，成了世间最强壮的人。可在2018年7月份，长春长生生物科技有限公司却“告诉”我们，接种的疫苗是假的，是“有毒”的，一时间全国哗然，甚至有些恐慌。虽然最终真相结果水落石出，相关人员受到处理，但是，一个视生命为儿戏，对生命缺乏起码的尊重和敬畏的公司，就永远要收到人们和社会的谴责 —— “曾经曾鼓起那么大的勇气，你特么告诉我这是无效的？”、“不搞你，对不起罪过的花朵”。百年大计，育人为本，可当孩子们的健康都被扼杀在摇篮里时，又何谈少年强则国强？</p><h3 id="凡是过去，皆为序章"><a href="#凡是过去，皆为序章" class="headerlink" title="凡是过去，皆为序章"></a>凡是过去，皆为序章</h3><p>平淡的生活，依然会有真善美，为我们的前行送来温暖。猝不及防的痛与哀，也是促进我们更上一层楼的决心。<code>凡是过去，皆为序章</code>，如果没有2018，又哪来的2019……新的开始，总会有新的期待。</p><p>在告别2018，迎来2019的时刻，也许你还在加班，丝毫没有辞旧迎新的激动；也许你还在四处奔波，为能过一个美满的农历新年在努力打拼；也许你还还在自习室里奋笔疾书，挑灯夜读；也许你仍驻守在祖国边疆，负重前行……</p><p>而此时，无论你身在何方，在做什么，祝愿你新的一年不用转发“锦鲤”也同样幸运满满，依旧有实现梦想的信心。祝你不用沉迷于虚幻，依旧能得到内心的慰藉。祝你在奋斗的道路上，遇到志同道合的人。祝你在孤单的旅途中，遇到那个对的人……</p><p>2019，愿所有人被世界温柔以待！愿你的世界，春暖花开！</p><p>2019，愿人间充满阳光，愿世界和平！</p><hr><p><center>2018年度热点图鉴</center><br><img src="/medias/article/journal/2018-summary.jpg" alt="2018年度热点图鉴"></p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>过去 “ 狗血 ” 的三个月</title>
      <link href="/2018/12/27/the-past-three-months/"/>
      <url>/2018/12/27/the-past-three-months/</url>
      
        <content type="html"><![CDATA[<blockquote><p>更新这篇文章前，看了看上一篇文章发布的日期是今年9月底，已经有三个月没有更新个人博客了。说起来实在惭愧，当初开始写博客就是为了记录生活中一些值得反思回味的事情，让自己学会思考，而过去的三个月却没做到这一点。现在想想过去三个月的工作生活，能回味（tù cáo）的事情还真不少……</p></blockquote><p>如果要用一个词来概括过去三个月的话，我唯一能想到的就是 —— 狗血……</p><h3 id="加班，加班，加班！"><a href="#加班，加班，加班！" class="headerlink" title="加班，加班，加班！"></a>加班，加班，加班！</h3><p>公司从9月份开始强制995（朝九晚九，一周五天）加班，虽不合规矩，但在大环境下，对于一个IT公司来说也在情理之中，也没人计较什么。毕竟像公司这样一年少有几个月加班，平时18:30公司就没人了的IT公司来说，我们算身在福中了。而且，加班期间公司管晚饭，虽然提供的饭菜不怎么好吃…..</p><p>可为什么我们却“身在福中去不知福”呢？</p><ol><li>我想不明白的是，为什么一个公司在绝大多数人没有多少活干，白天慢慢悠悠都能完成现有工作的情况下，要强制要求所有人995加班？</li><li>9月份，在开发任务依旧很轻松的情况下毫无意义地强制加班，导致的结果就是，到10月份任务繁重的时候，反而没有人愿意认真工作，因为已经被前一个月“折磨”皮了。</li><li>粗略计算，加班期间晚饭花费一个月在20000元左右。在目前开发的系统一片混乱，bug无数，更谈不上性能的前提下，为什么不花这些钱去招聘一两个大神来带着我们carry全场？</li><li>不愿意花钱，请不来大神，这就是公司几乎无限制招聘实习生的原因？新人刚开始实习，需要老员工指导，这并不是件“顺便、顺手”就办的事，反而拖慢了现有的工作效率。曾经还有实习生连续两天把系统后台搞崩的事情，导致整个团队连续两个早上没法正常开发。图什么？我不懂…..</li><li>总有一些脑子没有进化完全的“低级领导”喜欢出风头，喜欢装13，喜欢在“高级领导”面前找存在感，给项目埋下多少坑，自己却从来不填，让下面的人背锅……我喜欢称这些领导为“狗头领导”。</li></ol><p>当我得知，“高级领导”强制995加班是因为他的同事一句“你们部门每天下班那么早，哪有IT公司的样子”的时候，我只能叹一口气，“唉……‘高级领导’也不都是脑子好使的主，‘吃枣药丸’！”</p><p>加班给领导看，是我最厌恶的加班情况，没有之一。而且，在“高级领导”知道全团队长期加班并没有什么工作效率，没多少工作产出的情况下，居然依旧看得津津有味。只要自己的一线“码农”晚上待在公司，他就心满意足，自诩团队积极向上，充满活力，终于像自己同事所说的“像个IT公司的样子”了。</p><p>于是，在这种“高级狗头领导”的带领下，我过去三个多月的生活就成了：起床 → 上班 → 加班 → 下班 → 失眠 → 睡觉 → 起床……一个机器一般的“狗血”的循环。那段时间我觉得自己不应该是一个“码农”，称为“码畜”更合适。而这其中，长期的失眠，严重影响了身体的健康状况……</p><h3 id="苦尽“甘”来"><a href="#苦尽“甘”来" class="headerlink" title="苦尽“甘”来"></a>苦尽“甘”来</h3><p>12月14号，终于，持续了三个半月的995宣布结束了！晚上，公司在一位前同事参股的酒吧餐厅搞了一个party，算是补偿之前没办的“年中聚会”，更重要的是犒劳一下大家过去几个月的辛苦。虽然按照公司的“惯例”，平均下来每个人也花不了几个钱，但还好算是对过去三个多月苦日子的一些“慰藉”。用“高级领导”的话说“中国人喜欢在重要的有意义的节点上，以聚会宴席的形式宣布确认一下”。</p><p>当晚还算开心，想着苦尽甘来，我喝了不少酒，那种喝起来没感觉后劲儿却很大的酒……顺理成章的我喝醉了，返回途中还飘飘欲仙，有种李白“斗酒诗百篇”的意思，回到公寓就狂吐不止，真的是把胆汁儿都吐出来的那种。晚上躺在床长，头晕、恶心、腰背酸痛……折腾到凌晨4点多才算入睡。还好，第二天周六，不用上班。</p><p>第二天，由于醉酒，晚上睡觉着凉，出现了感冒的症状，不停地咳嗽，就医后的诊断结果 —— 气管发炎。本以为这够悲催的了，第二天晚上又开始腰酸背痛，同时，我发现自己开始耳鸣，一种尖锐而又细小的蜂鸣声在右耳响起。因为之前偶尔也会出现这种情况，并没有太在意。最后证明我错了，因为这次耳鸣“前所未有”，几乎24小时“陪伴”我，一直持续到了现在，而且预计还会持续……白天并不明显，但一到晚上就很“活跃”。</p><p>引起耳鸣的原因有很多，主要分为听觉系统疾病和全身性疾病两种。包括中耳炎，耵聍栓塞，长期精神压力过大、睡眠不足，颈椎腰椎疾病，甚至酗酒感冒也会引起耳鸣。而这些，很多种在我身上都有出现，自己也不太确定什么原因所致。</p><p>因为影响到睡眠，加上我了解到长期耳鸣会严重影响听力，所以预约了医生，最快需要等到明年1月2号。这意味着我需要和这次耳鸣至少再“相处”一个星期，也就是说，这“伙计”还会陪我走完2018，一起“跨年”……希望到时候能尽快告别这位“前所未有”的朋友。</p><blockquote><p>所以，还是想告诫所有朋友，任何时候，身体健康永远排在首位。也许你的生活中存在各种各样的压力，要求你不得不“拼命”。请相信我，没有那么紧迫，或者说还有更好的解决方法，但绝不是以劳累拼命、牺牲健康为代价。<br><br>我们总说“愿身边的人被世界温柔以待”，但请先善待自己，不要用贫穷和压力去修饰你的拼命与熬夜。<code>穷尽健康，你将一无所有。</code></p></blockquote><h3 id="一件乐事"><a href="#一件乐事" class="headerlink" title="一件乐事"></a>一件乐事</h3><p>过去三个月的生活也并不是日日都如此，也有一件乐事。11月中旬的时候，我请了一次工作以来最长的假 —— 3天。加上周六周日，凑够五天，忙里偷闲，完成了我自初中毕业以来的一个愿望 —— 云南之旅。这是一段很有趣、很美好的经历，赏过很多美景，遇到很多有趣的人，也改变了我对旅游的认识，重新定义了旅游的意义，是过去三个月唯一美好的回忆。写在这里实在有些辜负，后面会单独更新博客文章，与大家分享这次奇妙之旅。</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活工作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>倒影</title>
      <link href="/2018/09/29/gallery-1/"/>
      <url>/2018/09/29/gallery-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>几月前，于微博中见一题为——<code>“摄影师眼里雨后的世界”</code>的博文，摄影师将镜头倒转，在雨后的一汪小水潭中捕捉到一个美丽的<code>“镜像世界”</code>，幽蓝的夜色下，车水马龙、灯火阑珊的街头，却给人一种平静祥和来自现实的梦幻般的美，观之实为惊叹。</p></blockquote><p><img id="sina-blog" src="/medias/galleries/reflection/sina-blog.jpg" alt="摄影师眼里雨后的世界”引用博文(侵删)"></p><div class="gallery-tip-ceter">“摄影师眼里雨后的世界”引用博文(侵删)</div><p><img id="sina-blog-img" src="/medias/galleries/reflection/sina-blog-img.jpg" alt="摄影师眼里雨后的世界”视频截图(侵删)"></p><div class="gallery-tip-ceter">“摄影师眼里雨后的世界”视频截图(侵删)</div><blockquote><p>个人同样爱好摄影，但并不专业，平日里自己琢磨，纯属“自娱自乐”。看到这一博文，从此便迷上这个角度，闲暇之时幸遇一些相似的景致，用手机记录下一个个瞬间，便有了这<code>《倒影》</code>影集。若有专业人士不吝赐教，也欢迎点评指正。</p></blockquote><p><img src="/medias/galleries/reflection/20180920_193227.jpg" alt="2018.09.20-摄于西安市高新区"></p><div class="gallery-tip-ceter">2018.09.20-摄于西安市高新区</div><p><img src="/medias/galleries/reflection/20180920_193229.jpg" alt="2018.09.20-摄于西安市高新区"></p><div class="gallery-tip-ceter">2018.09.20-摄于西安市高新区</div><p><img src="/medias/galleries/reflection/20180920_193340.jpg" alt="2018.09.20-摄于西安市高新区"></p><div class="gallery-tip-ceter">2018.09.20-摄于西安市高新区</div><p><img src="/medias/galleries/reflection/20180919_184602.jpg" alt="2018.09.19-摄于西安市高新区"></p><div class="gallery-tip-ceter">2018.09.19-摄于西安市高新区</div><p><img src="/medias/galleries/reflection/20180905_191759.jpg" alt="2018.09.05-摄于西安市高新区"></p><div class="gallery-tip-ceter">2018.09.05-摄于西安市高新区</div><p><img src="/medias/galleries/reflection/20180704_211340.jpg" alt="2018.07.04-摄于西安市高新区"></p><div class="gallery-tip-ceter">2018.07.04-摄于西安市高新区</div><p><img src="/medias/galleries/reflection/20180626_191742.jpg" alt="2018.06.26-摄于西安市高新区"></p><div class="gallery-tip-ceter">2018.06.26-摄于西安市高新区</div><style>  #galleryContent img#sina-blog-img,  #galleryContent img#sina-blog {    width: auto;  }</style>]]></content>
      
      
      <categories>
          
          <category> 影集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随拍(影集) </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>长安城里的夜</title>
      <link href="/2018/09/18/the-night-scence-of-chang-An-city/"/>
      <url>/2018/09/18/the-night-scence-of-chang-An-city/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>本文写于我大四实习期间，2017年7月2日，周日凌晨。那时我还住在学校，平时坐车上下班。7月1日加班至近午夜零点，下班后于街上漫步，幸遇些许人物场景，心生感慨，遂记之。</p></blockquote><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>昨日加班，下班时已近午夜，身心有些疲惫。心想，晚了便晚了罢，那便沿街走走，好好看看这头顶城市的夜，毕竟深夜的景，深夜的静，不是匆忙的白日里所能求得的。单肩背着书包，拖着沉重的双腿，迈着缓缓的步子，独自一人走在深夜的街道上，偶尔哼唱几段旋律，添添几分乐趣。</p><p>此时的西安城，不再灯火辉煌，温热的风，昏暗的灯，迷离的霓虹，摇曳的树影……路上不见了公交车的踪影，一眼望去街上的行人屈指可数，时不时有几辆私家车或出租车从身边驶过，此时才发觉原本熟悉的西安城却有着如此的神秘。</p><a id="more"></a><p>走了一段路程，突然发现前面不远处有一位交警，看样子是在夜里执勤，还真是辛苦。他也看见了我，向我走过来说道：“小伙子，这么晚了，还在外面？”我怔了一下，答道：“是啊，加班，准备回去了。”他沉默了一会儿，笑了笑说：“这么晚，男生也要注意安全，快回去吧。”我回道：“嗯，谢谢！”这个夜晚，安静祥和，我相信每个夜晚都会是这样，因为总有许多像这位警察一样的卫士守护着这座城市的安宁。</p><p>走在深夜的街道上，吹着微热的晚风，哼唱着熟悉的旋律，路过高新路的街道，远远的便有声声笑声入耳。前面，几位建筑工人在路边行道上一起吃着西瓜，看着很是悠闲。其中，有人席地而坐，有的慵懒的站着，看上去好不惬意。路过他们身边，听得一人说道：“唉…把他家的，忙活了一天，终于歇下了……”听完这一句，也便已远离他们的位置，只有身后慢慢远去的笑声还回荡在耳边。一天的忙碌，方得这美好的深夜，一口多汁的西瓜，便可忘去整日的烦恼和劳累。此时的夜，陪着他们，一起感受西瓜的香甜……</p><p>未走多远，同一条街边，看到一位四五十岁的阿姨她在路边的一棵树下整理着什么。仔细一看，才发现她在整理一些废旧的纸箱。昏暗的光线，想着也许并不能看得清楚，一个个纸箱却被她用心地拆开，依照棱角慢慢压平，再堆放在身边。走近，她便问道：“你好，这会儿几点了？”她的语气很是温和。我掏出手机，很遗憾的是没电了。“不好意思，我的手机没电了”，我一边答道一遍举起手机示意。想着从公司离开的时间，估算了一下， “大概快一点了吧”，我补充道。她回道：“谢谢！”我笑着说：“不客气。”离开的时候，那位阿姨还在仔细的整理着那些纸箱，她心里也想早点回到家里吧，毕竟这深夜里，独自一人还是会觉得有些许的孤独。</p><p>就这样，哼着《十点半的地铁》，继续我回学校的路。走到南二环，在医学院附近，转过弯看到一个路边摊，想起还未吃晚饭，便想着填填肚子。走近摊位发现老板坐在低矮的凳子上，吃着一碗像是已经变凉的馄饨。“老板也才吃晚饭啊！”我走上前说道。他抬起头，看着我笑了笑，站了起来，此时才发现，老板是一位看起来五六十岁的大叔。“还有吃的么，老板？”我带着期待的眼神看着他。“有！”老板爽快的回道。“都有什么吃的啊？”我追问到。“馄饨、包子、米线，都有”。我甚是欣喜，在子夜还能吃到路边摊，其实也是不容易了。“来一碗馄饨吧”我说道，“好嘞！”老板开始了忙碌。</p><p>坐在那矮矮的凳子上，顿时觉得惬意无比，全身的放松，让人想坐着这里，看着夜景，一直到天亮。坐下没多久，一位中年男子走过，蓝黑色的短袖，黑色的裤子，一双拖鞋，头略微扬起，看着天空，看样子也是满脸疲惫。经过摊位前，老板打声招呼:“下班啦？” “嗯，下班了……”中年男子叹息一样地回答道。我心想，这男子和老板应该是老熟人了吧，常常就在这摊位前，这样遇见。慢慢的，男子远离了摊位……在如今，总有人带着一天的酸甜苦辣，在深夜里，仰天长叹。</p><p>没坐一会儿，馄饨登场，皮薄馅大，还未入口，便觉得馋人，一勺鲜汤，便可忘却前面所有的疲倦与劳累。鲜嫩的紫菜，清香的香菜还有点睛之效的榨菜为这看似普通的馄饨注入了灵魂。</p><p>在细细享受这美食之时，一辆出租车停在了路边，司机看起来三十多岁，白色的体恤，棕色的裤子，一双凉皮鞋。未到摊位前便说道：“老板，一碗米线，一笼包子！”“先坐，马上就好！”老板爽快的回应到。司机坐在矮桌前，低着头看着手机，目不转睛，我能看到他时不时扬起嘴角，高兴的心情满满的溢在脸上。也许是看到了什么笑话，才让他在这摊位前暂时地放下一切，也许是今天拉客挣了些钱，可以给孩子买好吃的，也许，家里有喜事也说不定。没多久，一位外卖小哥骑着电动车，一身蓝色的工作服，来到摊位前：“老板，一碗麻辣米线带走。”“好嘞，马上就好！”之后，老板开始了新一轮的忙碌。小哥弯下身子，双臂搭在电动车头上，把头埋进了双臂中。他，应该也很是疲惫吧……忙碌的一天，给别人准时送去美食，自己却只能在这深夜里靠一碗米线填饱肚子。今晚，我们有缘相遇，尽管可能只是擦肩而过，但大家都是“夜归人”……</p><p>吃完馄饨，特意多喝了几口汤，心满意足。“老板，馄饨多少钱？”，“5块…”老板回应道。付钱时，对老板笑道：“馄饨很好吃，谢谢！”老板开心地笑了笑。也许一碗馄饨没有多少利润，但一句肯定，一个微笑，希望在这深夜里给予老板小小的幸福。</p><p>夜很深了，也该早些回学校了。在路边拦下一辆出租车，坐上副驾驶，“师傅，去理工大金花校区”，我一边系安全带一边告知司机我的目的地。司机娴熟的车技，带着我飞驰在深夜的南二环上。看着窗外快速倒退的风景，路边一闪即过的行道树，渐渐的有些困乏,眼睛微闭，靠在座椅上，静静地等待着回到学校。不超半个钟头，到达学校东门，今日的事情，深夜的见闻，即将结束。回到办公室（因下班太晚，宿舍大楼已熄灯闭门，当晚我便在学生会的办公室住了一夜），写下此文，用文字记下这如诗似剧的夜境。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><blockquote><p>在如今，总有人披星戴月地奔波，早出晚归。深夜里，每一位“夜归人”都有属于自己的故事，属于自己酸甜苦辣，这所有的一切，就只为了自己心中那份最简单而又美好的心愿与目标。也许只有在这深夜里，在夜深人静的时候，我们才会静下心来，回味这一天，甚至是回味一路走来的平坦与坎坷。这时候，我们也许会审视自己，看看心灵深处的自己，开心、难过、委屈、思念等等这些情感在这时被不断放大，最终极大化。也许这时再也抑制不住内心的汹涌，迷离过后，流泪过后，我们依旧会怀揣着心里的那份执着、对未来的期许、对远方的思念等等寄托慢慢入睡，期待着明日的第一缕朝阳划破天际。</p></blockquote><p>最后，把我最喜欢的一位歌手——<strong><a href="https://www.baidu.com/link?url=BsltTzlHbDVY83hcXfq3fs1sPLee1fFXhRZperHgpnpGYrvNA1pkm_tIOWp6uwExDNz7hzr-4fK3XXpcLC3cvZElHhODunSKMhXqKqAcjTu&amp;wd=&amp;eqid=a1ae7140000804bc000000035b7167a3" target="_blank" rel="noopener">李健</a></strong>的一首歌曲 <strong><a href="https://baike.baidu.com/item/%E5%BC%82%E4%B9%A1%E4%BA%BA/6402179?fr=aladdin" target="_blank" rel="noopener">《异乡人》</a></strong>分享给大家。这是作为东北黑龙江人的李健当时身处北京时，所作的一首歌曲。在2017年《歌手》节目中对歌词进行新的修改和补充，词曲中对独自在外拼搏的“异乡人”的生活做了细致的描写，也对“异乡人”的孤独、迷茫、无助以及对故乡思念的情感进行了淋漓尽致的表达。</p><div id="content-ctn"><br>  <div class="centerContent"><br>    <strong>异乡人</strong><br>    <strong>作词： 李健</strong><br>    <strong>作曲: 李健</strong><br><br>    披星戴月地奔波<br>    只为一扇窗<br>    当你迷失在路上<br>    能够看见那灯光<br>    不知不觉把他乡<br>    当做了故乡<br>    只是偶尔难过时<br>    不经意遥望远方<br>    曾经的乡音<br>    悄悄地隐藏<br>    说不出的诺言<br>    一直放心上<br>    有许多时候<br>    眼泪就要流<br>    那扇窗是让我<br>    坚强的理由<br>    小小的门口<br>    还有她的温柔<br>    给我温暖陪伴我左右<br>    近在眼前的繁华<br>    多少人着迷<br>    当你走近才发现<br>    远过故乡的距离<br>    不知不觉把他乡<br>    当做了故乡<br>    故乡却已成他乡<br>    偶尔你才敢回望<br>    曾经的坎坷<br>    现 在不用讲<br>    异乡的人有着相同的惆怅<br>    有许多时候<br>    眼泪就要流<br>    那扇窗是让我<br>    坚强的理由<br>    小小的门口<br>    还有她的温柔<br>    给我温暖陪伴我左右<br>    有许多时候<br>    眼泪就要流<br>    那扇窗是让我坚强的理由<br>    就在这时候<br>    眼泪已经流<br>    那扇窗依然明亮为我守候<br>    看过了多少<br>    海市蜃楼<br>    让我回到小小的门口<br>    给我温暖陪伴我左右<br>    给我温暖陪伴我左右<br>  </div><br> </div>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 朝花夕拾 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS层叠上下文、层叠等级、层叠顺序、z-index完全说明</title>
      <link href="/2018/08/28/z-index/"/>
      <url>/2018/08/28/z-index/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近，在项目中遇到一个关于CSS中元素<code>z-index</code>属性的问题，具体问题不太好描述，总结起来就是当给元素和父元素色设置<code>position</code>属性和<code>z-index</code>相关属性后，页面上渲染的元素层级结果和我预想的不一样。根据自己之前的理解，也没找到一个合理的解释。我知道，肯定是我对相关属性的细节理解存在问题，所以结合官方文档和在网上各种搜集整理，明白了其中的原因。写下这篇文章，和大家分享有关CSS中<code>层叠上下文</code>、<code>层叠等级</code>、<code>层叠顺序</code>以及<code>z-index</code>相关的一整套技术细节。</p><p>如果存在什么错误或重要遗漏或者有什么疑问，欢迎留言指正、讨论！感谢！</p><a id="more"></a><h3 id="一个“片面”的理解"><a href="#一个“片面”的理解" class="headerlink" title="一个“片面”的理解"></a>一个“片面”的理解</h3><p>以往，由于自己使用<code>z-index</code>的频率不大，所以对这个CSS属性存在比较片面的认识。一直认为<code>z-index</code>就是用来描述定义一个元素在屏幕<code>Z轴</code>上的堆叠顺序。<code>z-index</code>值越大在<code>Z轴</code>上就越靠上，也就是离屏幕观察者越近。最后才发现这个认识存在很大的问题：</p><ol><li>首先，<code>z-index</code>属性值并不是在任何元素上都有效果。它<strong>仅在</strong>定位元素（定义了<code>position</code>属性，且属性值为非<code>static</code>值的元素）上有效果。</li><li>判断元素在<code>Z轴</code>上的堆叠顺序，不仅仅是直接比较两个元素的<code>z-index</code>值的大小，这个堆叠顺序实际由元素的<strong>层叠上下文</strong>、<strong>层叠等级</strong>共同决定。</li></ol><p><img src="/medias/article/coding/z-index/XYZ.png" alt="屏幕上的XYZ轴"></p><p>要想完全理解一个东西，首先要明白它是什么，也就是它的定义。我们先看看上面提到的<code>层叠上下文</code>、<code>层叠等级</code>、<code>层叠顺序</code>都是什么？定义又太过抽象，后面会再用一个具象的比喻来让你彻底明白它们到底是什么，有什么联系。</p><h3 id="什么是“层叠上下文”"><a href="#什么是“层叠上下文”" class="headerlink" title="什么是“层叠上下文”"></a>什么是“层叠上下文”</h3><p>层叠上下文(stacking context)，是<code>HTML</code>中一个三维的概念。在<code>CSS2.1</code>规范中，每个盒模型的位置是三维的，分别是平面画布上的<code>X轴</code>，<code>Y轴</code>以及表示层叠的<code>Z轴</code>。一般情况下，元素在页面上沿<code>X轴Y轴</code>平铺，我们察觉不到它们在<code>Z轴</code>上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。</p><p>如果一个元素含有层叠上下文，(也就是说它是层叠上下文元素)，我们可以理解为这个元素在<code>Z轴</code>上就“高人一等”，最终表现就是它离屏幕观察者更近。</p><blockquote><p><strong>具象的比喻</strong>：你可以把层叠上下文元素理解为理解为<strong>该元素当了官</strong>，而其他非层叠上下文元素则可以理解为普通群众。凡是“当了官的元素”就比普通元素等级要高，也就是说元素在<code>Z轴</code>上更靠上，更靠近观察者。</p></blockquote><h3 id="什么是“层叠等级”"><a href="#什么是“层叠等级”" class="headerlink" title="什么是“层叠等级”"></a>什么是“层叠等级”</h3><p>那么，层叠等级指的又是什么？层叠等级(stacking level，叫“层叠级别”/“层叠水平”也行)</p><ul><li>在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在<code>Z轴</code>上的上下顺序。</li><li>在其他普通元素中，它描述定义的是这些普通元素在<code>Z轴</code>上的上下顺序。</li></ul><p>说到这，可能很多人疑问了，不论在层叠上下文中还是在普通元素中，层叠等级都表示元素在<code>Z轴</code>上的上下顺序，那就直接说它描述定义了所有元素在<code>Z轴</code>上的上下顺序就OK啊！为什么要分开描述？</p><p>为了说明原因，先举个栗子：</p><blockquote><p><strong>具象的比喻</strong>：我们之前说到，处于层叠上下文中的元素，就像是元素当了官，等级自然比普通元素高。再想象一下，假设一个官员A是个省级领导，他下属有一个秘书a-1，家里有一个保姆a-2。另一个官员B是一个县级领导，他下属有一个秘书b-1，家里有一个保姆b-2。a-1和b-1虽然都是秘书，但是你想一个省级领导的秘书和一个县级领导的秘书之间有可比性么？甚至保姆a-2都要比秘书b-1的等级高得多。谁大谁小，谁高谁低一目了然，所以根本没有比较的意义。只有在A下属的a-1、a-2以及B下属的b-1、b-2中相互比较大小高低才有意义。</p></blockquote><p><strong>再类比回“层叠上下文”和“层叠等级”，就得出一个结论：</strong></p><ol><li>普通元素的层叠等级优先由其所在的层叠上下文决定。</li><li>层叠等级的比较只有在当前层叠上下文元素中才有意义。不同层叠上下文中比较层叠等级是没有意义的。</li></ol><h3 id="如何产生“层叠上下文”"><a href="#如何产生“层叠上下文”" class="headerlink" title="如何产生“层叠上下文”"></a>如何产生“层叠上下文”</h3><p>前面说了那么多，知道了“层叠上下文”和“层叠等级”，其中还有一个最关键的问题：到底如何产生层叠上下文呢？如何让一个元素变成层叠上下文元素呢？</p><p>其实，层叠上下文也基本上是有一些特定的CSS属性创建的，一般有3种方法：</p><ol><li><code>HTML</code>中的根元素<code>&lt;html&gt;&lt;/html&gt;</code>本身j就具有层叠上下文，称为“根层叠上下文”。</li><li>普通元素设置<code>position</code>属性为<strong>非</strong><code>static</code>值并设置<code>z-index</code>属性为具体数值，产生层叠上下文。</li><li>CSS3中的新属性也可以产生层叠上下文。</li></ol><p>至此，终于可以上代码了，我们用代码说话，来验证上面的结论：</p><p><strong>栗子1:</strong><br><strong>有两个div，p.a、p.b被包裹在一个div里，p.c被包裹在另一个盒子里，只为.a、.b、.c设置<code>position</code>和<code>z-index</code>属性</strong></p><pre><code>&lt;style&gt;  div {      position: relative;      width: 100px;      height: 100px;    }    p {      position: absolute;      font-size: 20px;      width: 100px;      height: 100px;    }    .a {      background-color: blue;      z-index: 1;    }    .b {      background-color: green;      z-index: 2;      top: 20px;      left: 20px;    }    .c {      background-color: red;      z-index: 3;      top: -20px;      left: 40px;    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;      &lt;p class=&quot;a&quot;&gt;a&lt;/p&gt;      &lt;p class=&quot;b&quot;&gt;b&lt;/p&gt;    &lt;/div&gt;   &lt;div&gt;      &lt;p class=&quot;c&quot;&gt;c&lt;/p&gt;    &lt;/div&gt;  &lt;/body&gt; </code></pre><p>效果：<br><img src="/medias/article/coding/z-index/xiaoguo1.jpg" alt="效果1"><br>因为p.a、p.b、p.c三个的父元素div都没有设置<code>z-index</code>，所以不会产生层叠上下文，所以.a、.b、.c都处于由<code>&lt;html&gt;&lt;/html&gt;</code>标签产生的“根层叠上下文”中，属于同一个层叠上下文，此时谁的<code>z-index</code>值大，谁在上面。</p><p><strong>栗子2：</strong><br><strong>有两个div，p.a、p.b被包裹在一个div里，p.c被包裹在另一个盒子里，同时为两个div和.a、.b、.c设置<code>position</code>和<code>z-index</code>属性</strong></p><pre><code>&lt;style&gt;  div {    width: 100px;    height: 100px;    position: relative;  }  .box1 {    z-index: 2;  }  .box2 {    z-index: 1;  }  p {    position: absolute;    font-size: 20px;    width: 100px;    height: 100px;  }  .a {    background-color: blue;    z-index: 100;  }  .b {    background-color: green;    top: 20px;    left: 20px;    z-index: 200;  }  .c {    background-color: red;    top: -20px;    left: 40px;    z-index: 9999;  }&lt;/style&gt;&lt;body&gt;  &lt;div class=&quot;box1&quot;&gt;    &lt;p class=&quot;a&quot;&gt;a&lt;/p&gt;    &lt;p class=&quot;b&quot;&gt;b&lt;/p&gt;  &lt;/div&gt;  &lt;div class=&quot;box2&quot;&gt;    &lt;p class=&quot;c&quot;&gt;c&lt;/p&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><p>效果：<br><img src="/medias/article/coding/z-index/xiaoguo2.jpg" alt="效果2"><br>我们发下，虽然<code>p.c</code>元素的<code>z-index</code>值为9999，远大于<code>p.a</code>和<code>p.b</code>的<code>z-index</code>值，但是由于<code>p.a</code>、<code>p.b</code>的父元素<code>div.box1</code>产生的层叠上下文的<code>z-index</code>的值为2，<code>p.c</code>的父元素<code>div.box2</code>所产生的层叠上下文的<code>z-index</code>值为1，所以<code>p.c</code>永远在<code>p.a</code>和<code>p.b</code>下面。</p><p>同时，如果我们只更改<code>p.a</code>和<code>p.b</code>的<code>z-index</code>值，由于这两个元素都在父元素<code>div.box1</code>产生的层叠上下文中，所以，谁的<code>z-index</code>值大，谁在上面。</p><h3 id="什么是“层叠顺序”"><a href="#什么是“层叠顺序”" class="headerlink" title="什么是“层叠顺序”"></a>什么是“层叠顺序”</h3><p>说完“层叠上下文”和“层叠等级”，我们再来说说“层叠顺序”。“层叠顺序”(stacking order)表示元素发生层叠时按照特定的顺序规则在<code>Z轴</code>上垂直显示。<strong>由此可见，前面所说的“层叠上下文”和“层叠等级”是一种概念，而这里的“层叠顺序”是一种规则。</strong></p><p><img src="/medias/article/coding/z-index/stacking-order.jpg" alt="不同属性的元素的层叠顺序"></p><p>在不考虑CSS3的情况下，当元素发生层叠时，层叠顺讯遵循上面途中的规则。<br><strong>这里值得注意的是：</strong></p><ol><li>左上角”层叠上下文<code>background/border</code>“指的是层叠上下文元素的背景和边框。</li><li><code>inline/inline-block</code>元素的层叠顺序要高于<code>block</code>(块级)/<code>float</code>(浮动)元素。</li><li>单纯考虑层叠顺序，<code>z-index: auto</code>和<code>z-index: 0</code>在同一层级，但这两个属性值本身是有根本区别的。</li></ol><blockquote><p>对于上面第2条，为什么<code>inline/inline-block</code>元素的层叠顺序要高于<code>block</code>(块级)/<code>float</code>(浮动)元素？这个大家可以思考一下！<br>其实很简单，像<code>border/background</code>属于装饰元素的属性，浮动和块级元素一般用来页面布局，而网页设计之初最重要的就是文字内容，所以在发生层叠时会优先显示文字内容，保证其不被覆盖。</p></blockquote><h3 id="你要的“套路”"><a href="#你要的“套路”" class="headerlink" title="你要的“套路”"></a>你要的“套路”</h3><p>上面说了那么多，可能你还是有点懵。这么多概念规则，来点最实际的，有没有一个“套路”当遇到元素层叠时，能很清晰地判断出他们谁在上谁在下呢？答案是——肯定有啊！</p><blockquote><p>1、首先先看要比较的两个元素是否处于同一个层叠上下文中：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1如果是，谁的层叠等级大，谁在上面（怎么判断层叠等级大小呢？——看“层叠顺序”图）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2如果两个元素不在统一层叠上下文中，请先比较他们所处的层叠上下文的层叠等级。<br>2、当两个元素层叠等级相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上。</p></blockquote><h3 id="光说不练假把式"><a href="#光说不练假把式" class="headerlink" title="光说不练假把式"></a>光说不练假把式</h3><p>对于技术学习，代码展示是最直观最易懂的方式之一。话不多说，直接上代码，我们通过以下几个“栗子”，来进一步验证掌握上面的结论。</p><p><strong>栗子3：</strong></p><pre><code>&lt;style&gt;  .box1, .box2 {    position: relative;    z-index: auto;  }  .child1 {    width: 200px;    height: 100px;    background: #168bf5;    position: absolute;    top: 0;    left: 0;    z-index: 2;  }  .child2 {    width: 100px;    height: 200px;    background: #32c292;    position: absolute;    top: 0;    left: 0;    z-index: 1;  }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;box1&quot;&gt;    &lt;div class=&quot;child1&quot;&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;box2&quot;&gt;    &lt;div class=&quot;child2&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><p>效果：<br><img src="/medias/article/coding/z-index/xiaoguo3.jpg" alt="效果3"><br><strong>说明：</strong><code>.box1/.box2</code>虽然设置了<code>position: relative</code>，但是<code>z-index: auto</code>的情况下，这两个<code>div</code>还是普通元素，并没有产生层叠上下文。所以，<code>child1/.child2</code>属于<code>&lt;html&gt;&lt;/html&gt;</code>元素的“根层叠上下文”中，此时，<strong>谁的<code>z-index</code>值大，谁在上面</strong>。</p><p><strong>栗子4：</strong></p><p>对于栗子1中的CSS代码，我们只把<code>.box1/.box2</code>的<code>z-index</code>属性值改为<code>数值0</code>，其余不变。</p><pre><code>.box1, .box2 {  position: relative;  z-index: 0;}...</code></pre><p>效果：<br><img src="/medias/article/coding/z-index/xiaoguo4.jpg" alt="效果4"><br><strong>说明：</strong> 此时，我们发现，仅仅修改了<code>.box1/.box2</code>的<code>z-index</code>属性值改为<code>数值0</code>，最终结果完全相反。这时<code>.child2</code>覆盖在了<code>.child1</code>上面。原因是什么呢？很简单：因为设置<code>z-index: 0</code>后，<code>.box1/.box2</code>产生了各自的层叠上下文，这时候要比较<code>.child1/.child2</code>的层叠关系完全由父元素<code>.box1/.box2</code>的层叠关系决定。但是<code>.box1/.box2</code>的<code>z-index</code>值都为<code>0</code>，都是块级元素（所以它们的层叠等级，层叠顺序是相同的），这种情况下，在<code>DOM</code>结构中<strong>后面的覆盖前面的</strong>，所以<code>.child2</code>就在上面。</p><h3 id="CSS3中的属性对层叠上下文的影响"><a href="#CSS3中的属性对层叠上下文的影响" class="headerlink" title="CSS3中的属性对层叠上下文的影响"></a>CSS3中的属性对层叠上下文的影响</h3><p>CSS3中出现了很多新属性，其中一些属性对层叠上下文也产生了很大的影响。如下：</p><ol><li>父元素的display属性值为<code>flex|inline-flex</code>，子元素<code>z-index</code>属性值不为<code>auto</code>的时候，子元素为层叠上下文元素；</li><li>元素的<code>opacity</code>属性值不是<code>1</code>；</li><li>元素的<code>transform</code>属性值不是<code>none</code>；</li><li>元素<code>mix-blend-mode属性值不是</code>normal`；</li><li>元素的<code>filter</code>属性值不是<code>none</code>；</li><li>元素的<code>isolation</code>属性值是<code>isolate</code>；</li><li><code>will-change</code>指定的属性值为上面任意一个；</li><li>元素的<code>-webkit-overflow-scrolling</code>属性值设置为<code>touch</code>。</li></ol><p>CSS3中，元素属性满足以上条件之一，就会产生层叠上下文。我们用第1条来做一个简单的解释说明。</p><p><strong>栗子5：</strong></p><pre><code>&lt;style&gt;  .box {  }  .parent {    width: 200px;    height: 100px;    background: #168bf5;    /* 虽然设置了z-index，但是没有设置position，z-index无效，.parent还是普通元素，没有产生层叠上下文 */    z-index: 1;  }  .child {    width: 100px;    height: 200px;    background: #32d19c;    position: relative;    z-index: -1;  }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;parent&quot;&gt;      parent      &lt;div class=&quot;child&quot;&gt;child&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><p>效果：<br><img src="/medias/article/coding/z-index/xiaoguo5.jpg" alt="效果5"><br><strong>说明：</strong> 我们发现，<code>.child</code>被<code>.parent</code>覆盖了。按照“套路”来分析一下：<br>虽然<code>.parent</code>设置了<code>z-index</code>属性值，但是没有设置<code>position</code>属性，<code>z-index</code>无效，所以没有产生层叠上下文，<code>.parent</code>还是普通的块级元素。此时，在层叠顺序规则中，<code>z-index</code>值小于<code>0</code>的<code>.child</code>会被普通的<code>block</code>块级元素<code>.parent</code>覆盖。</p><p><strong>栗子6</strong></p><p>对于上面的栗子，我们只修改.box的属性，设置display: flex，其余属性和DOM结构不变。</p><pre><code>.box {  display: flex;}</code></pre><p>效果：<br><img src="/medias/article/coding/z-index/xiaoguo6.jpg" alt="效果6"><br><strong>说明：</strong> 当给<code>.box</code>设置<code>display: flex</code>时，<code>.parent</code>就变成层叠上下文元素，根据层叠顺序规则，层叠上下文元素的<code>background/border</code>的层叠等级小于<code>z-index</code>值小于<code>0</code>的元素的层叠等级，所以<code>z-index</code>值为<code>-1</code>的<code>.child</code>在<code>.parent</code>上面。</p><h3 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h3><p>下面的代码，我会把最终页面渲染的结果放在代码之后，有兴趣的“童鞋”可以分析一下，各个元素的层叠等级，最后来确定这些元素哪个在上哪个在下。</p><pre><code>&lt;style&gt;  .parent {    width: 100px;    height: 200px;    background: #168bf5;    position: absolute;    top: 0;    left: 0;    z-index: 0;  }  .child1 {    width: 100px;    height: 200px;    background: #32d19c;    position: absolute;    top: 20px;    left: 20px;    z-index: 1;  }  .child2 {    width: 100px;    height: 200px;    background: #e4c950;    position: absolute;    top: 40px;    left: 40px;    z-index: -1;  }  .child2-1 {    width: 100px;    height: 200px;    background: #e45050;    position: absolute;    top: 60px;    left: 60px;    z-index: 9999;  }  .child2-2 {    width: 100px;    height: 200px;    background: #db68a7;    position: absolute;    top: 80px;    left: 40px;    z-index: -9999;  }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;parent&quot;&gt;    parent    &lt;div class=&quot;child1&quot;&gt;child1&lt;/div&gt;    &lt;div class=&quot;child2&quot;&gt;      child2      &lt;div class=&quot;child2-1&quot;&gt;child2-1&lt;/div&gt;      &lt;div class=&quot;child2-2&quot;&gt;child2-2&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><p>效果：<br><img src="/medias/article/coding/z-index/test.jpg" alt="小测试代码页面渲染结果"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>以上的内容有一部分内容参考了以下两位大神的博客，写的很好，也很清晰，推荐大家看一看，你会对相关知识点掌握的更清晰。</p><blockquote><p><a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">张鑫旭-《深入理解CSS中的层叠上下文和层叠顺序》</a><br><a href="https://blog.csdn.net/weixin_40672882/article/details/81183321" target="_blank" rel="noopener">AMInInsist-《CSS 中的z-index属性》</a></p></blockquote><h3 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h3><p><strong>下面的文章链接是我在学习实践过程中看到的一些觉得比较好的文章，有兴趣霍有需要的朋友可以参考参考，希望可以帮你彻底弄清文章中涉及的这些问题。</strong></p><blockquote><p><a href="http://www.w3help.org/zh-cn/kb/013/" target="_blank" rel="noopener">lijinxieyang-《层叠上下文【stacking context】与层叠顺序【stacking order】》</a><br><a href="http://www.w3help.org/zh-cn/kb/013/" target="_blank" rel="noopener">w3help.org - 《KB013: 分层的显示( Layered presentation )》</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">MDN-《The stacking context》</a><br><a href="https://www.cnblogs.com/chenshanyuanzi/p/7700823.html" target="_blank" rel="noopener">尚-《css之层叠上下文和层叠顺序》</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> z-index </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>愿你拥有“太阳”，亦拥有“繁星”</title>
      <link href="/2018/08/20/random-thoughts-2/"/>
      <url>/2018/08/20/random-thoughts-2/</url>
      
        <content type="html"><![CDATA[<p>近来在网上读到一段话，很是触动。网上标注这段话出自英国著名女作家，2007年诺贝尔文学奖获得者<a href="https://baike.baidu.com/item/%E5%A4%9A%E4%B8%BD%E4%B8%9D%C2%B7%E8%8E%B1%E8%BE%9B/8307879?fromtitle=%E8%8E%B1%E8%BE%9B&amp;fromid=13350458&amp;fr=aladdin" target="_blank" rel="noopener"><strong>多丽丝·莱莘</strong></a>的长篇小说<a href="https://baike.baidu.com/item/%E5%B9%B8%E5%AD%98%E8%80%85%E5%9B%9E%E5%BF%86%E5%BD%95" target="_blank" rel="noopener"><strong>《幸存者回忆录》</strong></a>，我粗略地阅读原著后并未在文中找到这段话，但可以肯定的是这段话确实出自莱莘笔下。进来，计划通读此书，再对以上话语作出最后定论。</p><p><img src="/medias/article/random-thoughts/The-Mcmoirs-of-a-Survivor.jpg" alt="幸存者回忆录"></p><p>不论最终结论肯定与否，最重要的是，这段话的内容，值得每一个读到他的人深思。原文如下所言：</p><a id="more"></a><blockquote><p>做孩子的时候，感到无聊，盼望着长大。长大后，又向往返回童年。<br>我们浪费自己的健康，去赢得个人的财富,<br>然后又浪费自己的财富去重建自己的健康。<br><strong>我们焦虑地憧憬着未来，忘记了眼前的生活，</strong><br><strong>活得既不是为了现在，也不是为了未来。</strong><br><strong>我们活得似乎永远不会死，我们死得好像从来没活过。</strong></p></blockquote><p>文中最后两句话，尤其触动我的内心。私以为，这两句话一针见血地、深刻地总结了很多人的生活方式和生活意义。莱莘，英国人，都说艺术源于生活但高于生活，我倒觉得，文中的话用来描述很多人的生活和生命历程也是再贴切不过了。</p><p>我们拼命地奔波，没日没夜的工作，放弃了休息团聚，忘记了春夏秋冬，看不到世界的“千里丹青”…… 我们苦苦追求，追求心中“向往的生活”。认为这只要现在“拼命”，以后就能过上想要的日子，就不用再“受罪”。我们总觉得来日方长，此时苦点儿没什么，以后“赢了”总有机会享受，好日子还在后头。可到后来，慢慢的，我们发现脖子不好了，腰不好了，胃不好了，血糖高了，血压也高了…… 迫不得已，再用浪费健康换得的为数不多的财富支付昂贵的医药费去重建自己的健康，之后再因为巨额的花销更加“拼命”…… 就这样，一直“乐此不疲”、“义无反顾”地走在这个“死循环”里。<code>我们活得似乎永远不会死</code>。</p><p>到最后回首往昔，这一路走来却艰辛无比，我们反而失去很多，陪家人的时间少了，挚友少了，感情淡了，思考的时间少了，欢声笑语少了，甚至浪费了健康，却未见赢得多少财富，“好日子”似乎依旧遥遥无期。其实，我们忽略了一点，<strong>并非生活没有变好，也不是努力没有意义，真正在于需求与欲望也同样在膨胀，而且远远快于你努力的速度。</strong>于是，我们变得焦虑，焦虑于现在的不如人意，焦虑于将来可能的“不堪”，渐渐地忘记了眼前的生活。这样的生活，<code>活得既不是为了现在，也不是为了未来</code>。直到将要“告别”的时候，一切走到尽头，才恍然发现，我们没留下多少，更没有带走什么，<code>我们死得好像从来没活过</code>。真正的悲哀，莫过于此……</p><p><a href="https://baike.baidu.com/item/%E6%8B%89%E5%AE%BE%E5%BE%B7%E6%8B%89%E7%BA%B3%E7%89%B9%C2%B7%E6%B3%B0%E6%88%88%E5%B0%94/490458?fromtitle=%E6%B3%B0%E6%88%88%E5%B0%94&amp;fromid=189375&amp;fr=aladdin" target="_blank" rel="noopener"><strong>泰戈尔</strong></a>在<a href="https://baike.baidu.com/item/%E9%A3%9E%E9%B8%9F%E9%9B%86/732033?fr=aladdin" target="_blank" rel="noopener"><strong>《飞鸟集》</strong></a>中有一首脍炙人口又富含哲理的诗：</p><blockquote><p><strong>如果你因错过太阳而哭泣，那么你也将失去繁星。</strong></p></blockquote><p>作者在洞察自然的同时用妙笔告诫人们：不要过分悲伤于错过的美好，珍惜眼前。短短二十几言，告诉了我们失与得联系，告诉我们化失望为希望，化悲伤为幸福的方法。而莱莘的文字中，正好描写了“铜币的另一面”——我们不仅错过了“太阳”，我们也失去了“繁星”。</p><p><a href="https://baike.baidu.com/item/%E5%A4%A7%E5%86%B0/349069?fr=aladdin" target="_blank" rel="noopener"><strong>大冰</strong></a>在<a href="https://baike.baidu.com/item/%E4%B9%96%EF%BC%8C%E6%91%B8%E6%91%B8%E5%A4%B4/15817286" target="_blank" rel="noopener"><strong>《乖，摸摸头》</strong></a>如是说 ：</p><blockquote><p><strong>你我都明白，这从来就不是公平的世界。人们起点不同，路径不同，乃至遭遇不同，命运不同。有人认命，有人顺命，有人抗命，有人玩命，希望和失望交错而生，倏尔一生。</strong></p></blockquote><p>短短的一生中，有的人真正意义上获得的只是短暂的欣喜，更多的却是长久的自我煎熬。愿你的生活，与之相反，愿你拥有“太阳”，亦拥有璀璨的“繁星”。</p>]]></content>
      
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读感悟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生命难以承受的“2 ℃&quot;</title>
      <link href="/2018/08/10/journal-2/"/>
      <url>/2018/08/10/journal-2/</url>
      
        <content type="html"><![CDATA[<h3 id="“番茄炒蛋”"><a href="#“番茄炒蛋”" class="headerlink" title="“番茄炒蛋”"></a>“番茄炒蛋”</h3><p>近一个月来的西安城高温持续不下，与阴雨绵绵、凉爽怡人的7月初的差距算得上是天冠地屦，近几日的气温用“烁石流金”形容也是毫无夸张之嫌。在七八月份华南华北甚至全国“一片火热”的形势下，西安的温度也算是遥遥领先。当华南华北高温在地图上连上一片时，西安城的气温很多时候就像冬日那傲然的梅花，真可谓一枝独秀，也算是“雄鸡”中心最瞩目的一点。夏季的西安，在高温预报图上就是一个又红又紫，红得发紫的城市。</p><p>西安所处地理位置典型的温带季风性气候——夏季高温多雨，冬季寒冷干燥。看起来降水充足，但以个人的感受，西安的高温实在是有过之而无不及。下图是2018年8月13日，中央气象台发布的全国高温预报图，说西安“一枝独秀”、红得发紫，真的是名副其实。</p><a id="more"></a><p><img src="/medias/article/journal/temperature-1.jpg" alt="中央气象台2018.08.13 06:00:00全国高温预报图"></p><p>下图是2018.07.14 - 2018.08.12全国高温分布图。每年七八月份，不仅是西安城，全国的气温预报图便成了一片又红又紫的“雄鸡”。网友也调侃着说，全国气温图看起来就像是一盘“番茄炒蛋”。</p><p><img src="/medias/article/journal/temperature-2.jpg" alt="全国近一个月温度分布图"></p><p class="data-resource">以上数据来源，<a href="http://www.nmc.cn/" target="_blank" rel="noopener">中央气象台</a></p><h3 id="最近的地球"><a href="#最近的地球" class="headerlink" title="最近的地球"></a>最近的地球</h3><p>2018年，好像全球都比往年更加“火热”。<strong> <code>地球，好像发烧了，而且，高烧不退...</code> </strong></p><p>今年7月初，多个北非国家也出现热浪，撒哈拉沙漠地区最高气温达到51.3℃。世界气象组织说，这应该是阿尔及利亚可靠的温度记录中的最高值。持续的高温同样袭击了整个欧洲，瑞典、西班牙、葡萄牙、法国、意大利、德国、芬兰等几乎所有欧洲国家都出现了历史上罕见的高温天气。地处东欧的波兰，往年被视为避暑好去处，最近却连续遭遇30℃以上罕见高温，最高气温34℃。</p><blockquote><p><strong><a href="http://www.takefoto.cn/viewnews-1532649.html" target="_blank" rel="noopener">北晚新视觉 - 《欧洲多地持续高温：局地或超47℃ 瑞典最高峰冰川融化4米》</a></strong></p></blockquote><p>此外，就连北极圈内也出现了罕见的超过30℃的高温，冰川融化，甚至严重威胁到北极熊的生存。茫茫无边的北极圈海面上天空阴沉昏暗，让人窒息，冰冷刺骨的海面上飘着一块孤零零的来自极地的冰山，一只北极熊蜷缩在上面睡着了。饥饿、劳累，但对于它来说，比海更广阔的是内心的孤独…</p><p><img src="/medias/article/journal/arctic.jpg" alt="比海更广阔的是内心的孤独"></p><blockquote><p><strong><a href="https://www.thepaper.cn/newsDetail_forward_2322066" target="_blank" rel="noopener">澎湃新闻 - 《四大洲同现极端高温北极圈罕见32℃，北极熊或40年内灭绝》</a></strong><br><strong><a href="https://baijiahao.baidu.com/s?id=1608148193270009243&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">百度百家号新闻 - 《北极圈出现罕见高温，北极熊将消失？》</a></strong></p></blockquote><p><strong><a href="https://www.thepaper.cn/newsDetail_forward_2335388" target="_blank" rel="noopener">这里</a></strong>，有一封来自北极熊的独白信。充满悲伤、孤独和无奈… 人类用了几十年就使几百万年的北极冰川大面积融化… 因饥饿与劳累北极熊溺死在北极冰冷的海水中… 以海豹为主食的北极熊，开始捕食鸟蛋、海豚，甚至撕碎并吃掉自己的孩子… 最后的图文中有一句话<strong><code>“不知道人类还记不记得，北极，Arctic，这个词源自希腊语，意思是 —— 被熊照耀的地方...”</code></strong> 如今的北极，好像也生病了… 而且，无法康复…</p><h3 id="一串数字"><a href="#一串数字" class="headerlink" title="一串数字"></a>一串数字</h3><p>下面这一串数字，访问<strong><a href="http://trillionthtonne.org/" target="_blank" rel="noopener">这里</a></strong>，你可以看到它在飞速增长。<code>6240多亿</code>（截止于2018.08.13，相信以后会越来越多），粗略估计大约每<code>2秒</code>就会增加<code>1000</code>。它代表什么？你所拥有的财富的增长？某个国家GDP总量的增长？地球氧气总量的增长？你可能会有很多猜测… </p><p><img src="/medias/article/journal/carbon.jpg" alt="飞速增长的全球二氧化碳排放总量"></p><p class="data-resource">数据来源，<a href="http://trillionthtonne.org/" target="_blank" rel="noopener">这里</a></p><p>其实，它代表的是<strong> <code>自工业化以来，全球范围内人类在化石燃料使用、水泥制造、土地利用等活动中排放的二氧化碳总量，并且在实时更新</code> </strong>，值得注意的是，该数值的单位是 <strong><code>吨</code></strong>。这就表示，自工业化以来全球目前排放二氧化碳<strong> <code>6240多亿吨</code> </strong>。第一次知道它代表的含义，在看着这飞速增长的数字，我心惊肉跳。我想让它走得慢一些… 我恨不得抓住它，抑制住它。可是，我无能为力，心有余而力不足… 那种焦虑和无助感，真的可以让你抓耳挠心塞。在这个网站页面主体的右下方，还有一个倒计时，目前，预计在2036年2月全球二氧化碳排放量达到10000亿吨，意味着那时全球平均温度较现在升高2℃左右。每一秒看着时间的走近，就让人觉得恐慌，灾难在一步步靠近…</p><p><img src="/medias/article/journal/reserve-time.jpg" alt="全球二氧化碳排放量达到10000亿吨倒计时"></p><blockquote><p>笔者注：这一数据信息是我在阅读阮一峰大佬的<strong><a href="http://www.ruanyifeng.com/blog/2018/08/weekly-issue-17.html" target="_blank" rel="noopener">这一片博客</a></strong>时获取到的，相信数据的真实性。个人对于这个数据，个人还存在一些疑问。</p><ol><li>目前我还没有搞清楚该网站如何获得这一数据值的，同时也不清楚该网站如何做到实时同步全球二氧化碳排放量的。</li><li>这应该是一个估计值，个人感觉实际的二氧化碳排放量肯定是有过之而无不及。</li></ol></blockquote><p>全球变暖已经是活生生的现实。化石燃料的过度使用，温室气体大量排放，滥砍滥发，绿色植被逐年大幅减少，海平面上升… 现在的地球就像是一个天然的<code>“烤炉”</code>。</p><blockquote><p></p><p class="data-resource">以下信息，引用自<a href="http://www.ruanyifeng.com/blog/2018/08/weekly-issue-17.html" target="_blank" rel="noopener">阮一峰博客</a></p><br>科学家估计，目前的年平均气温比工业革命前已经升高了<code>1度</code>。《巴黎气候协议》的目标是，气温升高控制在<code>2度</code>，但是成功的希望据说只有<code>5%</code>。如果学过统计学，你就知道，<code>5%</code>的机会在统计学上可以视作不会发生。现在的计算是，如果人类排放<code>10000亿吨</code>二氧化碳，地球就会升高<code>2度</code>，千万不要觉得，<code>2度</code>不算什么，<strong><a href="https://www.nytimes.com/interactive/2018/08/01/magazine/climate-change-losing-earth.html" target="_blank" rel="noopener">《纽约时报》</a></strong>描述了后果：<p></p><ul><li>升高<code>2度</code>：热带珊瑚礁灭绝，海平面上升几米，波斯湾不适合人类居住。</li><li>升高<code>3度</code>：北极的森林和大多数沿海城市被淹没。</li><li>升高<code>4度</code>：欧洲永久干旱， 中国、印度和孟加拉国大部分地区变成沙漠，美国科罗拉多河接近干涸，美国西南部将不适合居住。</li><li>升高<code>5度</code>：人类文明终结。</li></ul></blockquote><h3 id="我们到底要拯救谁"><a href="#我们到底要拯救谁" class="headerlink" title="我们到底要拯救谁"></a>我们到底要拯救谁</h3><p>第二次工业革命以来，人类社会飞速发展。起初，我们天真地以为地球资源取之不尽用之不竭，各个国家费劲一切力气开发一切可用资源——土地、石油、煤炭、天然气、海洋资源等等，为掠夺资源而发动战争也是屡见不鲜。我们错误地认为所谓位于食物链顶端的自由就是可以随意地拥有，我们陷入迷途肆意地挥洒，我们深陷迷途却毫不清楚、“义无反顾”… 到最后却要穷尽地球的所有… </p><p>我们的行为，极大地改变了地球生态，曾经的辉煌变成如今眼前的荒芜。全球气温升高，冰川面积锐减，海平面上升，极端天气骤多，臭氧层破坏，酸雨频发，生物多样性破坏，土地退化及荒漠化，森林面积锐减… 地球，愈来愈伤痕累累…</p><p>后来，我们“长大了”，意识到了问题的严重性。政府颁布各种法律禁令，国际组织签订个多项协议公约，目的就是想尽力保护地球生态，而这些行为有一个几乎相同的口号——“保护地球，保护我们赖以生存的家园”。以前觉得这一口号言简意赅、目的明确，知错就改，还是“好孩子”。直到最近，在网上看到下面这样一段话，感触很深。</p><blockquote><p>比起拯救地球，人类最需要拯救的是自己。地球她并不担心，因为她经历过更严重的灾难，毁灭般的气候变换，五次绝世大爆炸，数次核爆炸，数不清的火山喷发，社会动乱，彗星撞击，难以想象的冰川时期，各大洲错位的情况也时有发生，但是她都挺过来了，而且过得好好的。但，在这45亿年来，地球上96%的水生动物和70%的陆地脊椎动物都灭绝了。</p></blockquote><p>太阳的寿命100亿年，它已经走过了漫长的50亿年，地球也已经46亿岁了。以一个最简单的模型估计，太阳的终结伴随着地球的湮灭，那么地球还有50多亿年的寿命。前45亿年，经历了那么多的“坎坷”，地球依旧好好的，我相信以后的50多亿年，也不会坏到哪去，可这并不代表人类就能一直好好好的。<strong><code>对于地球的“一生”来说，人类的出现好似沧海一粟那么渺小，在慢慢长河中，甚至比不上弹指一挥间的短暂。我们的出现，就像你在春日里看到的路边的野花，就像是夜晚昙花那一瞬的闪耀。</code></strong> 我们要明白，拯救地球，拯救的不是地球本身，地球也不需要我们来拯救。<strong><code>我们要拯救的，是自己，而这其中更多的是对人类自己过往的一种救赎</code></strong>。</p><p>也许，对于地球来说，在不久的将来，她会回到自己最初的模样，一切归于沉寂，一切会从头来过。而那时，她已失去所有，失去了日出月落，失去了碧海蓝天，失去了草长莺飞，失去了寒梅傲雪。更重要的，她失去了自己的“孩子”，失去了欢声笑语，失去了曾经的辉煌，曾经的一切… 可，她还在，在宇宙的一隅，叹一口长长的太息，哀婉于曾经“孩子”的欲望与迷途…</p><h3 id="一首歌"><a href="#一首歌" class="headerlink" title="一首歌"></a>一首歌</h3><blockquote><p>最后，把我最喜欢的一位歌手——<strong><a href="https://www.baidu.com/link?url=BsltTzlHbDVY83hcXfq3fs1sPLee1fFXhRZperHgpnpGYrvNA1pkm_tIOWp6uwExDNz7hzr-4fK3XXpcLC3cvZElHhODunSKMhXqKqAcjTu&amp;wd=&amp;eqid=a1ae7140000804bc000000035b7167a3" target="_blank" rel="noopener">李健</a></strong>的一首歌曲<strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%B5%B7%E4%B9%8B%E5%AF%BB/18337760?fr=aladdin" target="_blank" rel="noopener">《深海之寻》</a></strong>分享给大家。这是李健作为<code>“国家海洋公益形象大使”</code>为<code>“世界海洋日暨中国海洋公益日”</code>创作的宣传曲。在歌中采用与海洋“对话”式的表达，用反思的方式，写出了自然对人类的失望，人类对自然的亏欠。</p></blockquote><div id="content-ctn"><br>  <div class="centerContent"><br><strong> 深海之寻 </strong><br>作词：李健<br>作曲：李健<br>编曲：赵兆<br><br>这无穷宇宙谁能看得透<br>不知不觉中你已经远走<br>我以为自由 是随意的拥有<br>可是到最后 快一无所有<br>我的辉煌让你黯淡了很久<br>我的挥洒穷尽了你的所有<br>在那拥挤的天空何止乌云密布<br>我已经深陷迷途还不清楚<br>竟义无反顾<br><br>这无边海洋装不下欲望<br>每一朵浪花都历经沧桑<br>我的辉煌让你黯淡了很久<br>我的挥洒穷尽了你的所有<br>在那拥挤的天空何止乌云密布<br>我已经深陷迷途还不清楚<br>竟义无反顾<br><br>曾经辉煌的地方如今已荒芜<br>一路孤独铺满了你的去处<br>在那风平浪静的下面暗流涌动<br>我已经踏上征途 狂奔向你<br>竟义无反顾<br><br>Wu~ 这无穷宇宙<br>Wu~ 谁能看得透<br>Wu~ 让我奔向你<br>Wu~ 给你我所有<br>  </div><br> </div><style>  #iframe-ctn {    padding: 0px;    margin: 30px auto 30px;    overflow: hidden;    width: 800px;    height: 95px;  }  #page-iframe {    position: relative;    left: 0px;    top: -205px;  }  .data-resource {    text-align:right;    font-size: 12px;    color: #999;  }  #arctic-pic img {    float: left;    height: 500px;  }</style>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读感悟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一篇2016年的随想</title>
      <link href="/2018/08/01/random-thoughts-1/"/>
      <url>/2018/08/01/random-thoughts-1/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>这篇随想，其实不是近期的作品，实际写于2016年9月6日。当时的我还在读大三，按照学校的教学安排，那个时候需要进行生产实习，两种选择 —— 参加学校组织的或者自己找实习工作。我自己找了一家本地的互联网公司去实习，做前端开发工作，这也是真正意义上的第一份工作，这篇随想就写于实习期间。</p><p>当时的我刚开始尝试着从一个学生向一个职场IT工作者转变。说实话，并不是很顺利，自己也很不适应，所以那一阵子很煎熬，对未来正式工作也产生了迷茫。主要的原因是很多工作上和技术上的要求在学校学到的还差得很远，工作的环境氛围、压力和自己之前预想的、准备的差距较大，所以一时半会儿不太适应，当时也比较焦虑。实习期间，我一直住在学校宿舍，一天下班后，路过熟悉的校园，回想起过去近三年的大学生活，走在一条昏暗的小路上，突然有了一些感慨，回去就顺手写下了这篇随想。</p><a id="more"></a><p><img src="/medias/article/random-thoughts/plates-1.jpg" alt="random-thoughts-1插图"></p><center>图片摄于2016年07月15日-西安理工大学金花校区</center><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><div id="content-ctn"><br>  <div class="centerContent"><br>    每个夜晚，<br>    他都会向影子招手，<br>    与草木问好，<br>    昏暗幽静的小路上，<br>    铺满一层层的煎熬与落寞。<br>    他步伐缓慢，<br>    一次次回望，<br>    望见身后的挣扎先生，<br>    神情依旧，<br>    同样迈着缓缓的步子，<br>    时不时也无奈地回头看。<br>    一转身，<br>    却又被自己撞到。<br>    撞乱了春秋冬夏，<br>    撞散了意念魂灵。<br>    <span class="date">—— 2016.09.06</span><br>  </div><br> </div><style>  #content-ctn span.date {    padding-left: 100px;  }</style>]]></content>
      
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 朝花夕拾 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你的工作是对生命的极大浪费</title>
      <link href="/2018/08/01/journal-1/"/>
      <url>/2018/08/01/journal-1/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><blockquote><p>这篇文章有一些桥段是我生活的影子，但本文的主人公完全虚构，不代表我和周围任何一个同事朋友。文章内容是我根据自己的经历更多是和不同朋友交流时了解到的加工而来。文章没有什么华丽的词藻，内容平铺直叙，但是我相信读下去你也许能在其中找到自己的影子或者是曾经熟悉的一幕。更多的是文章带有一些<code>“魔幻”</code>色彩，就是这一点点的<code>“魔幻”</code>成分才是文章中最大的暗示和思考。希望有兴趣的朋友能读下去，谢谢大家的支持！</p></blockquote><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>窗外，已经倾泻了一整夜的雨好像还是没有停下来的迹象。雨声伴着街道上汽车急促的鸣笛声再夹杂着发动机的轰鸣声传入屋内，又是一个繁忙嘈杂的早晨。窗内，昏昏沉沉，还在睡梦中的欧阳面色有些凝重，他应该又做梦了…</p><a id="more"></a><p>经济管理专业的欧阳，大学毕业后选择留在当地的一家民营私企从事行政相关的工作。平时就和一个朋友住在一起合租的小区公寓内。最近公司业务繁重，经常加班，他连续好几天加班到很晚，最近睡眠质量也不是很好。欧阳计划着，忙过这一阵，出去转一转，放松放松。</p><p>已经响过三次闹铃的手机再次响起，欧阳凭着仅仅清醒的些许意识，用手在枕边、枕头下一次次地摸索试探着，终于，在被窝里找到了“吵闹”了半天的手机。他缓缓睁开眼睛，眼皮重的就像是压在眼睛上的两座大山，双眼迷离，看了下时间 —— 2018年7月30日，早上8:00整。按下最后一遍闹铃开关，拖着“灌了铅”后又不听使唤的身躯，欧阳起身坐在床边，又闭上了眼睛，睁眼… 闭眼… 再睁眼… 每天起床就是一场持久的他和“周公”与“梦想”的拉锯战。一轮轮的交锋后，欧阳睁开眼睛，下床，懒散地拖着拖鞋，拿起洗漱用品，拖沓着身体走到卫生间，打开水龙头，欧阳看着镜子里的人，陌生又熟悉… 水漫出牙杯好一会儿，他才回过神，牙膏被肆意地挤在牙刷上，伸到嘴里漫无目的地游走一会儿，漱口。用冷水打湿面部，快速地搓一搓，反复几次，擦干，洗漱完毕。一瓶快要被挤得变形的“大宝”，勉勉强强地挤出一点到手上，在脸上四面八方地搓一搓，算是给他原本还帅气的脸上唯一“精致”的保养。穿上衣服，换上鞋，背上包，出门… 一天的工作又要开始了…</p><p>公寓电梯口，几乎层层都停的电梯好不容易停在自己面前，人快要挤满了… 欧阳挤进电梯，昨天好像也是这些人… 因为住在同一栋，遇到很正常，欧阳也没有多想。而所有人都像极了刚刚镜子里的自己，面无表情，睡眼惺忪，可能甚至都有人不知道电梯里又多了一个他。电梯下行，人越来越多，狭小的空间里越来越拥挤，早些进来的人也越来越着急。终于，几分钟过去，到了一层，所有人都急匆匆地涌出电梯，向小区门口赶去。欧阳似乎不善于争抢，踉踉跄跄的最后一个挤了出来。</p><p>外面还下着雨，公司离公寓说远不远，说近，将近5公里的距离，开“11路”走过去也不现实，况且早上时间本就不充裕。挤公交，住处到公司没有直达车，倒车、等车的时间换做骑车他骑个来回，这就很尴尬了… 所以，上班一年多以来，不论春夏秋冬，刮风下雨还是下雪，他都是骑车上班，也练就了一手撑伞一手骑车的“绝技”。撑着伞，在小区门口东张西望，不凑巧，今天运气不佳，“坐骑”被抢光了。欧阳住的小区是工薪族聚集地，一个小区八成左右都是上班族，每天早上稍微晚点,门口的共享单车就没你的份了。他也习以为常，老样子，沿着去公司的路先开“11路”吧，运气好路上还能捡到“宝”…几分钟后，他在街角发现一辆“某拜”，急匆匆赶过去，还没到跟前，被别人“截胡”了… 看着那人，欧阳脸上就是一幅复制版的“尴尬又不失礼貌的微笑”的表情包。再走一段路，又看见一辆，欧阳冲了过去，再被“截胡”的话今天就要迟到了！还好，没人和他抢，掏出手机，打开车锁，跨上车，刚骑没几米，发现后车轮有点瓢…“点儿真背！”，欧阳嘴里嘀咕着，“算了，赶时间，凑活着骑”，欧阳一手撑着伞，一手骑车把着方向，一路“哐啷…哐啷…”地往公司赶去… 一路晃荡，欧阳边骑边想：“早上看手机，今天是几号来着？”他在盘算着还有几天能休息？什么时候能放假，他想出去走走。一个不留神，车轮好像压到一块硬硬的东西，加上雨天路滑和这不争气的“坐骑”，欧阳连人带车就要摔倒在地上…</p><p>一瞬间，躺在床上的欧阳睁开眼睛，一身冷汗… 幸亏，幸亏，原来是个梦… 他看了一眼手机，2018年7月30日，早上8点10分，星期一。“靠！要迟到了！”，他下意识地喊了一句。着急忙慌穿上拖鞋，拿起洗漱用品来到卫生间，镜子里的自己依旧陌生又熟悉，这场景好像在哪见过？哪有功夫想那么多，同样的步骤，刷牙，洗脸，换衣服，背上包，出门，挤进依旧人满为患的电梯下楼，来到小区门口“抢”到一辆单车，今天还算幸运。一路狂飙来到公司楼下，电梯口长长的队伍，欧阳心里暗想：“妹的，又要迟到了…”。夏天高温，电梯里又闷又热，各种“迷人”的汗味混杂着各式早餐的味道，有点辣眼睛…</p><p>走进公司，伸手去打卡的瞬间，欧阳楞了一下，“咦，是不是已经打过卡了？”很快，他就否定了自己这个愚蠢的疑问。今天刚到公司，怎么可能打过卡？过糊涂了？没再多想，欧阳朝着自己的工位走了过去。跟往常一样，和同事打过招呼之后，欧阳坐在工位上，一刹那好像回到了昨天。“昨天同样如此坐在这，就好像是几小时甚至几分钟前的事”，欧阳心里一阵感叹… 看着电脑屏幕上隐约倒映出来的自己的脸，越看越陌生，越看越不像自己。毕业一年多来，由于工作和生活的压力，欧阳的确看起来憔悴了许多。每天的工作排得满满当当，加班几乎成了家常便饭，工作到凌晨一两点也是时不时会有的事。慢慢的，他也适应习惯了，唯一的就是身体逐渐消瘦了下来，还好，总体状况倒也健康。</p><p>“欧阳！”，背后的声音才让他回过神来，是老大 —— 一个最近让他烦透也恶心透了的人。平时大小事都不管，关键时刻总爱抛头露面装个13，没事总爱跪舔上级，最主要的，时不时话语中还不尊重同事。以前没发现，日子久了，欧阳真的是看不惯这种自以为是又没有素质的人，越看越觉得恶心。但，人家是领导，能有什么办法…? “昨天让你准备的材料真被好了没？今天郑总开会要用呢！”讨厌归讨厌，欧阳还是一脸不悲不喜的回到：“好了…” 他顺手把材料递过去，老大转身的时候欧阳一脸不屑的竖起中指。忙碌的一天又要开始了…欧阳像往常一样东奔西跑，前答后应，忙个不停，而这，只是他工作的日常罢了…</p><p>好不容易熬到中午，可以喘口气了。公司中午有两个小时的休息时间，也是白天唯一能放松的时段。七八月份，正是一年中最热的时候，欧阳和同事一起在楼下的小店里买了一份九块钱的快餐，因为公司能吹空调就带回了公司，坐在工位上开始了自己的午餐时间。一份快餐，三四个菜，荤腥少的可怜，吃饱可以，但毫无质量可言。十几分钟后，一天的主食也就结束了，简单收拾停当，欧阳趴在工位上玩起了手机，这是他一天中为数不多可以了解到“外面世界”的机会。刷一刷各类新闻，看一看明星八卦，欧阳又在盘算着，希望忙过这一段能出去转一转。毕竟，世界那么大，他也想去看看… 搁下手机，放下座椅靠背，躺下去，很快他就睡着了…</p><p>“叮铃铃铃…”，一阵铃声在耳边响起，欧阳睁开眼睛确是傻了眼，“我靠！什么情况？怎么还躺在床上！？” 欧阳像见鬼了一样不敢相信眼前的自己竟然还躺在公寓的床上！“玩什么？‘盗梦空间’么？梦中梦！？还是…现在还是在做梦？”欧阳脑子飞转，却怎么也想不明白，刚才梦里的一切也太真实了吧！越像越瘆得慌，欧阳学电视里掐了一下自己，“靠，真的疼，不是梦…”拿起手机看了看时间，2018年7月30日，早上8:00整,到了上班的时间。上班第一，欧阳也没敢再想太多，还是每天按部就班的流程，洗漱，换衣服，出门，挤电梯，抢“坐骑”… 欧阳一路赶到公司，又开始了一天的忙碌…</p><p>“欧阳，这堆报表按日期整理一下！”，“欧阳，这些财报一会给郑总送过去！”，“欧阳，公司该买电了！”，“欧阳，最近招聘季，注意注意有没有求职者应聘！”，“欧阳，明天张总要过来，提前联系一下！”，“欧阳”，“欧阳”…  因为公司规模不大，一个人顶两个人用，加上欧阳本身又比较勤恳办事也靠谱，所以作为行政岗的欧阳其实做了很多非本岗位的事情。就这样不可开交，“前赴后继”，等大事小事真正忙完又将近晚上11点了。欧阳看着窗外的夜色，街道上车水马龙黑，远处灯火阑珊，渐渐地他的眼神有些迷离。黑夜就像是深渊，盯着太久了，就出不来了，欧阳陷进去，沉思了很久…..</p><p>回过神来，欧阳收拾收拾工位，关了电脑，关上公司大门，乘着电梯下楼去了… 刚出写字楼，温热的风还在静静的吹，因为时间太晚，视野里已经找不到共享单车的踪迹，欧阳沿着回去的路，独自一人，慢慢地往回走… 回到公寓的时候已经近子夜时分了，夏天的夜晚温度依旧不低，这一路走来一身黏腻，卸下一身疲惫，欧阳简单地冲了个凉就躺下了。很快，他睡着了… 明天，又是普通却繁忙的一天，所有的一切还会继续…</p><p>当清晨的第一缕阳光划破天际，窗外，雨水好像早已停歇，鸣笛声和发动机的声音依旧“热热闹闹”。窗内，光线还是那么的昏暗。欧阳被最后一遍闹铃叫醒，惺忪的睡眼慢慢睁开，关掉闹钟，当看到手机上显示的时间，欧阳怔了一下，瞳孔瞬间扩大。他双手颤抖着把手机拿进，白色的眼球上瞬间布满血丝，全身寒毛卓竖，因为，手机上赫然是显示着时间：2028年7月31日，早上8:00整，星期一……</p><p><img src="/medias/article/journal/timg.gif" alt="盗梦空间-旋转的陀螺"></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><blockquote><p>谢谢您能读完这篇文章。就像<code>“序言”</code>中全所言，全文内容并不华丽，但略带<code>“魔幻”</code>的<code>“盗梦空间”</code>情节，是文章最大的暗示，也是最发人深省的部分。主人公欧阳一天中总感觉很多事似乎刚发生，很多场景也很熟悉，其实是因为他每一天都在重复着相同的事情，被工作占据了几乎所有的生活，所以脑海中只有这些事情记忆最深刻。还有隐藏的一点，按照逻辑全文看似几乎都发生在2018年7月30日这一天，其实这一天只是欧阳一天天工作生活的一个缩影和循环。每一次从梦中醒来，实际暗示着已经过去了一天甚至是很多天。直到最后，欧阳再一次醒来，才发现，时间飞逝，已经是10年之后的2028年了。</p></blockquote><blockquote><p>其实很多时候，我们会发现繁忙的工作和沉重的生活压力，让我们每天都过得失去了色彩，更甚至我们每天都在重复做着几乎相同的事情，日复一日…… 转眼间，可能就是几年甚至十几年。这也是现代人经常感叹时间很快的一个重要原因。所以，希望大家能在繁重的工作之余，给自己的生活增添一抹亮丽的色彩。毕竟，这个世界以及来到这个世界的幸运从来不值得被我们辜负。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活工作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CreateJS 入门</title>
      <link href="/2018/07/18/create-js/"/>
      <url>/2018/07/18/create-js/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是CreateJS"><a href="#什么是CreateJS" class="headerlink" title="什么是CreateJS"></a>什么是CreateJS</h3><blockquote><p><a href="https://www.createjs.com/" target="_blank" rel="noopener">官网介绍</a> （<a href="http://www.createjs.cc/" target="_blank" rel="noopener">中文</a>）：CreateJS 是一组模块化代码库和工具套件，可以独立工作也可以组合工作，用于通过HTML5技术来在网页上开发丰富的交互式内容。</p></blockquote><h3 id="四个核心库"><a href="#四个核心库" class="headerlink" title="四个核心库"></a>四个核心库</h3><p>CreateJS主要包含如下四个类库：</p><ul><li><code>EaselJS</code> – 简化处理HTML5画布（核心）</li><li><code>TweenJS</code> – 用来帮助设计H5动画，调整HTML5属性</li><li><code>SoundJS</code> – 用来简化处理HTML5 audio 音频</li><li><code>PreloadJS</code> – 帮助管理和协调加载中的一些资源</li></ul><a id="more"></a><p><strong>今天，主要来了解一下 <code>EaselJS</code> 库</strong></p><h3 id="EaselJS"><a href="#EaselJS" class="headerlink" title="EaselJS"></a>EaselJS</h3><p><img src="/medias/article/coding/create-js/easeljs.jpg" alt="EaselJS"></p><h4 id="EaselJS-简介"><a href="#EaselJS-简介" class="headerlink" title="EaselJS 简介"></a>EaselJS 简介</h4><blockquote><p><code>EaselJS</code> 是一个JavaScript库,用来简单快捷的操作 <code>HTML5 Canvas</code> 标签。在创建H5游戏，生成艺术作品、处理其他高级图形化等工作中有着很友好的体验。</p></blockquote><h4 id="EaselJS中的一些核心类"><a href="#EaselJS中的一些核心类" class="headerlink" title="EaselJS中的一些核心类"></a>EaselJS中的一些核心类</h4><ol><li><code>Stage Class</code> – 创建舞台</li><li><code>Text Class</code> – 绘制文字</li><li><code>Graphics Class</code> – 绘制图形</li><li><code>Shape Class</code> – 绘制图形</li><li><code>Bitmap Class</code> – 绘制图片</li><li><code>Ticker Class</code> – 定时广播</li><li>……等</li></ol><h3 id="一些”栗子”"><a href="#一些”栗子”" class="headerlink" title="一些”栗子”"></a>一些”栗子”</h3><h4 id="绘制文本-Text-Class"><a href="#绘制文本-Text-Class" class="headerlink" title="绘制文本(Text Class)"></a>绘制文本(Text Class)</h4><p>定义一个<code>&lt;canvas&gt; &lt;/canvas&gt;</code> 画布。</p><pre><code>// HTML:&lt;!-- Text Class 文本类--&gt;&lt;canvas id=&quot;demo1&quot; width=&quot;650&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;</code></pre><p>调用<code>EaselJS</code>提供的<code>API - new createjs.Text()</code>，绘制文字</p><pre><code>// JS&lt;script src=&quot;https://code.createjs.com/1.0.0/createjs.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  window.onload = () =&gt; {    /**      * Test Class 文本类 -- demo      */    let stage1 = new createjs.Stage(&quot;demo1&quot;);    let text1 = new createjs.Text(&quot;Text 1 !&quot;, &quot;bold 26px Arial&quot;, &quot;#ff7700&quot;);    text1.regX = -50;     // 沿X轴负方向的偏移量    text1.regY = -50;     // 沿Y轴负方向的偏移量    text1.x = 100;        // 绘制源点 X坐标    text1.y = 50;         // 绘制源点 Y坐标    let text2 = new createjs.Text(&quot;旋转+XY拉伸！&quot;, &quot;bold 18px Arial&quot;, &quot;#ff7700&quot;);    text2.x = 50;    text2.y = 50;    text2.rotation = 50;      // 旋转角度 DEG    text2.scaleX = 3;         // X轴放大(拉伸)    text2.scaleY = 2;         // X轴放大(拉伸)    let text3 = new createjs.Text(&quot;XY轴倾斜&quot;, &quot;bold 50px Arial&quot;, &quot;#ff7700&quot;);    text3.x = 300;    text3.y = 200;    text3.skewX = 45;         // X轴倾斜角度 DEG    text3.skewY = 20;         // Y周倾斜角度 DEG    let text4 = new createjs.Text(&quot;文字shadow&quot;, &quot;bold 30px Arial&quot;, &quot;#ff7700&quot;);    text4.x = 400;    text4.y = 100;    text4.shadow = new createjs.Shadow(&quot;#000000&quot;, 5, 5, 10);      // 创建一个shadow实例Object    stage1.addChild(text1, text2, text3, text4);    stage1.update();    // 更新舞台，每次修改操作后需要更新真个舞台才有效果  }&lt;/script&gt;</code></pre><h4 id="绘制图形-Graphics-Class"><a href="#绘制图形-Graphics-Class" class="headerlink" title="绘制图形(Graphics Class)"></a>绘制图形(Graphics Class)</h4><p>定义一个<code>&lt;canvas&gt; &lt;/canvas&gt;</code> 画布。</p><pre><code>// HTML:&lt;!-- Graphics Class 文本类--&gt;&lt;canvas id=&quot;demo2&quot; width=&quot;650&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;</code></pre><p>调用<code>EaselJS</code>提供的<code>API - new createjs.Graphics()</code>，绘制图形</p><pre><code>// JS&lt;script src=&quot;https://code.createjs.com/1.0.0/createjs.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  window.onload = () =&gt; {    /**      * Graphics Class 绘图类 -- demo      * 用于生成矢量绘图指令      */    let stage2 = new createjs.Stage(&#39;demo2&#39;)    // 画线    let g = new createjs.Graphics();    /* 同一个 Graphics 实例， 可以多次绘制，以下线段、折线都是用 g 实例绘制的*/    g.setStrokeStyle(10).beginStroke(&quot;#d23c4f&quot;).moveTo(400,10).lineTo(600,100)    // 简写形式    g.ss(20).s(&#39;#fafa35&#39;).mt(400,100).lt(400,260)    // 多点折线的简写形式    g.ss(1).s(&#39;#000&#39;).mt(600,400).lt(600, 200).lt(400,300).lt(500, 550)    // Graphics 实例不能直接 addChild() 到舞台 stage 中，实例化为 Shape 实例后才可以    let line = new createjs.Shape(g)    // 圆    let g1 = new createjs.Graphics();    g1.setStrokeStyle(1);         // 描边    g1.beginStroke(&quot;#000000&quot;);    // 描边颜色    g1.beginFill(&quot;red&quot;);          // 图形填充    g1.drawCircle(0,0,100);        // 绘制 (X, X, R)    let c1 = new createjs.Shape(g1)     // 实例化Shape对象    // 矩形    let g2 = new createjs.Graphics().beginStroke(&quot;red&quot;).beginFill(&quot;blue&quot;).drawRect(150, 0, 200, 100);     // X, Y, W, H    let c2 = new createjs.Shape(g2)    // 命令对象    let g3 = new createjs.Graphics();    // 每个图形接口调用后会生成一个命令对象，可以使用.command访问，它保存对已创建或附加的最后一个命令的引用    let fillCommand = g3.beginFill(&quot;green&quot;).command;    g3.drawCircle(200,200,50);        // 绘制 (X, X, R)    let c3 = new createjs.Shape(g3);    // 一些异步操作后，更新填充样式/颜色:    setTimeout(() =&gt; {      fillCommand.style = &quot;gray&quot;;      stage2.update();                // 不更新舞台，不会重新渲染    }, 2000);    // 点击事件    //c3.addEventListener(&#39;click&#39;, () =&gt; {    // alert(123)    // fillCommand.style = &quot;gray&quot;;    // stage2.update();          // 不更新舞台，不会重新渲染    //})    stage2.addChild(c1, c2, c3, line);    stage2.update();  }&lt;/script&gt;</code></pre><h4 id="绘制图像imgaes-Bitmap-Class"><a href="#绘制图像imgaes-Bitmap-Class" class="headerlink" title="绘制图像imgaes(Bitmap Class)"></a>绘制图像imgaes(Bitmap Class)</h4><p>定义一个<code>&lt;canvas&gt; &lt;/canvas&gt;</code> 画布。</p><pre><code>// HTML:&lt;!-- Bitmap Class 图像类--&gt;&lt;canvas id=&quot;demo3&quot; width=&quot;650&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;</code></pre><p>调用<code>EaselJS</code>提供的<code>API - new createjs.Bitmap()</code>，绘制图像</p><pre><code>// JS&lt;script src=&quot;https://code.createjs.com/1.0.0/createjs.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  window.onload = () =&gt; {    /**      * bitmap Class 图像类      * 用于在画布显示列表中渲染图像      */    let stage3 = new createjs.Stage(&#39;demo3&#39;)    // 渲染图片    let bitmap = new createjs.Bitmap(&#39;./assets/img/hill1.png&#39;)    bitmap.alpha = 0.6      // 透明度    bitmap.cursor = &#39;help&#39;    // 创建一个shadow实例Object(color, offsetX, offsetY, blur)    bitmap.shadow = new createjs.Shadow(&quot;#97c89e&quot;, 20, 10, 20);    // 给图片添加遮罩    let bitmap2 = new createjs.Bitmap(&#39;./assets/img/avatar.jpg&#39;)    bitmap2.x = 400;        // 图片绘制的起始点X坐标    bitmap2.y = 0;          // 图片绘制的起始点Y坐标    //遮罩图形    let shape = new createjs.Shape();    shape.graphics.beginFill(&#39;#000&#39;).drawCircle(0, 0, 100);    shape.x = 500;          // 圆心X坐标    shape.y = 100;          // 圆心Y坐标    bitmap2.mask = shape;   //给图片bg添加遮罩    // 绘制一片草地    let groundBg = new createjs.Bitmap(&quot;./assets/img/ground.png&quot;).image;    let ground = new createjs.Shape();    w = stage3.canvas.width;      // 650    h = stage3.canvas.height;     // 400    stage3.addChild(ground)    stage3.addChild(bitmap, bitmap2)    stage3.update()       // 此处刷新无效    // 监听定时广播    createjs.Ticker.timingMode = createjs.Ticker.RAF;    createjs.Ticker.addEventListener(&#39;tick&#39;,(event) =&gt; {      ground.tileW = groundBg.width;      ground.y = h - groundBg.height;      ground.graphics.beginBitmapFill(groundBg).drawRect(0, 0, w, groundBg.height);      ground.cache(0, 0, w, groundBg.height);      stage3.update()    });  }&lt;/script&gt;</code></pre><h3 id="一个小游戏-来自官网Demo-Running-man"><a href="#一个小游戏-来自官网Demo-Running-man" class="headerlink" title="一个小游戏(来自官网Demo) Running man"></a>一个小游戏(来自官网Demo) Running man</h3><h4 id="定义一个-lt-canvas-gt-lt-canvas-gt-画布"><a href="#定义一个-lt-canvas-gt-lt-canvas-gt-画布" class="headerlink" title="定义一个&lt;canvas&gt;&lt;/canvas&gt;画布"></a>定义一个<code>&lt;canvas&gt;&lt;/canvas&gt;</code>画布</h4><pre><code>&lt;!-- HTML --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;running-man game&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;canvas id=&quot;demoCanvas&quot; width=&quot;960&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><p>这里就不写具体思路分析了，代码不长，注释也很详细，方便理解，直接上代码。</p><pre><code>// JS&lt;script src=&quot;https://code.createjs.com/1.0.0/createjs.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  window.onload = () =&gt; {    let stage, w, h, loader;    let sky, grant, ground, hill, hill2;    function init() {      stage = new createjs.StageGL(&quot;demoCanvas&quot;);      // 获取画布的宽和高，后面计算使用      w = stage.canvas.width;     // 960      h = stage.canvas.height;    // 400      // 定义静态资源      let manifest = [{        src: &quot;spritesheet_grant.png&quot;, id: &quot;grant&quot;}, {     // 人物动作雪碧图        src: &quot;sky.png&quot;, id: &quot;sky&quot;}, {           // 天空        src: &quot;ground.png&quot;, id: &quot;ground&quot;}, {     // 地面        src: &quot;hill1.png&quot;, id: &quot;hill&quot;}, {        // 远山        src: &quot;hill2.png&quot;, id: &quot;hill2&quot;           // 近山      }];     // Array, String, Object      // 创建资源加载队列      // (Boolean) 用XHR还是用HTML标签来加载      // 如果是false的时候，就用标签来加载，如果不能用标签的话，就用XHR来加载。默认是true，用XHR来加载。      loader = new createjs.LoadQueue(false);      // 添加&quot;资源加载完成&quot;事件      loader.addEventListener(&quot;complete&quot;, handleComplete);      // 加载资源      loader.loadManifest(manifest, true, &quot;./assets/img/&quot;);  // (manifest, loadNow, basePath)    }    /**      * 静态资源加载完成，处理函数      */    function handleComplete() {      // 渲染天空      sky = new createjs.Shape();      sky.graphics.beginBitmapFill(loader.getResult(&quot;sky&quot;)).drawRect(0, 0, w, h);      // 定义缓存区域(整个天空的区域))      sky.cache(0, 0, w, h);      // 渲染地面      let groundImg = loader.getResult(&quot;ground&quot;);      ground = new createjs.Shape();      // 注意：drawRect()宽度要躲绘制一个单位      ground.graphics.beginBitmapFill(groundImg).drawRect(0, 0, w + groundImg.width, groundImg.height);      ground.tileW = groundImg.width;      ground.y = h - groundImg.height;      // 缓存区域(地面的区域)      ground.cache(0, 0, w + groundImg.width, groundImg.height);      // 随机渲染远处山脉      hill = new createjs.Bitmap(loader.getResult(&quot;hill&quot;));      // 设置图像转换      // setTransform([x=0], [y=0], [scaleX=1], [scaleY=1], [rotation=0], [skewX=0], [skewY=0], [regX=0], [regY=0])      hill.setTransform(Math.random() * w, h - hill.image.height * 4 - groundImg.height, 4, 4);      hill.alpha = 0.5;     // 设置透明度      // 随机渲染近处山脉      hill2 = new createjs.Bitmap(loader.getResult(&quot;hill2&quot;));      hill2.setTransform(Math.random() * w, h - hill2.image.height * 3 - groundImg.height, 3, 3);      // 创建雪碧图动画      let spriteSheet = new createjs.SpriteSheet({        framerate: 30,      // 帧率 FPS        &quot;images&quot;: [loader.getResult(&quot;grant&quot;)],      // 雪碧图原图        &quot;frames&quot;: {&quot;width&quot;: 165, &quot;height&quot;: 292, &quot;count&quot;: 64, &quot;regX&quot;: 82, &quot;regY&quot;: 0},  // 初始化        // 定义动画        &quot;animations&quot;: {          &quot;run&quot;: [0, 25, &quot;run&quot;],     // name: [开始索引, 结束索引, &#39;下一个动画名称&#39;, 倍率]          &quot;jump&quot;: [26, 63, &quot;run&quot;]        }      });      // 绘制动画      grant = new createjs.Sprite(spriteSheet, &quot;run&quot;);      // 处理雪碧图人物下方空白      grant.y = 35;      // 将生成的所有内容渲染至舞台      stage.addChild(sky, ground, hill, hill2, grant);      // 监听舞台上的鼠标点击事件      stage.addEventListener(&quot;stagemousedown&quot;, () =&gt; {        // 跳转播放 jump 动画        grant.gotoAndPlay(&quot;jump&quot;);      });      createjs.Ticker.timingMode = createjs.Ticker.RAF;     // RAF / RAF_SYNCHED / TIMEOUT      createjs.Ticker.addEventListener(&quot;tick&quot;, tick);    }    /**      * 定时器-重绘舞台      */    function tick(event) {      // event.delta -- 上一次tick到当前tick的ms      let deltaS = event.delta / 1000;      // 雪碧图人物移动距离      let position = grant.x + 150 * deltaS;      // getBounds() -- 返回当前帧相对于雪碧图原点的边界      let grantW = grant.getBounds().width * grant.scaleX;      grant.x = (position &gt;= w + grantW) ? -grantW : position;      ground.x = (ground.x - deltaS * 150) % ground.tileW;      // 从右至左移动山脉      hill.x = (hill.x - deltaS * 30);      // 如果山脉从左侧离开屏幕      if (hill.x + hill.image.width * hill.scaleX &lt;= 0) {        hill.x = w;     // 重置回屏幕最右侧      }      // 处理如上      hill2.x = (hill2.x - deltaS * 45);      if (hill2.x + hill2.image.width * hill2.scaleX &lt;= 0) {        hill2.x = w;      }      stage.update();    }    // 程序主入口-初始化    init()  }&lt;/script&gt;</code></pre><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><blockquote><p>示例demo的GitHub地址：<a href="https://github.com/webCaolixin/study-notes/tree/master/create-js" target="_blank" rel="noopener">完整代码</a></p></blockquote><!-- 图片链接定义-->]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Create.JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>伊 始</title>
      <link href="/2018/07/11/beginning/"/>
      <url>/2018/07/11/beginning/</url>
      
        <content type="html"><![CDATA[<h3 id="开始的开始"><a href="#开始的开始" class="headerlink" title="开始的开始"></a>开始的开始</h3><p>最近几天的西安城，阴雨绵绵，到哪都是湿漉漉的一片，给人一种身处烟雨江南的感觉。走在人少路窄的街道上，你也许能体会到戴望舒那“独自徘徊在悠长、悠长又寂寥的雨巷”朦胧而又幽深的美感，还会期待着“逢着一个丁香一样的结着愁怨的姑娘”。说实话，这不是西安第一次让我产生这样的错觉，今年夏天的西安，似乎更受雨水的青睐，总在温度快速攀升至30多度的时候迎来一场及时雨，之后又快速回落，这便被网友玩成了“满30立减20”的梗。的确，今年夏天西安少了一些往年的燥热，多了几分夏末秋初的凉爽。</p><a id="more"></a><h3 id="善“思”"><a href="#善“思”" class="headerlink" title="善“思”"></a>善“思”</h3><p>我喜欢下雨天，不仅仅是因为雨天凉快，更重要的是我喜欢雨后万物如新洗的明丽和纯粹，洗去一身尘垢，显得本真色彩，这种雨后独有的清新秀丽在其他时间是看不到、体会不到的。其实，还有一个重要原因是我喜欢时不时地“胡思乱想”。一直觉得雨天最适合“天马行空”，尤其是雨后，觅一幽静之处，檐下雨水滴答，袖间凉风习习，雾气散尽之后，溢成满屋花香。这个时候，放空脑袋，忘却平日的紧张与忙碌，心随着眼睛漫无目的的在近处、远处、高处、低处肆意游荡。当有趣的事物映入眼帘，定睛多瞧几眼，之后会心一笑。仰望天空，乌云未散，依旧能感受到“黑云压城城欲摧”的气势。凝望着天空，就好似凝望着无尽的深渊，而此时，深渊也在凝望着你，看得愈久，陷得愈深，这便开始了天马行空般的“胡思乱想”。可能会从日常闲事想到人生哲理，也许会从方隅之间想到世界宇宙，会想东想西，会“思前想后”。这种思考不一定有多大意义，甚至可能有人认为毫无意义，但最重要的是这可以放松身心，在匆忙疲惫的生活中在精神上宽慰自己。心里的豁然开朗、风轻云淡，还有思维的释放，用语言很难表达出那种奇妙的感觉。据说每天给自己一定时间的冥想，能很好地平静内心，缓解压力，促进身心健康，更重要的是，也许某一时刻的灵光闪动，就会是改变你一生的“箴言”。</p><p>最近一直阴雨天，加上近来工作也相对清闲，便有了较多的时间做自己想做的事情，这对于我，可以说是如获至宝。因为真正忙碌的时候，没有时间更重要是没有心思去做其他的事情，也可能是长时间的“养老”氛围让我有些安逸和懒惰了。这一段时间，一直觉得过得有些浑浑噩噩，过于单调乏味。白天上班，空余看看技术文章，找找技术盲点研究研究，时间长了就会有些许疲惫。下班之后，便起身回到住处（我不太喜欢把租的公寓称之为“家”，不论是合租还是自己一个人住，因为在我觉得那不是“家”，称之为“住处”更为合适），回去便是“咸鱼躺”，然后刷刷新闻、微博，看看综艺（《向往的生活》一直是我很喜欢的一档综艺，很慢生活，很田园，推荐可以看看），隔三差五洗洗衣服。几乎每天都是这样，这让我每天起床睁眼，总觉得被“困”在了同一天，循环这一天所有的事情，就像电影<a href="https://baike.baidu.com/item/%E5%9C%9F%E6%8B%A8%E9%BC%A0%E4%B9%8B%E6%97%A5/3687686" target="_blank" rel="noopener">《土拨鼠之日》</a>一样。</p><p>这样的生活也有一段时了，刚开始没感到有什么不妥，也没察觉其中的可怕之处。这几天，总是觉得被这一天“困”得无法前进，觉得自己更像是一个“智能机器”，醒来之后便重复着几乎相同的事情，睡着后什么都像是忘掉了，可能连“梦”都没有。都说不做梦，是因为睡眠质量好，可一直不做梦是不是也有些可怜甚至可悲呢？这种循环最可怕的在于，你的记忆里就只有了早上起床洗漱、挤公交上班、枯燥地工作八小时甚至十几个小时、挤公交下班、洗漱睡觉这些事情，然后一天天地反复循环，没有尽头……这样的生活还会给人一种可怕的错觉 —— “时间过得真快”，对于一般的工薪上班族，这种感觉应该是格外明显。在我看来，这种生活是可怜的，也是可怕的，时间久了，如果渐渐适应或者说妥协，是一件很可怕的事情，就像<a href="https://baike.baidu.com/item/%E9%9D%92%E8%9B%99%E6%95%88%E5%BA%94/9627267" target="_blank" rel="noopener">“青蛙效应”</a>。毕竟从“智人”进化而来的人类，是“智”、“思考”造就了今天的我们，生而为人，如果每天扮演一个“智能机器”的角色，还真是很不甘心啊……</p><h3 id="善“思”，亦应善“行”"><a href="#善“思”，亦应善“行”" class="headerlink" title="善“思”，亦应善“行”"></a>善“思”，亦应善“行”</h3><p>与其被困在原地，每天浑浑噩噩，那不如做一些改变。如果说没有意识到，或者说习惯了循环式的生活，那就另当别论。但如果选择改变，选择不妥协，那就应该做出改变。工作学习之余，合理安排时间，看看书，练练字，写写博客，跑跑步，健健身，学学厨艺，学学摄影，随处走走停停……对了，每天给自己冥想的时间，也是一个不错的选择，在善“思”的同时，亦应该做到善“行”。</p><p>每个人都应该有自己的爱好，有自己的乐趣所在，也应该有自己想要做但没来得及做的事情。一切都不算晚，一切都还有机会，最重要的是学会开始，毕竟“万事开头难”。改变并不意味着要短时间的巨变，给自己一个过渡的时间，一个循序渐进的过程，“量变到质变”是一个永恒不变的真理。</p><p>所以，我想，首先学会写博客，把自己的生活记录下来，再分享给大家。不一定要有很多人看，更不奢求有什么粉丝，只是希望看到文章的人在读到某一行，某一句的时候会心一笑，或者能帮你拨去心头的乌云。其实最简单的目的还是为了记录自己生活的点滴，记录自己的心路历程，同时也记录自己思想转变的过程，我相信日后回味起来，这将是一杯世间最醇的“美酒”……</p><p>最后，把我很喜欢的一段话分享给大家，这是国产电影《大鱼·海棠》中女主人公 —— 椿 的一段独白：</p><blockquote><p><strong>你相信奇迹吗？</strong><br><strong>生命是一场旅程，我们等了多少个轮回，才有机会去享受这一次旅程。</strong><br><strong>这短短的一生，我们最终都会失去，不妨大胆一些，爱一个人，攀一座山，追一个梦。是的，不妨大胆一些。</strong><br><strong>很多事我都不了解，很多问题也没有答案。但我相信，上天给我们生命，一定是为了让我们创造奇迹的。</strong><br><strong>—— 电影《大鱼·海棠》</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活工作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分分钟教你用node.js写个爬虫</title>
      <link href="/2018/06/08/news-spider/"/>
      <url>/2018/06/08/news-spider/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是爬虫"><a href="#一、什么是爬虫" class="headerlink" title="一、什么是爬虫"></a>一、什么是爬虫</h3><blockquote><p><a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/5162711?fr=aladdin&amp;fromid=22046949&amp;fromtitle=%E7%88%AC%E8%99%AB" target="_blank" rel="noopener">网络爬虫</a>（又被称为网页蜘蛛，网络机器人，在<code>FOAF</code>社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。<br><a href="https://en.wikipedia.org/wiki/Web_crawler" target="_blank" rel="noopener">WIKIPEDIA 爬虫介绍</a></p></blockquote><h3 id="二、爬虫的分类"><a href="#二、爬虫的分类" class="headerlink" title="二、爬虫的分类"></a>二、爬虫的分类</h3><ul><li>通用网络爬虫（全网爬虫）<blockquote><p>爬行对象从一些 <code>种子URL</code> 扩充到整个 Web，主要为门户站点搜索引擎和大型 Web 服务提供商采集数据。</p></blockquote></li></ul><a id="more"></a><p><img src="/medias/article/coding/news-spider/1.jpg" alt="通用爬虫工作流程"></p><ul><li><p>聚焦网络爬虫（主题网络爬虫）</p><blockquote><p>是 <code>指选择性</code> 地爬行那些与预先定义好的主题相关页面的网络爬虫。 </p></blockquote></li><li><p>增量式网络爬虫</p><blockquote><p>指对已下载网页采取增量式更新和 <code>只爬行新产生的或者已经发生变化网页</code> 的爬虫，它能够在一定程度上保证所爬行的页面是尽可能新的页面。</p></blockquote></li><li><p>Deep Web 爬虫</p><blockquote><p>爬行对象是一些在用户填入关键字搜索或登录后才能访问到的<code>深层网页信息</code>的爬虫。</p></blockquote></li></ul><h3 id="三、爬虫的爬行策略"><a href="#三、爬虫的爬行策略" class="headerlink" title="三、爬虫的爬行策略"></a>三、爬虫的爬行策略</h3><ul><li>通用网络爬虫（全网爬虫）<blockquote><p>深度优先策略、广度优先策略</p></blockquote></li></ul><p><img src="/medias/article/coding/news-spider/2.png" alt="页面关系模拟树状结构"></p><ul><li><p>聚焦网络爬虫（主题网络爬虫）</p><blockquote><p>基于内容评价的爬行策略（内容相关性），基于链接结构评价的爬行策略、基于增强学习的爬行策略（链接重要性），基于语境图的爬行策略（距离，图论中两节点间边的权重）</p></blockquote></li><li><p>增量式网络爬虫</p><blockquote><p> 统一更新法、个体更新法、基于分类的更新法、自适应调频更新法</p></blockquote></li><li><p>Deep Web 爬虫</p><blockquote><p>Deep Web 爬虫爬行过程中最重要部分就是表单填写，包含两种类型：基于领域知识的表单填写、基于网页结构分析的表单填写</p></blockquote></li></ul><p><strong>现代的网页爬虫的行为通常是四种策略组合的结果：</strong></p><blockquote><p>选择策略：决定所要下载的页面；<br>重新访问策略：决定什么时候检查页面的更新变化；<br>平衡礼貌策略：指出怎样避免站点超载；<br>并行策略：指出怎么协同达到分布式抓取的效果；</p></blockquote><p><img src="/medias/article/coding/news-spider/3.jpg" alt="现代分布式爬虫系统"></p><h3 id="四、写一个简单网页爬虫的流程"><a href="#四、写一个简单网页爬虫的流程" class="headerlink" title="四、写一个简单网页爬虫的流程"></a>四、写一个简单网页爬虫的流程</h3><ol><li>确定爬取对象（网站/页面）</li><li>分析页面内容（目标数据/DOM结构）</li><li>确定开发语言、框架、工具等</li><li>编码 测试，爬取数据</li><li>优化</li></ol><h3 id="一个简单的百度新闻爬虫"><a href="#一个简单的百度新闻爬虫" class="headerlink" title="一个简单的百度新闻爬虫"></a>一个简单的百度新闻爬虫</h3><h4 id="确定爬取对象（网站-页面）"><a href="#确定爬取对象（网站-页面）" class="headerlink" title="确定爬取对象（网站/页面）"></a>确定爬取对象（网站/页面）</h4><blockquote><p><a href="http://news.baidu.com/" target="_blank" rel="noopener">百度新闻</a> （<a href="http://news.baidu.com/）" target="_blank" rel="noopener">http://news.baidu.com/）</a></p></blockquote><h4 id="分析页面内容（目标数据-DOM结构）"><a href="#分析页面内容（目标数据-DOM结构）" class="headerlink" title="分析页面内容（目标数据/DOM结构）"></a>分析页面内容（目标数据/DOM结构）</h4><blockquote><p>······</p></blockquote><h4 id="确定开发语言、框架、工具等"><a href="#确定开发语言、框架、工具等" class="headerlink" title="确定开发语言、框架、工具等"></a>确定开发语言、框架、工具等</h4><blockquote><p><code>node.js (express)</code> + <code>SublimeText 3</code></p></blockquote><h4 id="编码，测试，爬取数据"><a href="#编码，测试，爬取数据" class="headerlink" title="编码，测试，爬取数据"></a>编码，测试，爬取数据</h4><blockquote><p>coding ···</p></blockquote><h3 id="Let’s-start"><a href="#Let’s-start" class="headerlink" title="Let’s start"></a>Let’s start</h3><h4 id="新建项目目录"><a href="#新建项目目录" class="headerlink" title="新建项目目录"></a>新建项目目录</h4><blockquote><p>1.在合适的磁盘目录下创建项目目录<code>baiduNews</code>（我的项目目录是：<code>F:\web\baiduNews</code>）</p></blockquote><p><strong>注：因为在写这篇文章的时候用的电脑真心比较渣。安装WebStorm或者VsCode跑项目有些吃力。所以后面的命令行操作我都是在Window自带的DOS命令行窗口中执行的。</strong></p><h4 id="初始化package-json"><a href="#初始化package-json" class="headerlink" title="初始化package.json"></a>初始化package.json</h4><blockquote><p>1.在DOS命令行中进入项目根目录 <code>baiduNews</code><br>2.执行<code>npm init</code>，初始化<code>package.json</code>文件</p></blockquote><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><blockquote><p><code>express</code> （使用express来搭建一个简单的Http服务器。当然，你也可以使用node中自带的<code>http</code>模块）<br><code>superagent</code> （superagent是node里一个非常方便的、轻量的、渐进式的第三方客户端请求代理模块，用他来请求目标页面）<br><code>cheerio</code> （cheerio相当于node版的jQuery，用过jQuery的同学会非常容易上手。它主要是用来获取抓取到的页面元素和其中的数据信息）</p></blockquote><pre><code>// 个人比较喜欢使用yarn来安装依赖包,当然你也可以使用 npm install 来安装依赖，看个人习惯。yarn add expressyarn add superagentyarn add cheerio</code></pre><p>依赖安装完成后你可以在package.json中查看刚才安装的依赖是否成功。<br>安装正确后如下图：</p><p><img src="/medias/article/coding/news-spider/4.jpg" alt="安装依赖包"></p><h4 id="开始coding"><a href="#开始coding" class="headerlink" title="开始coding"></a>开始coding</h4><p><strong> 一、使用<code>express</code>启动一个简单的本地Http服务器 </strong></p><p>1、在项目根目录下创建<code>index.js</code>文件（后面都会在这个index文件中进行coding）</p><p>2、创建好<code>index.js</code>后，我们首先实例化一个<code>express</code>对象，用它来启动一个本地监听<code>3000</code>端口的Http服务。</p><pre><code>const express = require(&#39;express&#39;);const app = express();// ...let server = app.listen(3000, function () {  let host = server.address().address;  let port = server.address().port;  console.log(&#39;Your App is running at http://%s:%s&#39;, host, port);});</code></pre><p>对，就是这么简单，不到10行代码，搭建启动一个简单的本地Http服务。</p><p>3、按照国际惯例，我们希望在访问本机地址<code>http://localhost:3000</code>的时候，这个服务能给我们犯规一个<code>Hello World！</code>在<code>index.js</code>中加入如下代码：</p><pre><code>app.get(&#39;/&#39;, function (req, res) {  res.send(&#39;Hello World!&#39;);});</code></pre><blockquote><p>此时，在DOS中项目根目录<code>baiduNews</code>下执行<code>node index.js</code>,让项目跑起来。之后，打开浏览器，访问<code>http://localhost:3000</code>,你就会发现页面上显示’Hellow World!’字样。<br>这样，在后面我们获取到百度新闻首页的信息后，就可以在访问<code>http://localhost:3000</code>时看到这些信息。</p></blockquote><p><strong>二、抓取百度新闻首页的新闻信息</strong></p><p>1、 首先，我们先来分析一下百度新闻首页的页面信息。</p><p><img src="/medias/article/coding/news-spider/5.jpg" alt="百度新闻首页"></p><p><img src="/medias/article/coding/news-spider/6.jpg" alt="百度新闻首页"></p><blockquote><p>百度新闻首页大体上分为“热点新闻”、“本地新闻”、“国内新闻”、“国际新闻”……等。这次我们先来尝试抓取左侧<code>“热点新闻”</code>和下方的<code>“本地新闻”</code>两处的新闻数据。</p></blockquote><p><img src="/medias/article/coding/news-spider/7.jpg" alt="热点新闻DOM结构"></p><blockquote><p><code>F12</code>打开<code>Chrome</code>的控制台，审查页面元素，经过查看左侧“热点新闻”信息所在<code>DOM</code>的结构，我们发现所有的“热点新闻”信息（包括新闻标题和新闻页面链接）都在<code>id</code>为<code>#pane-news</code>的<code>&lt;div</code>&gt;下面<code>&lt;ul&gt;</code>下<code>&lt;li&gt;</code>下的<code>&lt;a&gt;</code>标签中。用<code>jQuery</code>的选择器表示为：<code>#pane-news ul li a</code>。</p></blockquote><p>2、为了爬取新闻数据，首先我们要用superagent请求目标页面，获取整个新闻首页信息</p><pre><code>// 引入所需要的第三方包const superagent= require(&#39;superagent&#39;);let hotNews = [];                                // 热点新闻let localNews = [];                              // 本地新闻/** * index.js * [description] - 使用superagent.get()方法来访问百度新闻首页 */superagent.get(&#39;http://news.baidu.com/&#39;).end((err, res) =&gt; {  if (err) {    // 如果访问失败或者出错，会这行这里    console.log(`热点新闻抓取失败 - ${err}`)  } else {   // 访问成功，请求http://news.baidu.com/页面所返回的数据会包含在res   // 抓取热点新闻数据   hotNews = getHotNews(res)  }});</code></pre><p>3、获取页面信息后，我们来定义一个函数<code>getHotNews()</code>来抓取页面内的“热点新闻”数据。</p><pre><code>/** * index.js * [description] - 抓取热点新闻页面 */// 引入所需要的第三方包const cheerio = require(&#39;cheerio&#39;);let getHotNews = (res) =&gt; {  let hotNews = [];  // 访问成功，请求http://news.baidu.com/页面所返回的数据会包含在res.text中。  /* 使用cheerio模块的cherrio.load()方法，将HTMLdocument作为参数传入函数     以后就可以使用类似jQuery的$(selectior)的方式来获取页面元素   */  let $ = cheerio.load(res.text);  // 找到目标数据所在的页面元素，获取数据  $(&#39;div#pane-news ul li a&#39;).each((idx, ele) =&gt; {    // cherrio中$(&#39;selector&#39;).each()用来遍历所有匹配到的DOM元素    // 参数idx是当前遍历的元素的索引，ele就是当前便利的DOM元素    let news = {      title: $(ele).text(),        // 获取新闻标题      href: $(ele).attr(&#39;href&#39;)    // 获取新闻网页链接    };    hotNews.push(news)              // 存入最终结果数组  });  return hotNews};</code></pre><blockquote><p>这里要多说几点：</p><ol><li><code>async/await</code>据说是异步编程的终级解决方案,它可以让我们以同步的思维方式来进行异步编程。<code>Promise</code>解决了异步编程的“回调地狱”，async/await同时使异步流程控制变得友好而有清晰，有兴趣的同学可以去了解学习一下，真的很好用。</li><li><code>superagent</code>模块提供了很多比如<code>get</code>、<code>post</code>、<code>delte</code>等方法，可以很方便地进行Ajax请求操作。在请求结束后执行<code>.end()</code>回调函数。<code>.end()</code>接受一个函数作为参数，该函数又有两个参数<code>error和res</code>。当请求失败，<code>error</code>会包含返回的错误信息，请求成功，<code>error</code>值为<code>null</code>，返回的数据会包含在<code>res</code>参数中。</li><li><code>cheerio</code>模块的<code>.load()</code>方法，将<code>HTML document</code>作为参数传入函数，以后就可以使用类似jQuery的$(selectior)的方式来获取页面元素。同时可以使用类似于<code>jQuery</code>中的<code>.each()</code>来遍历元素。此外，还有很多方法，大家可以自行Google/Baidu。</li></ol></blockquote><p>4、将抓取的数据返回给前端浏览器</p><blockquote><p>前面，<code>const app = express();</code>实例化了一个<code>express</code>对象<code>app</code>。<br><code>app.get(&#39;&#39;, async() =&gt; {})</code>接受两个参数，第一个参数接受一个String类型的路由路径，表示Ajax的请求路径。第二个参数接受一个函数Function，当请求此路径时就会执行这个函数中的代码。</p></blockquote><pre><code>/** * [description] - 跟路由 */// 当一个get请求 http://localhost:3000时，就会后面的async函数app.get(&#39;/&#39;, async (req, res, next) =&gt; {  res.send(hotNews);});</code></pre><blockquote><p>在DOS中项目根目录<code>baiduNews</code>下执行<code>node index.js</code>,让项目跑起来。之后，打开浏览器，访问<code>http://localhost:3000</code>,你就会发现抓取到的数据返回到了前端页面。我运行代码后浏览器展示的返回信息如下：<br><strong>注：因为我的<code>Chrome</code><a href="https://www.cnblogs.com/whycxb/p/7126116.html" target="_blank" rel="noopener">安装了JSONView扩展程序</a>，所以返回的数据在页面展示的时候会被自动格式化为结构性的JSON格式，方便查看。</strong></p></blockquote><p><img src="/medias/article/coding/news-spider/9.jpg" alt="热点新闻抓取结果"></p><p><strong>OK！！这样，一个简单的百度<code>“热点新闻”</code>的爬虫就大功告成啦！！</strong></p><blockquote><p>简单总结一下，其实步骤很简单：</p><ol><li><code>express</code>启动一个简单的<code>Http</code>服务</li><li>分析目标页面<code>DOM</code>结构，找到所要抓取的信息的相关<code>DOM</code>元素</li><li>使用<code>superagent</code>请求目标页面</li><li>使用<code>cheerio</code>获取页面元素，获取目标数据</li><li>返回数据到前端浏览器</li></ol></blockquote><p><strong>现在，继续我们的目标，抓取<code>“本地新闻”</code>数据（编码过程中，我们会遇到一些有意思的问题）</strong><br>有了前面的基础，我们自然而然的会想到利用和上面相同的方法“本地新闻”数据。<br>1、 分析页面中“本地新闻”部分的<code>DOM</code>结构，如下图：</p><p><img src="/medias/article/coding/news-spider/10.jpg" alt="百度新闻本地新闻"></p><blockquote><p><code>F12</code>打开控制台，审查“本地新闻”<code>DOM</code>元素，我们发现，“本地新闻”分为两个主要部分，“左侧新闻”和右侧的“新闻资讯”。这所有目标数据都在<code>id</code>为<code>#local_news</code>的<code>div</code>中。“左侧新闻”数据又在<code>id</code>为<code>#localnews-focus</code>的<code>ul</code>标签下的<code>li</code>标签下的<code>a</code>标签中，包括新闻标题和页面链接。“本地资讯”数据又在<code>id</code>为<code>#localnews-zixun</code>的<code>div</code>下的<code>ul</code>标签下的<code>li</code>标签下的<code>a</code>标签中，包括新闻标题和页面链接。</p></blockquote><p>2、OK！分析了<code>DOM</code>结构，确定了数据的位置，接下来和爬取<code>“热点新闻”</code>一样，按部就班，定义一个<code>getLocalNews()</code>函数，爬取这些数据。</p><pre><code>/** * [description] - 抓取本地新闻页面 */let getLocalNews = (res) =&gt; {  let localNews = [];  let $ = cheerio.load(res);  // 本地新闻  $(&#39;ul#localnews-focus li a&#39;).each((idx, ele) =&gt; {    let news = {      title: $(ele).text(),      href: $(ele).attr(&#39;href&#39;),    };    localNews.push(news)  });  // 本地资讯  $(&#39;div#localnews-zixun ul li a&#39;).each((index, item) =&gt; {    let news = {      title: $(item).text(),      href: $(item).attr(&#39;href&#39;)    };    localNews.push(news);  });  return localNews};</code></pre><p>对应的，在<code>superagent.get()</code>中请求页面后，我们需要调用<code>getLocalNews()</code>函数，来爬去本地新闻数据。<br><code>superagent.get()</code>函数修改为：</p><pre><code>superagent.get(&#39;http://news.baidu.com/&#39;).end((err, res) =&gt; {  if (err) {    // 如果访问失败或者出错，会这行这里    console.log(`热点新闻抓取失败 - ${err}`)  } else {   // 访问成功，请求http://news.baidu.com/页面所返回的数据会包含在res   // 抓取热点新闻数据   hotNews = getHotNews(res)   localNews = getLocalNews(res)  }});</code></pre><p>同时，我们要在<code>app.get()</code>路由中也要将数据返回给前端浏览器。<code>app.get()</code>路由代码修改为：</p><pre><code>/** * [description] - 跟路由 */// 当一个get请求 http://localhost:3000时，就会后面的async函数app.get(&#39;/&#39;, async (req, res, next) =&gt; {  res.send({    hotNews: hotNews,    localNews: localNews  });});</code></pre><blockquote><p>编码完成，激动不已！！<code>DOS</code>中让项目跑起来，用浏览器访问<code>http://localhost:3000</code></p></blockquote><p><strong>尴尬的事情发生了！！返回的数据只有热点新闻，而本地新闻返回一个空数组<code>[ ]</code>。检查代码，发现也没有问题，但为什么一直返回的空数组呢？</strong><br><strong>经过一番原因查找，才返现问题出在哪里！！</strong></p><h3 id="一个有意思的问题"><a href="#一个有意思的问题" class="headerlink" title="一个有意思的问题"></a>一个有意思的问题</h3><blockquote><p>为了找到原因，首先，我们看看用<code>superagent.get(&#39;http://news.baidu.com/&#39;).end((err, res) =&gt; {})</code>请求百度新闻首页在回调函数<code>.end()</code>中的第二个参数res中到底拿到了什么内容？</p></blockquote><pre><code>// 新定义一个全局变量 pageReslet pageRes = {};        // supergaent页面返回值// superagent.get()中将res存入pageRessuperagent.get(&#39;http://news.baidu.com/&#39;).end((err, res) =&gt; {  if (err) {    // 如果访问失败或者出错，会这行这里    console.log(`热点新闻抓取失败 - ${err}`)  } else {    // 访问成功，请求http://news.baidu.com/页面所返回的数据会包含在res    // 抓取热点新闻数据    // hotNews = getHotNews(res)    // localNews = getLocalNews(res)    pageRes = res  }});// 将pageRes返回给前端浏览器，便于查看app.get(&#39;/&#39;, async (req, res, next) =&gt; {  res.send({    // {}hotNews: hotNews,    // localNews: localNews,    pageRes: pageRes  });});</code></pre><blockquote><p>访问浏览器<code>http://localhost:3000</code>，页面展示如下内容：</p></blockquote><p><img src="/medias/article/coding/news-spider/11.jpg" alt="superagent.get()请求返回值"></p><blockquote><p>可以看到，返回值中的<code>text</code>字段应该就是整个页面的<code>HTML</code>代码的字符串格式。为了方便我们观察，可以直接把这个<code>text</code>字段值返回给前端浏览器，这样我们就能够清晰地看到经过浏览器渲染后的页面。</p></blockquote><p>修改给前端浏览器的返回值</p><pre><code>app.get(&#39;/&#39;, async (req, res, next) =&gt; {  res.send(pageRes.text)}</code></pre><p>访问浏览器<code>http://localhost:3000</code>，页面展示如下内容：</p><p><img src="/medias/article/coding/news-spider/12.jpg" alt="本地新闻返回页面"></p><blockquote><p>审查元素才发现，原来我们抓取的目标数据所在的<code>DOM</code>元素中是空的，里面没有数据！<br>到这里，一切水落石出！在我们使用<code>superagent.get()</code>访问百度新闻首页时，<code>res</code>中包含的获取的页面内容中，我们想要的“本地新闻”数据还没有生成，<code>DOM</code>节点元素是空的，所以出现前面的情况！抓取后返回的数据一直是空数组<code>[ ]</code>。</p></blockquote><p><img src="/medias/article/coding/news-spider/13.jpg" alt="本地新闻请求接口"></p><blockquote><p>在控制台的<code>Network</code>中我们发现页面请求了一次这样的接口：<br><code>http://localhost:3000/widget?id=LocalNews&amp;ajax=json&amp;t=1526295667917</code>，接口状态 <code>404</code>。<br>这应该就是百度新闻获取<code>“本地新闻”</code>的接口，到这里一切都明白了！“本地新闻”是在页面加载后动态请求上面这个接口获取的，所以我们用<code>superagent.get()</code>请求的页面再去请求这个接口时，接口<code>URL</code>中<code>hostname</code>部分变成了本地<code>IP</code>地址，而本机上没有这个接口，所以<code>404</code>，请求不到数据。</p></blockquote><p><strong>找到原因，我们来想办法解决这个问题！！</strong></p><blockquote><ol><li>直接使用<code>superagen</code>t访问正确合法的百度<code>“本地新闻”</code>的接口，获取数据后返回给前端浏览器。</li><li>使用第三方<code>npm</code>包，模拟浏览器访问百度新闻首页，在这个模拟浏览器中当<code>“本地新闻”</code>加载成功后，抓取数据，返回给前端浏览器。</li></ol></blockquote><p><strong>以上方法均可，我们来试试比较有意思的第二种方法</strong></p><h3 id="使用Nightmare自动化测试工具"><a href="#使用Nightmare自动化测试工具" class="headerlink" title="使用Nightmare自动化测试工具"></a>使用<code>Nightmare</code>自动化测试工具</h3><blockquote><p><code>Electron</code>可以让你使用纯<code>JavaScript</code>调用<code>Chrome</code>丰富的原生的接口来创造桌面应用。你可以把它看作一个专注于桌面应用的<code>Node.js</code>的变体，而不是<code>Web</code>服务器。其基于浏览器的应用方式可以极方便的做各种响应式的交互</p></blockquote><blockquote><p><code>Nightmare</code>是一个基于<code>Electron</code>的框架，针对<code>Web</code>自动化测试和爬虫，因为其具有跟<code>PlantomJS</code>一样的自动化测试的功能可以在页面上模拟用户的行为触发一些异步数据加载，也可以跟<code>Request</code>库一样直接访问<code>URL</code>来抓取数据，并且可以设置页面的延迟时间，所以无论是手动触发脚本还是行为触发脚本都是轻而易举的。</p></blockquote><h4 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h4><pre><code>// 安装nightmareyarn add nightmare</code></pre><h4 id="为获取“本地新闻”，继续coding…"><a href="#为获取“本地新闻”，继续coding…" class="headerlink" title="为获取“本地新闻”，继续coding…"></a>为获取“本地新闻”，继续coding…</h4><p>给<code>index.js</code>中新增如下代码：</p><pre><code>const Nightmare = require(&#39;nightmare&#39;);          // 自动化测试包，处理动态页面const nightmare = Nightmare({ show: true });     // show:true  显示内置模拟浏览器/** * [description] - 抓取本地新闻页面 * [nremark] - 百度本地新闻在访问页面后加载js定位IP位置后获取对应新闻， * 所以抓取本地新闻需要使用 nightmare 一类的自动化测试工具， * 模拟浏览器环境访问页面，使js运行，生成动态页面再抓取 */// 抓取本地新闻页面nightmare.goto(&#39;http://news.baidu.com/&#39;).wait(&quot;div#local_news&quot;).evaluate(() =&gt; document.querySelector(&quot;div#local_news&quot;).innerHTML).then(htmlStr =&gt; {  // 获取本地新闻数据  localNews = getLocalNews(htmlStr)}).catch(error =&gt; {  console.log(`本地新闻抓取失败 - ${error}`);})</code></pre><p>修改<code>getLocalNews()</code>函数为：</p><pre><code>/** * [description]- 获取本地新闻数据 */let getLocalNews = (htmlStr) =&gt; {  let localNews = [];  let $ = cheerio.load(htmlStr);  // 本地新闻  $(&#39;ul#localnews-focus li a&#39;).each((idx, ele) =&gt; {    let news = {      title: $(ele).text(),      href: $(ele).attr(&#39;href&#39;),    };    localNews.push(news)  });  // 本地资讯  $(&#39;div#localnews-zixun ul li a&#39;).each((index, item) =&gt; {    let news = {      title: $(item).text(),      href: $(item).attr(&#39;href&#39;)    };    localNews.push(news);  });  return localNews}</code></pre><p>修改<code>app.get(&#39;/&#39;)</code>路由为：</p><pre><code>/** * [description] - 跟路由 */// 当一个get请求 http://localhost:3000时，就会后面的async函数app.get(&#39;/&#39;, async (req, res, next) =&gt; {  res.send({    hotNews: hotNews,    localNews: localNews  })});</code></pre><blockquote><p>此时，<code>DOS</code>命令行中重新让项目跑起来，浏览器访问<code>https://localhost:3000</code>，看看页面展示的信息，看是否抓取到了<code>“本地新闻”</code>数据！</p></blockquote><p><strong>至此，一个简单而又完整的抓取百度新闻页面“热点新闻”和“本地新闻”的爬虫就大功告成啦！！</strong></p><p><strong>最后总结一下，整体思路如下：</strong></p><blockquote><ol><li><code>express</code>启动一个简单的<code>Http</code>服务</li><li>分析目标页面<code>DOM</code>结构，找到所要抓取的信息的相关<code>DOM元</code>素</li><li>使用<code>superagent</code>请求目标页面</li><li><strong>动态页面（需要加载页面后运行<code>JS</code>或请求接口的页面）可以使用<code>Nightmare</code>模拟浏览器访问</strong></li><li>使用<code>cheerio</code>获取页面元素，获取目标数据</li></ol></blockquote><p>###完整代码</p><blockquote><p>爬虫完整代码GitHub地址：<a href="https://github.com/webCaolixin/news-Spider" target="_blank" rel="noopener">完整代码</a></p></blockquote><p><strong><em>后面，应该还会做一些进阶，来爬取某些网站上比较好看的图片（手动滑稽），会牵扯到<code>并发控制</code>和<code>反-反爬虫</code>的一些策略。再用爬虫取爬去一些需要登录和输入验证码的网站，欢迎到时大家关注和指正交流。</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.JS </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
